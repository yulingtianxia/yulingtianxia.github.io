<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yulingtianxia&#39;s blog</title>
  
  <subtitle>玉令天下的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yulingtianxia.com/"/>
  <updated>2019-08-31T18:23:40.335Z</updated>
  <id>http://yulingtianxia.com/</id>
  
  <author>
    <name>杨萧玉</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>App 二进制文件重排已经被玩坏了</title>
    <link href="http://yulingtianxia.com/blog/2019/09/01/App-Order-Files/"/>
    <id>http://yulingtianxia.com/blog/2019/09/01/App-Order-Files/</id>
    <published>2019-08-31T16:47:39.000Z</published>
    <updated>2019-08-31T18:23:40.335Z</updated>
    
    <content type="html"><![CDATA[<p>『二进制文件重排优化启动速度』本是一项上古 PC 时代就玩的烂大街的东东，前一阵子借助某宇宙大厂重新火了一把。不过令我惊讶的是：这么简单个事情竟然搞得如此复杂，而且还声称『开拓性的探索、在没有业界经验可供参考』。。。</p><p><del>说真话可能会得罪人，但是我怕过吗？</del> 我怂了，这段掐了。</p><p>其实二进制文件重排很简单啊，我基于 Clang SanitizerCoverage 和业界已有的经验，整了个 <a href="https://github.com/yulingtianxia/AppOrderFiles" target="_blank" rel="noopener">AppOrderFiles</a>，一个调用搞定！Enjoy it！</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AppOrderFiles(^(<span class="built_in">NSString</span> *orderFilePath) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"OrderFilePath:%@"</span>, orderFilePath);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="苹果官方文档的古老方案"><a href="#苹果官方文档的古老方案" class="headerlink" title="苹果官方文档的古老方案"></a>苹果官方文档的古老方案</h2><p>苹果的官方文档很早就给了二进制文件重排的方案：<a href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/CodeFootprint/Articles/ImprovingLocality.html#//apple_ref/doc/uid/20001862-117091-BCIBJEBH" target="_blank" rel="noopener">Improving Locality of Reference</a>，『早』到甚至被苹果提示这份文档已经年久失修，部分工具和链接失效了。文档的过时不仅体现在还是 GCC 时代，连工具链比如像 ‘gprof’ 也不能用了，不过 Google 也给出了 macOS 上的替代品，有兴趣的可以去研究下。</p><h2 id="基于-Clang-SanitizerCoverage-的方案"><a href="#基于-Clang-SanitizerCoverage-的方案" class="headerlink" title="基于 Clang SanitizerCoverage 的方案"></a>基于 Clang SanitizerCoverage 的方案</h2><p>在 <a href="https://clang.llvm.org/docs/SanitizerCoverage.html#tracing-pcs" target="_blank" rel="noopener">Clang 10 documentation</a> 中可以看到 LLVM 官方对 SanitizerCoverage 的详细介绍，包含了示例代码。</p><p>简单来说 SanitizerCoverage 是 Clang 内置的一个代码覆盖工具。它把一系列以 <code>__sanitizer_cov_trace_pc_</code> 为前缀的函数调用插入到用户定义的函数里，借此实现了全局 AOP 的大杀器。其覆盖之广，包含 Swift/Objective-C/C/C++ 等语言，Method/Function/Block 全支持。</p><p>开启 SanitizerCoverage 的方法是：在 build settings 里的 “Other C Flags” 中添加 <code>-fsanitize-coverage=func,trace-pc-guard</code>。如果含有 Swift 代码的话，还需要在 “Other Swift Flags” 中加入 <code>-sanitize-coverage=func</code> 和 <code>-sanitize=undefined</code>。所有链接到 App 中的二进制都需要开启 SanitizerCoverage，这样才能完全覆盖到所有调用。</p><p>基于 Clang SanitizerCoverage 我写了个工具 AppOrderFiles。CocoaPods 接入，一行调用生成 Order File。啥也不说了，全在 GayHub 里了：<a href="https://github.com/yulingtianxia/AppOrderFiles" target="_blank" rel="noopener">https://github.com/yulingtianxia/AppOrderFiles</a></p><p>当然这也不完全是我的原创，对照着 Clang 文档的同时，还参考了 <a href="https://medium.com/@michael.eisel/improving-app-performance-with-order-files-c7fff549907f" target="_blank" rel="noopener">Improving App Performance with Order Files</a> 这篇文章的代码。人家这篇文章虽然早就给出了，不过还是有一些 bug 和优化空间的。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>苹果官方也提供了 PGO 的详细文档，而且操作很简单。不过它跟二进制文件重排还是有区别的，这里不展开讲了。毕竟相对于对业务代码加载优先级的优化来说，PGO 对启动优化性价比没那么高，应该就是高频调用函数内联之类的（这句纯属瞎扯）。</p><p>我为啥过了这么久才发此文呢？猜猜原因是啥：</p><p>A. 不爱蹭热度<br>B. 喜欢炒冷饭<br>C. 忙晋升答辩<br>D. 8 月发过文章了，这篇得等 9 月才能发，这样不浪费</p><p>碰到不会的题，我一般三短一长选最长，大鹏老师说《都选C》。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;『二进制文件重排优化启动速度』本是一项上古 PC 时代就玩的烂大街的东东，前一阵子借助某宇宙大厂重新火了一把。不过令我惊讶的是：这么简单个事情竟然搞得如此复杂，而且还声称『开拓性的探索、在没有业界经验可供参考』。。。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;说真话可能会得罪人，但是我怕过吗？&lt;/del&gt; 我怂了，这段掐了。&lt;/p&gt;
&lt;p&gt;其实二进制文件重排很简单啊，我基于 Clang SanitizerCoverage 和业界已有的经验，整了个 &lt;a href=&quot;https://github.com/yulingtianxia/AppOrderFiles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AppOrderFiles&lt;/a&gt;，一个调用搞定！Enjoy it！&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;AppOrderFiles(^(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *orderFilePath) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;OrderFilePath:%@&quot;&lt;/span&gt;, orderFilePath);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="瞎折腾" scheme="http://yulingtianxia.com/tags/%E7%9E%8E%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>BlockHook with Invocation(2)</title>
    <link href="http://yulingtianxia.com/blog/2019/08/11/BlockHook-with-Invocation-2/"/>
    <id>http://yulingtianxia.com/blog/2019/08/11/BlockHook-with-Invocation-2/</id>
    <published>2019-08-11T14:18:51.000Z</published>
    <updated>2019-08-14T03:04:30.649Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://yulingtianxia.com/blog/2019/07/27/BlockHook-with-Invocation/">上一篇文章</a> 简单介绍了下 <code>retainArguments</code> 和 <code>block_interceptor</code> 实现的思路，本文会详细讲解下 <code>BHInvocation</code> 的接口设计与实现，并与系统的 <code>NSInvocation</code> 作对比。</p><a id="more"></a><h2 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h2><p><code>BHInvocation</code> 相当于是参照 <code>NSInvocation</code> 的接口并改造了下，以承载 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 的一些元数据。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BHInvocation</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">weak</span>) BHToken *token;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) BlockHookMode mode;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">getter</span>=isArgumentsRetained, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> argumentsRetained;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSMethodSignature</span> *methodSignature;</span><br><span class="line">- (<span class="keyword">void</span>)invokeOriginalBlock; <span class="comment">// 替代 invoke 和 invokeWithTarget:</span></span><br><span class="line">- (<span class="keyword">void</span>)retainArguments;</span><br><span class="line">- (<span class="keyword">void</span>)getReturnValue:(<span class="keyword">void</span> *)retLoc;</span><br><span class="line">- (<span class="keyword">void</span>)setReturnValue:(<span class="keyword">void</span> *)retLoc;</span><br><span class="line">- (<span class="keyword">void</span>)getArgument:(<span class="keyword">void</span> *)argumentLocation atIndex:(<span class="built_in">NSInteger</span>)idx;</span><br><span class="line">- (<span class="keyword">void</span>)setArgument:(<span class="keyword">void</span> *)argumentLocation atIndex:(<span class="built_in">NSInteger</span>)idx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="BlockHook-相关的接口"><a href="#BlockHook-相关的接口" class="headerlink" title="BlockHook 相关的接口"></a>BlockHook 相关的接口</h3><p>为了存储 Hook 相关的信息，需要在 <code>NSInvocation</code> 的接口基础上新增 <code>token</code> 属性和 <code>mode</code> 属性。不过 <code>BHToken</code> 其实已经存储了 <code>BlockHookMode</code>，为何还要再在 <code>BHInvocation</code> 中加一个 <code>mode</code> 呢？</p><p><code>BHToken</code> 存储的是一次 Hook 行为的元数据；<code>BHInvocation</code> 存储的是 Hook 后 Block 执行时的元数据。<code>BHToken</code> 存储的 <code>mode</code> 是 Hook 的模式，可能包含了多种模式；而 <code>BHInvocation</code> 存储的 <code>mode</code> 则是当前这次 Hook 执行回调所处的时机。</p><p>例如同时 Hook Block 执行的前后，此时传入的 <code>mode</code> 值为 <code>BlockHookModeBefore|BlockHookModeAfter</code>，生成的 <code>BHToken</code> 的值也是一样。而 Block 执行前后会有两次回调，传入的 <code>BHInvocation</code> 参数内容却不太一样：其 <code>mode</code> 分别为 <code>BlockHookModeBefore</code> 和 <code>BlockHookModeAfter</code>。但这两次传入的 <code>BHInvocation</code> 中的 <code>token</code> 确是完全一样。</p><p><code>BHToken</code> 也是初始化 <code>BHInvocation</code> 所用到的唯一参数。</p><p>由于是 Hook，所以执行 Block 时需要注意是调用原始实现还是新的实现。 加入了 <code>invokeOriginalBlock</code> 接口来调用原始实现，这也是所有 AOP 工具的必要设计。</p><h3 id="NSInvocation-相关的接口"><a href="#NSInvocation-相关的接口" class="headerlink" title="NSInvocation 相关的接口"></a><code>NSInvocation</code> 相关的接口</h3><p>为了降低使用者的学习成本，<a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 的接口设计上会尽量参照一些已有的 AOP 工具。在 Invocation 这块，能参照的最好的例子就是系统提供的 <code>NSInvocation</code>。其提供了<strong>读、写和 <code>retian</code> 参数列表/返回值</strong>的接口，以及方法签名等。</p><p>而 <code>NSInvocation</code> 有些接口在 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 中是用不到的，比如 <code>selector</code> 属性没什么意义，再比如 <code>invoke</code> 和 <code>invokeWithTarget:</code> 这两个接口在 AOP 场景下也不必存在。</p><h2 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h2><p>在<a href="http://yulingtianxia.com/blog/2019/07/27/BlockHook-with-Invocation/">上一篇文章</a>中介绍了过了 <code>retainArguments</code> 的实现思路，针对每个指向参数或返回值的指针都需要经历 “Copy” 和 “Retain” 两步：</p><p><img src="https://github.com/yulingtianxia/Blog-Hexo-Source/blob/master/source/resources/BlockHook/retainArguments.png?raw=true" alt></p><h3 id="Copy-Pointer"><a href="#Copy-Pointer" class="headerlink" title="Copy Pointer"></a>Copy Pointer</h3><p>无论 <code>pointer</code> 指向的内容是一个 <code>struct</code> 还是 <code>NSObject *</code>，都需要将 <code>pointer</code> 的内容拷贝，防止原始内存被修改或者释放。在拷贝前需要开辟新的内存，其生命周期与 <code>BHInvocation</code> 绑定在一起。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span> *)_copyPointer:(<span class="keyword">void</span> **)pointer encode:(<span class="keyword">const</span> <span class="keyword">char</span> *)encode key:(<span class="built_in">NSNumber</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> pointerSize;</span><br><span class="line">    <span class="built_in">NSGetSizeAndAlignment</span>(encode, &amp;pointerSize, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">NSMutableData</span> *pointerData = [<span class="built_in">NSMutableData</span> dataWithLength:pointerSize];</span><br><span class="line">    <span class="keyword">self</span>.mallocMap[key] = pointerData;</span><br><span class="line">    <span class="keyword">void</span> *pointerBuf = pointerData.mutableBytes;</span><br><span class="line">    memcpy(pointerBuf, pointer, pointerSize);</span><br><span class="line">    <span class="keyword">return</span> pointerBuf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Retain-Pointer"><a href="#Retain-Pointer" class="headerlink" title="Retain Pointer"></a>Retain Pointer</h3><p>如果 <code>pointer</code> 指向的内容依然是个指针，比如 <code>NSObject *</code> 或 <code>char *</code>，还需要防止其内容提前被释放，产生野指针。这里相当于是对 Objective-C 对象和 C-String 的特殊处理，以参数和返回值的 index 作为 key，利用字典 <code>retainMap</code> 强引用 Objective-C 对象；对于 Block 对象还需调用 <code>copy</code> 方法，将栈上的 Block 拷贝到堆上防止被提早释放；对于 C-String 则是开辟新内存并拷贝字符串内容，然后放入 <code>retainMap</code> 中；</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)_retainPointer:(<span class="keyword">void</span> **)pointer encode:(<span class="keyword">const</span> <span class="keyword">char</span> *)encode key:(<span class="built_in">NSNumber</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *p = *pointer;</span><br><span class="line">    <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (encode[<span class="number">0</span>] == <span class="string">'@'</span>) &#123;</span><br><span class="line">        <span class="keyword">id</span> arg = (__bridge <span class="keyword">id</span>)p;</span><br><span class="line">        <span class="keyword">if</span> (strcmp(encode, <span class="string">"@?"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.retainMap[key] = [arg <span class="keyword">copy</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.retainMap[key] = arg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (encode[<span class="number">0</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> *arg = p;</span><br><span class="line">        <span class="built_in">NSMutableData</span> *data = [<span class="built_in">NSMutableData</span> dataWithLength:<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * strlen(arg)];</span><br><span class="line">        <span class="keyword">self</span>.retainMap[key] = data;</span><br><span class="line">        <span class="keyword">char</span> *str = data.mutableBytes;</span><br><span class="line">        strcpy(str, arg);</span><br><span class="line">        *pointer = str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读写参数和返回值"><a href="#读写参数和返回值" class="headerlink" title="读写参数和返回值"></a>读写参数和返回值</h3><p><a href="http://yulingtianxia.com/blog/2019/07/27/BlockHook-with-Invocation/">上一篇文章</a>讲述了 <code>BHInvocation</code> 存储参数列表和返回值上的一些处理策略，这里来讲讲如何读写。</p><p>在实现读写参数列表和返回值接口时，不仅仅是对 <code>args</code> 和 <code>retValue</code> 指针的读写操作，还要考虑到 Copy Pointer 和 Retain Pointer。</p><p>Copy Pointer 这步无需自行开辟内存了，原因是写入时 <code>retainArguments</code> 的时候已经开辟好了，读取时直接使用传入的指针。</p><p>Retain Pointer 接口使用 <code>idx</code> 作为 key，写入新的值时会替换字典 <code>retainMap</code> 中的旧值。这样既可以释放旧值，也能重新 retain 新值。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)getArgument:(<span class="keyword">void</span> *)argumentLocation atIndex:(<span class="built_in">NSInteger</span>)idx</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!argumentLocation || !<span class="keyword">self</span>.args || !<span class="keyword">self</span>.args[idx]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> *arg = <span class="keyword">self</span>.args[idx];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *type = [<span class="keyword">self</span>.methodSignature getArgumentTypeAtIndex:idx];</span><br><span class="line">    <span class="built_in">NSUInteger</span> argSize;</span><br><span class="line">    <span class="built_in">NSGetSizeAndAlignment</span>(type, &amp;argSize, <span class="literal">NULL</span>);</span><br><span class="line">    memcpy(argumentLocation, arg, argSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setArgument:(<span class="keyword">void</span> *)argumentLocation atIndex:(<span class="built_in">NSInteger</span>)idx</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!argumentLocation || !<span class="keyword">self</span>.args || !<span class="keyword">self</span>.args[idx]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> *arg = <span class="keyword">self</span>.args[idx];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *type = [<span class="keyword">self</span>.methodSignature getArgumentTypeAtIndex:idx];</span><br><span class="line">    <span class="built_in">NSUInteger</span> argSize;</span><br><span class="line">    <span class="built_in">NSGetSizeAndAlignment</span>(type, &amp;argSize, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isArgumentsRetained) &#123;</span><br><span class="line">        [<span class="keyword">self</span> _retainPointer:argumentLocation encode:type key:@(idx)];</span><br><span class="line">    &#125;</span><br><span class="line">    memcpy(arg, argumentLocation, argSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ARC 下从 <code>NSInvocation</code> 读取参数或返回值时，如果类型为 Objective-C 对象，则需要避免默认的强引用。<a href="https://stackoverflow.com/questions/16928299/get-block-argument-from-nsinvocation-with-arc" target="_blank" rel="noopener">Stack Overflow</a> 上有具体解决方案，其中的一种方案如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSObject * __unsafe_unretained <span class="keyword">arg</span>;</span><br><span class="line">[invocation getArgument:&amp;<span class="keyword">arg</span> atIndex:<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p><code>BHInvocation</code> 由于高仿了 <code>NSInvocation</code> 的接口和实现，所以也需要注意此问题。究其原因在于 <code>memcpy</code> 只是内存拷贝，不是直接向 <code>strong</code> 类型变量赋值，并不会参与到 ARC 的引用计数中。而出了作用域后 ARC 会自动对 <code>strong</code> 类型 <code>release</code> 一次，导致读取到的对象过度释放，导致 crash。（PS：ARC 真实的实现机制会更复杂些，为了描述方便这里对原理进行了简化）</p><p>其实还有一种更好的方式读参数，那就是直接在 <code>aspectBlock</code> 中取参数。<code>aspectBlock</code> 中的参数是可以随意写的，但需要跟 Block 的参数列表对应上。写法可以参照下面这个测试用例，直接获取参数，然后修改参数：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testObjectArg &#123;</span><br><span class="line">    <span class="built_in">NSObject</span> *argOrig = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    <span class="built_in">NSObject</span> *argFixed = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    <span class="keyword">void</span> (^ObjectArgBlock)(<span class="built_in">NSObject</span> *) = ^(<span class="built_in">NSObject</span> *test)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSAssert</span>(test == argFixed, <span class="string">@"Modify struct member failed!"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    [ObjectArgBlock block_hookWithMode:BlockHookModeBefore usingBlock:^(BHInvocation *invocation, <span class="built_in">NSObject</span> *test)&#123;</span><br><span class="line">        <span class="built_in">NSAssert</span>(test == argOrig, <span class="string">@"Wrong arg!"</span>);</span><br><span class="line">        <span class="comment">// Hook 改参数</span></span><br><span class="line">        [invocation setArgument:(<span class="keyword">void</span> *)&amp;argFixed atIndex:<span class="number">1</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    ObjectArgBlock(argOrig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最初 <code>BHInvocation</code> 还不够完善时，读写 Block 的参数/返回值只能用二级指针之类的晦涩语法直接操作 <code>args</code> 和 <code>retValue</code>，门槛较高而且还不够安全。<code>BHInvocation</code> 接口设计和实现上尽量参考已有的成熟案例，降低开发者学习成本，快速上手。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2019/07/27/BlockHook-with-Invocation/&quot;&gt;上一篇文章&lt;/a&gt; 简单介绍了下 &lt;code&gt;retainArguments&lt;/code&gt; 和 &lt;code&gt;block_interceptor&lt;/code&gt; 实现的思路，本文会详细讲解下 &lt;code&gt;BHInvocation&lt;/code&gt; 的接口设计与实现，并与系统的 &lt;code&gt;NSInvocation&lt;/code&gt; 作对比。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yulingtianxia.com/tags/Objective-C/"/>
    
      <category term="Runtime" scheme="http://yulingtianxia.com/tags/Runtime/"/>
    
      <category term="BlockHook" scheme="http://yulingtianxia.com/tags/BlockHook/"/>
    
  </entry>
  
  <entry>
    <title>BlockHook with Invocation(1)</title>
    <link href="http://yulingtianxia.com/blog/2019/07/27/BlockHook-with-Invocation/"/>
    <id>http://yulingtianxia.com/blog/2019/07/27/BlockHook-with-Invocation/</id>
    <published>2019-07-27T09:14:27.000Z</published>
    <updated>2019-08-11T14:20:22.195Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 在业界已经率先解决了在<strong>同步</strong>调用场景下对 Objective-C Block 的 AOP 问题。但也有很多场景是需要先调用一段自己的逻辑，然后再<strong>异步延时</strong>执行 Block。</p><p>比如从外部跳转到 App 某个页面前需要检查下登录态，如果未登录则需要走完登录流程后才能继续跳转页面，而几乎所有基于 Block callback 的路由组件都没提供路由拦截器的功能。不同的路由组件内部实现不同，想要实现拦截器就需要针对不同的内部实现来修改路由组件源码。</p><p>因此我实现了 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 的异步拦截功能，所有基于 Block 的路由组件就都有了通用的路由拦截器！</p><p>当然，Block 拦截器的应用场景不仅于此。只要是需要『同步改异步执行』 Block 的场景都可以用到。</p><p>让子弹再飞一会儿！</p><a id="more"></a><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p><a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 拦截器用法很简单，在已有 <code>BHInvocation</code> 参数的基础上，增加了一个 <code>completion</code> 回调。当拦截器的逻辑异步执行完后，调用 <code>completion</code> 即可继续执行原来的 Block。如果拦截器的逻辑是同步的，也依然可以用这个接口，只是没必要罢了，推荐直接用原来的 <code>block_hookWithMode:usingBlock:</code> 接口。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^IntercepterCompletion)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Interceptor for blocks. When your interceptor completed, call `completion` callback.</span></span><br><span class="line"><span class="comment"> You can call `completion` asynchronously!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param interceptor You **MUST** call `completion` callback in interceptor, unless you want to cancel invocation.</span></span><br><span class="line"><span class="comment"> @return BHToken instance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (BHToken *)block_interceptor:(<span class="keyword">void</span> (^)(BHInvocation *invocation, IntercepterCompletion completion))interceptor;</span><br></pre></td></tr></table></figure><p>举个例子，拦截时修改传入的参数，并延迟 0.5 秒再执行 Block：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *testArg = [<span class="built_in">NSObject</span> new];</span><br><span class="line"><span class="built_in">NSObject</span> *testArg1 = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSObject</span> *(^testblock)(<span class="built_in">NSObject</span> *) = ^(<span class="built_in">NSObject</span> *a) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSObject</span> new];</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">[testblock block_interceptor:^(BHInvocation *invocation, IntercepterCompletion  _Nonnull completion) &#123;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">0.5</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        *(<span class="keyword">void</span> **)(invocation.args[<span class="number">1</span>]) = (__bridge <span class="keyword">void</span> *)(testArg1);</span><br><span class="line">        completion();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">testblock(testArg);</span><br></pre></td></tr></table></figure><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>首先想想如果要延迟一个 Objective-C 方法的执行，需要怎么做？</p><p>答案是利用消息转发机制，<code>NSInvocation</code> 调用 <code>retainArguments</code> 将方法执行所需的上下文持有，这样才能保证方法执行时所需的参数、<code>target</code> 等不会被释放。</p><p>对于 Block 来说，虽然也能通过 <code>NSInvocation</code> 来进行调用，但是经过 Hook 过后已经不再适用。因为 <code>NSInvocation</code> 的实现机制以及生命周期管理是个黑盒，且无法承载 Hook 相关的信息，需要自己来实现个 <code>BHInvocation</code>。</p><p><img src="https://github.com/yulingtianxia/Blog-Hexo-Source/blob/master/source/resources/BlockHook/BlockInterceptor.png?raw=true" alt></p><h3 id="BHInvocation-结构"><a href="#BHInvocation-结构" class="headerlink" title="BHInvocation 结构"></a>BHInvocation 结构</h3><p>我之前的 <a href="http://yulingtianxia.com/blog/2019/04/27/BlockHook-with-Struct/">BlockHook with Struct</a> 这篇文章提到了个技术点：在 x86 架构下，当 Block 返回值是大于 16 Byte 的 <code>struct</code> 时，参数列表有些变化：</p><p><img src="https://github.com/yulingtianxia/Blog-Hexo-Source/blob/master/source/resources/BlockHook/realArgs.png?raw=true" alt></p><p>为了兼容这种情况，需要两套 <code>args</code> 和 <code>retValue</code>。一套『真的』用于传给 libffi 调用原始函数指针，另一套『假的』提供给使用方读写参数和返回值。这样使用方无需关心底层特殊逻辑，直接用就行了。</p><p><code>BHInvocation</code> 主要结构如下：</p><p><img src="https://github.com/yulingtianxia/Blog-Hexo-Source/blob/master/source/resources/BlockHook/BHInvocation.png?raw=true" alt></p><p>PS：<code>BHInvocation</code> 与 <code>NSInvocation</code> 的场景和用法有些不同，所以实现上也会有差异。<code>NSInvocation</code> 没有公开源码，想了解原理的可以看看 mikeash 的实现： <a href="https://github.com/mikeash/MAInvocation" target="_blank" rel="noopener">MAInvocation</a>。但我并没有参考过 mikeash 的源码，因为等我写完了才发现它。。。</p><h3 id="retainArguments-实现"><a href="#retainArguments-实现" class="headerlink" title="retainArguments 实现"></a><code>retainArguments</code> 实现</h3><p><code>retainArguments</code> 实现策略：</p><ol><li>拷贝 <code>void **args</code> 指针数组和返回值指针</li><li><code>retain</code> 指针内容类型为 Objective-C 对象的参数</li><li>如果参数中也有其他 Block 对象，则 <code>copy</code> 过来</li><li>如果参数中有 C-string，则 <code>strcpy</code> 过来</li></ol><p><img src="https://github.com/yulingtianxia/Blog-Hexo-Source/blob/master/source/resources/BlockHook/retainArguments.png?raw=true" alt></p><p>需要注意的是这里依然要考虑两套 <code>args</code> 和 <code>retValue</code> 的问题。代码就不贴了，有兴趣的可以自己去看。</p><h3 id="block-interceptor-实现"><a href="#block-interceptor-实现" class="headerlink" title="block_interceptor 实现"></a><code>block_interceptor</code> 实现</h3><p>解决了 <code>retainArguments</code> 的实现，一切都好说了。只要基于原有的 <code>block_hookWithMode:usingBlock:</code> 接口稍加改装即可：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">BHToken </span>*)<span class="keyword">block_interceptor:(void </span>(^)(<span class="keyword">BHInvocation </span>*invocation, IntercepterCompletion completion))interceptor &#123;</span><br><span class="line">    return [self <span class="keyword">block_hookWithMode:BlockHookModeInstead </span>usingBlock:^(<span class="keyword">BHInvocation </span>*invocation) &#123;</span><br><span class="line">        if (interceptor) &#123;</span><br><span class="line">            IntercepterCompletion completion = ^() &#123;</span><br><span class="line">                [invocation invokeOriginalBlock]<span class="comment">;</span></span><br><span class="line">            &#125;<span class="comment">;</span></span><br><span class="line">            interceptor(invocation, completion)<span class="comment">;</span></span><br><span class="line">            [invocation retainArguments]<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>写了这么多关于 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 的文章，我越来越发现自己在苹果爸爸面前所表现出的无知。几乎每一步都要去踩很多坑，看很多源码。而这次是看着苹果爸爸的文档脑补如何实现，业界也没有能参考的先例。</p><p>这种感觉犹如自己在黑暗中不断探索，并享受着这种孤独。</p><p>标题暗示着，这篇文章可能会有后续的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BlockHook&lt;/a&gt; 在业界已经率先解决了在&lt;strong&gt;同步&lt;/strong&gt;调用场景下对 Objective-C Block 的 AOP 问题。但也有很多场景是需要先调用一段自己的逻辑，然后再&lt;strong&gt;异步延时&lt;/strong&gt;执行 Block。&lt;/p&gt;
&lt;p&gt;比如从外部跳转到 App 某个页面前需要检查下登录态，如果未登录则需要走完登录流程后才能继续跳转页面，而几乎所有基于 Block callback 的路由组件都没提供路由拦截器的功能。不同的路由组件内部实现不同，想要实现拦截器就需要针对不同的内部实现来修改路由组件源码。&lt;/p&gt;
&lt;p&gt;因此我实现了 &lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BlockHook&lt;/a&gt; 的异步拦截功能，所有基于 Block 的路由组件就都有了通用的路由拦截器！&lt;/p&gt;
&lt;p&gt;当然，Block 拦截器的应用场景不仅于此。只要是需要『同步改异步执行』 Block 的场景都可以用到。&lt;/p&gt;
&lt;p&gt;让子弹再飞一会儿！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yulingtianxia.com/tags/Objective-C/"/>
    
      <category term="Runtime" scheme="http://yulingtianxia.com/tags/Runtime/"/>
    
      <category term="BlockHook" scheme="http://yulingtianxia.com/tags/BlockHook/"/>
    
  </entry>
  
  <entry>
    <title>BlockHook with Private Data</title>
    <link href="http://yulingtianxia.com/blog/2019/06/19/BlockHook-with-Private-Data/"/>
    <id>http://yulingtianxia.com/blog/2019/06/19/BlockHook-with-Private-Data/</id>
    <published>2019-06-19T14:50:39.000Z</published>
    <updated>2019-08-11T14:20:45.384Z</updated>
    
    <content type="html"><![CDATA[<p>在使用 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> Hook 所有 Block 对象时，发现有些 Block 被 Hook 后会 Crash。究其原因发现是它们骨骼惊奇，夹带了很多『私货』，不能直接 Hook！本文讲述 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 在处理这种 Block 时的技术原理，解开含有 Private Data 的 Block 的神秘面纱。</p><a id="more"></a><p>由于关于 Block Private Data 的资料几乎没有，所以我完全可以当回标题党，把这篇文章的标题叫做『你真的了解 Block 么？』或者『这才是 Hook Block 的正确姿势』之类的。但想想还是算了吧，怕被大佬们嘲笑称又『改变业界』了啊。</p><h2 id="Block-为何会有-Private-Data"><a href="#Block-为何会有-Private-Data" class="headerlink" title="Block 为何会有 Private Data"></a>Block 为何会有 Private Data</h2><p>首先来看一段代码：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_block_t </span><span class="keyword">block </span>= <span class="keyword">dispatch_block_create(0, </span>^&#123;</span><br><span class="line">    NSLog(@<span class="string">"I'm dispatch_block_t"</span>)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>用 <code>dispatch_block_create</code> 创建的 Block 都很特殊，返回的 Block 包含了参数里传入的 Block。此时 <code>dispatch_block_t</code> 虽然表面上是一种普通的 Block，但它的构造暗藏玄机，含有 Private Data，下面会详细解读。</p><h3 id="特殊的-invoke-函数"><a href="#特殊的-invoke-函数" class="headerlink" title="特殊的 invoke 函数"></a>特殊的 invoke 函数</h3><p>这种 Block 的 <code>invoke</code> 函数指针是固定的，函数名为 <code>___dispatch_block_create_block_invoke</code>。在 linux 系统下，函数名为 <code>__dispatch_block_create_block_invoke</code>，嗯少了个下划线。这个函数的定义来自 libdispatch.dylib，也就是我们常用的 GCD。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="comment">// The compiler hides the name of the function it generates, and changes it if</span></span><br><span class="line"><span class="comment">// we try to reference it directly, but the linker still sees it.</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">DISPATCH_BLOCK_SPECIAL_INVOKE</span><span class="params">(<span class="keyword">void</span> *)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></span></span><br><span class="line"><span class="function"><span class="title">asm</span><span class="params">(<span class="string">"___dispatch_block_create_block_invoke"</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">asm</span>(<span class="string">"____dispatch_block_create_block_invoke"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">void</span> (*<span class="keyword">const</span> _dispatch_block_special_invoke)(<span class="keyword">void</span>*) = DISPATCH_BLOCK_SPECIAL_INVOKE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>libdispatch 会通过判断 Block 的 <code>invoke</code> 指针是否为 <code>_dispatch_block_special_invoke</code>，来知道这个 Block 是否含有 Private Data。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span></span><br><span class="line">_dispatch_block_has_private_data(<span class="keyword">const</span> <span class="keyword">dispatch_block_t</span> block)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (_dispatch_Block_invoke(block) == _dispatch_block_special_invoke);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不幸的是，<code>_dispatch_block_special_invoke</code> 是私有的。在非调试场景下是无法通过 <code>dladdr</code> 等方式来获取它的函数名的。也就无法用类似上面的代码来判断 Block 是否含有 Private Data 了。</p><h3 id="获取-Private-Data"><a href="#获取-Private-Data" class="headerlink" title="获取 Private Data"></a>获取 Private Data</h3><p>使用 <code>dispatch_block_create</code> 创建的 <code>dispatch_block_t</code> 只是个『壳』，真正执行的是其内部包含的 Block。再加上 GCD 所需的一些数据（queue，group，thread，priority 等），这些数据都需要作为 Private Data 追加在 Block 上。对实现 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 来说最需要关注的就是 <code>dbpd_magic</code> 和 <code>dbpd_block</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">OS_OBJECT_DECL_CLASS(voucher);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_block_private_data_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> dbpd_magic;</span><br><span class="line">    <span class="keyword">dispatch_block_flags_t</span> dbpd_flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">volatile</span> dbpd_atomic_flags;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">volatile</span> dbpd_performed;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> dbpd_priority;</span><br><span class="line">    <span class="keyword">voucher_t</span> dbpd_voucher;</span><br><span class="line">    <span class="keyword">dispatch_block_t</span> dbpd_block;</span><br><span class="line">    <span class="keyword">dispatch_group_t</span> dbpd_group;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> dbpd_queue;</span><br><span class="line">    <span class="keyword">mach_port_t</span> dbpd_thread;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_block_private_data_s</span> *<span class="title">dispatch_block_private_data_t</span>;</span></span><br></pre></td></tr></table></figure><p>既然无法用 <code>_dispatch_block_special_invoke</code> 来判断 Block 是否含有 Private Data，可以使用 <code>dbpd_magic</code> 魔数来判断。当其值为 <code>0xD159B10C</code> 时（DisBloc 的意思），则表明含有 Private Data。<strong>当然这种溢出的方式同样是有风险的，但触及到 PAGEZERO 概率很低</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_BLOCK_PRIVATE_DATA_MAGIC 0xD159B10C <span class="comment">// 0xDISPatch_BLOCk</span></span></span><br><span class="line"></span><br><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">dispatch_block_private_data_t</span></span><br><span class="line">bh_dispatch_block_get_private_data(struct _BHBlock *block)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Keep in sync with _dispatch_block_create implementation</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *x = (<span class="keyword">uint8_t</span> *)block;</span><br><span class="line">    <span class="comment">// x points to base of struct Block_layout</span></span><br><span class="line">    x += <span class="keyword">sizeof</span>(struct _BHBlock);</span><br><span class="line">    <span class="comment">// x points to base of captured dispatch_block_private_data_s object</span></span><br><span class="line">    <span class="keyword">dispatch_block_private_data_t</span> dbpd = (<span class="keyword">dispatch_block_private_data_t</span>)x;</span><br><span class="line">    <span class="keyword">if</span> (dbpd-&gt;dbpd_magic != DISPATCH_BLOCK_PRIVATE_DATA_MAGIC) &#123;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dbpd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后真正执行的其实是 <code>dbpd_block</code> 这个 Block，<code>dispatch_block_t</code> 只是个保存各种元数据的壳。</p><h2 id="适配-BlockHook"><a href="#适配-BlockHook" class="headerlink" title="适配 BlockHook"></a>适配 BlockHook</h2><p>虽然说 Private Data 本身并不是 Block 实现中必要的一环，它只是 GCD 对 Block 数据结构的一种『魔改』扩充。但由于 GCD 内部的一些保护机制，会在修改了 Block 的 <code>invoke</code> 指针后触发 crash（<code>__builtin_trap</code>），所以不能直接对含有 Private Data 的 Block 进行 Hook。这就需要 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 组件做一些适配工作。</p><h3 id="Hook-真正要执行的-Block"><a href="#Hook-真正要执行的-Block" class="headerlink" title="Hook 真正要执行的 Block"></a>Hook 真正要执行的 Block</h3><p>既然 <code>dbpd_block</code> 才是真正要执行的 Block，那么 Hook 的时候需要先获取 Private Data，然后对其 <code>dbpd_block</code> 进行 Hook:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (BHToken *)block_hookWithMode:(BlockHookMode)mode</span><br><span class="line">                     usingBlock:(<span class="keyword">id</span>)aspectBlock</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!aspectBlock || ![<span class="keyword">self</span> block_checkValid]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> _BHBlock *bh_block = (__bridge <span class="keyword">void</span> *)<span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">if</span> (!_bh_Block_descriptor_3(bh_block)) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Block has no signature! Required ABI.2010.3.16. %@"</span>, <span class="keyword">self</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Handle blocks have private data.</span></span><br><span class="line">    dispatch_block_private_data_t dbpd = bh_dispatch_block_get_private_data(bh_block);</span><br><span class="line">    <span class="keyword">if</span> (dbpd &amp;&amp; dbpd-&gt;dbpd_block) &#123;</span><br><span class="line">        <span class="keyword">return</span> [dbpd-&gt;dbpd_block block_hookWithMode:mode usingBlock:aspectBlock];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [[BHToken alloc] initWithBlock:<span class="keyword">self</span> mode:mode aspectBlockBlock:aspectBlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取-Block-当前-Hook-Token"><a href="#获取-Block-当前-Hook-Token" class="headerlink" title="获取 Block 当前 Hook Token"></a>获取 Block 当前 Hook Token</h3><p>因为 Hook 的是 <code>dbpd_block</code>，所以获取 Token 的时候也需要额外处理下。要在 <code>dbpd_block</code> 上通过 AssociatedObject 来获取 Token，而不是 <code>dispatch_block_t</code> 上。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">BHToken </span>*)<span class="keyword">block_currentHookToken</span></span><br><span class="line"><span class="keyword">&#123;</span></span><br><span class="line"><span class="keyword"> </span>   <span class="meta">if</span> (![<span class="keyword">self </span><span class="keyword">block_checkValid]) </span>&#123;</span><br><span class="line">        return nil<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_block_private_data_t dbpd = <span class="keyword">bh_dispatch_block_get_private_data((__bridge </span><span class="keyword">struct </span>_BHBlock *)(<span class="keyword">self));</span></span><br><span class="line"><span class="keyword"> </span>   <span class="meta">if</span> (dbpd &amp;&amp; dbpd-&gt;dbpd_block) &#123;</span><br><span class="line">        return [dbpd-&gt;dbpd_block <span class="keyword">block_currentHookToken];</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line">    void *invoke = [<span class="keyword">self </span><span class="keyword">block_currentInvokeFunction];</span></span><br><span class="line"><span class="keyword"> </span>   return objc_getAssociatedObject(<span class="keyword">self, </span>invoke)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代码地址: <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">https://github.com/yulingtianxia/BlockHook</a></p><p>一图以蔽之。</p><p><img src="https://github.com/yulingtianxia/Blog-Hexo-Source/blob/master/source/resources/BlockHook/BlockHook%20PrivateData.png?raw=true" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用 &lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BlockHook&lt;/a&gt; Hook 所有 Block 对象时，发现有些 Block 被 Hook 后会 Crash。究其原因发现是它们骨骼惊奇，夹带了很多『私货』，不能直接 Hook！本文讲述 &lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BlockHook&lt;/a&gt; 在处理这种 Block 时的技术原理，解开含有 Private Data 的 Block 的神秘面纱。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yulingtianxia.com/tags/Objective-C/"/>
    
      <category term="Runtime" scheme="http://yulingtianxia.com/tags/Runtime/"/>
    
      <category term="BlockHook" scheme="http://yulingtianxia.com/tags/BlockHook/"/>
    
  </entry>
  
  <entry>
    <title>BlockHook with Revocation</title>
    <link href="http://yulingtianxia.com/blog/2019/05/26/BlockHook-with-Revocation/"/>
    <id>http://yulingtianxia.com/blog/2019/05/26/BlockHook-with-Revocation/</id>
    <published>2019-05-26T09:20:10.000Z</published>
    <updated>2019-08-11T14:21:07.747Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 开创性地解决了 Objective-C 语言界 Hook Block 的问题，但也迎来了新的问题：</p><ol><li>如何知道某个 Block 对象被谁 Hook 过？</li><li>多次 Hook 的先后顺序？</li><li>如何处理好多次 Hook 同一个 Block 后对任意一次 Hook 的撤销？</li></ol><p>这些问题也是开发者在使用时向我反馈过的问题，在这篇文章里，这些问题都将会解决。</p><p>关于 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 的原理，可以先阅读之前的文章：</p><ul><li><a href="http://yulingtianxia.com/blog/2018/02/28/Hook-Objective-C-Block-with-Libffi/">Hook Objective-C Block with Libffi</a></li><li><a href="http://yulingtianxia.com/blog/2019/04/27/BlockHook-with-Struct/">BlockHook with Struct</a></li></ul><a id="more"></a><h2 id="按顺序构造『虚拟的』-Hook-链表"><a href="#按顺序构造『虚拟的』-Hook-链表" class="headerlink" title="按顺序构造『虚拟的』 Hook 链表"></a>按顺序构造『虚拟的』 Hook 链表</h2><p>首先要有一个链表来按先后顺序记录一个 Block 对象上所有的 Hook。这个链表的格式以及持有关系也需要考虑在内。</p><p>为此我构造了一个虚拟的链表来记录 Hook 的先后关系，而不是单独创建一个链表显式的记录。首先介绍下 Block 与 token 之间的引用关系：</p><p><img src="https://raw.githubusercontent.com/yulingtianxia/Blog-Hexo-Source/master/source/resources/BlockHook/BlockHook_Token_List.png" alt></p><p>可以看出每个 <code>BHToken</code> 记录了原始和替换后的 <code>invoke</code> 函数指针，那么先后两次 Hook 就靠 <code>invoke</code> 函数指针来关联了：<strong>每个 tokne 的 <code>originalInvoke</code> 就是上一次 Hook 的 token 的 <code>replacementInvoke</code></strong>。而拿到 token 又是靠 Block 对象上的 <code>AssociatedObject</code>，且 key 为 <code>replacementInvoke</code>。这样就构造了一条虚拟的链表：想要获得上次 Hook 的 token，只需在 Hook 的 Block 对象上使用 <code>originalInvoke</code> 作为 key 即可。</p><p>下面的代码展示了获取下个 token 的 <code>next</code> 实现。因为链表可能会有新的插入和删除节点操作，所以需确保线程安全。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">BHToken </span>*)next</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">BHLock </span>*lock = [self.<span class="keyword">block </span><span class="keyword">bh_lockForKey:@selector(next)];</span></span><br><span class="line"><span class="keyword"> </span>   [lock lock]<span class="comment">;</span></span><br><span class="line">    if (!_next) &#123;</span><br><span class="line">        _next = objc_getAssociatedObject(self.<span class="keyword">block, </span>self.<span class="keyword">originInvoke);</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line">    <span class="keyword">BHToken </span>*result = _next<span class="comment">;</span></span><br><span class="line">    [lock unlock]<span class="comment">;</span></span><br><span class="line">    return result<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用 <code>replacementInvoke</code> 来作为 <code>AssociatedObject</code> 的 key 真是<strong>一举多得</strong>：</p><ol><li>将 token 的生命周期绑定到 Block 对象上，实现 self-managed</li><li>因为函数指针地址是唯一的，确保 Block 上关联每个 token 的 key 不会冲突</li><li>Block 的 <code>invoke</code> 指针作为 key，可以找到最后一次 Hook 的 token。进而按 Hook 先后顺序遍历出所有的 token。</li></ol><p>下面的代码展示了如何获取最后一次 Hook 的 token。在读取 <code>invoke</code> 函数指针的时候，注意保证线程安全。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">BHToken </span>*)<span class="keyword">block_currentHookToken</span></span><br><span class="line"><span class="keyword">&#123;</span></span><br><span class="line"><span class="keyword"> </span>   <span class="meta">if</span> (![<span class="keyword">self </span><span class="keyword">block_checkValid]) </span>&#123;</span><br><span class="line">        return nil<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    void *invoke = [<span class="keyword">self </span><span class="keyword">block_currentInvokeFunction];</span></span><br><span class="line"><span class="keyword"> </span>   return objc_getAssociatedObject(<span class="keyword">self, </span>invoke)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void *)<span class="keyword">block_currentInvokeFunction</span></span><br><span class="line"><span class="keyword">&#123;</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">struct </span>_BHBlock *<span class="keyword">bh_block </span>= (__bridge void *)<span class="keyword">self;</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">BHLock </span>*lock = [<span class="keyword">self </span><span class="keyword">bh_lockForKey:_cmd];</span></span><br><span class="line"><span class="keyword"> </span>   [lock lock]<span class="comment">;</span></span><br><span class="line">    void *invoke = <span class="keyword">bh_block-&gt;invoke;</span></span><br><span class="line"><span class="keyword"> </span>   [lock unlock]<span class="comment">;</span></span><br><span class="line">    return invoke<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="撤销-Hook"><a href="#撤销-Hook" class="headerlink" title="撤销 Hook"></a>撤销 Hook</h2><p>俗话说『请神容易送神难』。好多 Hook 框架只解决的如何 Hook，但是却无法撤销恢复原样，留下一堆烂摊子。</p><p>在搭建了 Hook 链表的基础上，多次 Hook 的链表可以简化成 <code>invoke</code> 函数指针之间的关系：</p><p><img src="https://raw.githubusercontent.com/yulingtianxia/Blog-Hexo-Source/master/source/resources/BlockHook/BlockHook_invoke_call.png" alt></p><p>那么撤销 Hook 就可以从链表头部开始遍历，找到当前要 <code>remove</code> 的 token。接着链表上删除这个 token，而这又可以分为两个子问题：</p><ol><li>移除最后一次 Hook：需要将 Block 的 <code>invoke</code> 指针指向 token 的 <code>originalInvoke</code>。</li><li>移除<em>非</em>最后一次 Hook：需要将上一次 Hook token 的 <code>originalInvoke</code> 指向当前 token 的 <code>originalInvoke</code>。</li></ol><p>最后肯定还要解除 Block 对象对 token 的持有。</p><p>这部分逻辑的实现代码如下，在操作 Block 的 <code>invoke</code> 指针时依然需要注意线程安全问题：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)remove</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isStackBlock) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Can't remove token for StackBlock!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.deadBlock = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.originInvoke) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.block) &#123;</span><br><span class="line">            BHToken *current = [<span class="keyword">self</span>.block block_currentHookToken];</span><br><span class="line">            BHToken *last = <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">while</span> (current) &#123;</span><br><span class="line">                <span class="keyword">if</span> (current == <span class="keyword">self</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (last) &#123; <span class="comment">// remove middle token</span></span><br><span class="line">                        last.originInvoke = <span class="keyword">self</span>.originInvoke;</span><br><span class="line">                        last.next = <span class="literal">nil</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// remove head(current) token</span></span><br><span class="line">                        BHLock *lock = [<span class="keyword">self</span>.block bh_lockForKey:<span class="keyword">@selector</span>(block_currentInvokeFunction)];</span><br><span class="line">                        [lock lock];</span><br><span class="line">                        ((__bridge <span class="keyword">struct</span> _BHBlock *)<span class="keyword">self</span>.block)-&gt;invoke = <span class="keyword">self</span>.originInvoke;</span><br><span class="line">                        [lock unlock];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                last = current;</span><br><span class="line">                current = [current next];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.originInvoke = <span class="literal">NULL</span>;</span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>.block, _replacementInvoke, <span class="literal">nil</span>, OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 还在不断完善每一个细节，尽可能做到有始有终，至善尽美。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BlockHook&lt;/a&gt; 开创性地解决了 Objective-C 语言界 Hook Block 的问题，但也迎来了新的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何知道某个 Block 对象被谁 Hook 过？&lt;/li&gt;
&lt;li&gt;多次 Hook 的先后顺序？&lt;/li&gt;
&lt;li&gt;如何处理好多次 Hook 同一个 Block 后对任意一次 Hook 的撤销？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些问题也是开发者在使用时向我反馈过的问题，在这篇文章里，这些问题都将会解决。&lt;/p&gt;
&lt;p&gt;关于 &lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BlockHook&lt;/a&gt; 的原理，可以先阅读之前的文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2018/02/28/Hook-Objective-C-Block-with-Libffi/&quot;&gt;Hook Objective-C Block with Libffi&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2019/04/27/BlockHook-with-Struct/&quot;&gt;BlockHook with Struct&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yulingtianxia.com/tags/Objective-C/"/>
    
      <category term="BlockHook" scheme="http://yulingtianxia.com/tags/BlockHook/"/>
    
  </entry>
  
  <entry>
    <title>BlockHook with Struct</title>
    <link href="http://yulingtianxia.com/blog/2019/04/27/BlockHook-with-Struct/"/>
    <id>http://yulingtianxia.com/blog/2019/04/27/BlockHook-with-Struct/</id>
    <published>2019-04-27T13:26:55.000Z</published>
    <updated>2019-08-11T14:21:21.285Z</updated>
    
    <content type="html"><![CDATA[<p>一年前，我开发了 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a>，（应该是）填补了 Objective-C 业界在 Hook Block 技术领域的空白。但是对于 Block 的参数和返回值有限制，仅定制了 <code>CGRect</code>, <code>CGSize</code>, <code>CGPoint</code> 等结构体，不支持自定义 struct。这次就把这个坑给填上。</p><p>至此，<a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 已支持 macOS 和 iOS 平台全架构、tvOS 和 watchOS 模拟器，<code>BlockHook.m</code> 测试覆盖率达到 92% 以上。</p><a id="more"></a><p>关于 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 的实现原理，可以先阅读 <a href="http://yulingtianxia.com/blog/2018/02/28/Hook-Objective-C-Block-with-Libffi/">Hook Objective-C Block with Libffi</a>。</p><h2 id="Struct-Encode"><a href="#Struct-Encode" class="headerlink" title="Struct Encode"></a>Struct Encode</h2><p>要想解析自定义结构体的类型，并转换为 <code>ffi_type</code>，首先要从 Block 的 signature 入手。从中提取出 struct 的 encode，并继续解析其内容。</p><p>比如下面这个结构体，encode 是 “{TestStruct=idfc^i^{CGRect}}”。编码规则可以查看 <a href="https://nshipster.cn/type-encodings/" target="_blank" rel="noopener">Type Encodings</a>。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct TestStruct &#123;</span><br><span class="line">    int32_t a<span class="comment">;</span></span><br><span class="line">    double b<span class="comment">;</span></span><br><span class="line">    float c<span class="comment">;</span></span><br><span class="line">    char d<span class="comment">;</span></span><br><span class="line">    int *e<span class="comment">;</span></span><br><span class="line">    CGRect *f<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>基本可以把结构体当做基本类型的组合嵌套了，那么在原有解析方法的基础上，针对 “{name=type}” 这种范式来个递归遍历就行了。<code>_ffiTypeForStructEncode</code> 方法将截取 signature 字符串前面的 struct，并得到结构体的 <code>size</code>、 <code>alignment</code> 和 encode 长度 <code>length</code>。构建 <code>ffi_type</code>，并截取 <code>=</code> 后面的内容调用 <code>_typesWithEncodeString</code> 递归处理，得到结构体元素数组。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (ffi_type *)_ffiTypeForStructEncode:(const char *)<span class="keyword">str</span></span><br><span class="line"><span class="keyword">&#123;</span></span><br><span class="line"><span class="keyword"> </span>   NSUInteger size, <span class="meta">align</span><span class="comment">;</span></span><br><span class="line">    long length<span class="comment">;</span></span><br><span class="line">    <span class="keyword">BHSizeAndAlignment(str, </span>&amp;size, &amp;<span class="meta">align</span>, &amp;length)<span class="comment">;</span></span><br><span class="line">    ffi_type *<span class="keyword">structType </span>= [<span class="keyword">self </span>_allocate:size]<span class="comment">;</span></span><br><span class="line">    <span class="keyword">structType-&gt;type </span>= FFI_TYPE_STRUCT<span class="comment">;</span></span><br><span class="line">    <span class="keyword">structType-&gt;size </span>= size<span class="comment">;</span></span><br><span class="line">    <span class="keyword">structType-&gt;alignment </span>= <span class="meta">align</span><span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    const char *temp = [[[NSString <span class="keyword">stringWithUTF8String:str] </span><span class="keyword">substringWithRange:NSMakeRange(0, </span>length)] UTF8String]<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    // cut <span class="string">"struct="</span></span><br><span class="line">    <span class="meta">while</span> (temp &amp;&amp; *temp &amp;&amp; *temp != <span class="string">'='</span>) &#123;</span><br><span class="line">        temp++<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ffi_type **elements = [<span class="keyword">self </span>_typesWithEncodeString:temp + <span class="number">1</span>]<span class="comment">;</span></span><br><span class="line">    <span class="keyword">structType-&gt;elements </span>= elements<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    return <span class="keyword">structType;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><p><code>BHSizeAndAlignment</code> 处理了字符串中的 encode，跳过了无用的 “}” 和数字。这里面的数字其实是内存地址偏移量。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *BHSizeAndAlignment(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="built_in">NSUInteger</span> *sizep, <span class="built_in">NSUInteger</span> *alignp, <span class="keyword">long</span> *lenp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">out</span> = <span class="built_in">NSGetSizeAndAlignment</span>(str, sizep, alignp);</span><br><span class="line">    <span class="keyword">if</span> (lenp) &#123;</span><br><span class="line">        *lenp = <span class="keyword">out</span> - str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*<span class="keyword">out</span> == <span class="string">'&#125;'</span>) &#123;</span><br><span class="line">        <span class="keyword">out</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(isdigit(*<span class="keyword">out</span>)) &#123;</span><br><span class="line">        <span class="keyword">out</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">out</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_ffiTypeForEncode</code> 方法中对 struct 的处理也得到了简化，只需调用 <code>_ffiTypeForStructEncode</code> 即可。经测试，struct 之间的嵌套都 OK。</p><h2 id="Return-Struct-on-x86"><a href="#Return-Struct-on-x86" class="headerlink" title="Return Struct on x86"></a>Return Struct on x86</h2><p>在 x86 架构下，当 Block 返回值是大于 16 Byte 的 struct 时，其实现函数 <code>invoke</code> 的参数列表会发生变化：第一个参数不再是 Block 对象自己，而是指向 struct 返回值的指针。其余参数依次往后挪一位。Block 结构中 <code>flags</code> 里有一个 bit 标记了这个『潜规则』：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">BLOCK_HAS_STRET</span> =         (<span class="number">1</span> &lt;&lt; <span class="number">29</span>)</span><br></pre></td></tr></table></figure><p>那么在使用 libffi 定义 Hook 函数的返回值和参数列表的时候就需要注意了，虽然 signature 还是正常的，但是参数列表顺序调整了啊！当 <code>BLOCK_HAS_STRET</code> 生效时，得特殊处理下。<code>_typesWithEncodeString</code> 方法负责解析 signature 字符串中的 Type Encoding 列表，支持加偏移量。而 <code>_argsWithEncodeString</code> 是调用了前者，<code>startIndex</code> 传入 <code>1</code>，略过了第一个返回值。</p><p><img src="https://github.com/yulingtianxia/Blog-Hexo-Source/blob/master/source/resources/BlockHook/realArgs.png?raw=true" alt></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int argCount<span class="comment">;</span></span><br><span class="line">ffi_type **argTypes<span class="comment">;</span></span><br><span class="line">ffi_type *returnType<span class="comment">;</span></span><br><span class="line">struct _BHBlock *<span class="keyword">bh_block </span>= (__bridge void *)self.<span class="keyword">block;</span></span><br><span class="line"><span class="keyword">if </span>((<span class="keyword">bh_block-&gt;flags </span>&amp; <span class="keyword">BLOCK_HAS_STRET)) </span>&#123;</span><br><span class="line">    argTypes = [self _typesWithEncodeString:str getCount:&amp;argCount startIndex:<span class="number">0</span>]<span class="comment">;</span></span><br><span class="line">    argTypes[<span class="number">0</span>] = &amp;ffi_type_pointer<span class="comment">;</span></span><br><span class="line">    returnType = &amp;ffi_type_void<span class="comment">;</span></span><br><span class="line">    self.stret = YES<span class="comment">;</span></span><br><span class="line">    NSLog(@<span class="string">"Block has stret!"</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    argTypes = [self _argsWithEncodeString:str getCount:&amp;argCount]<span class="comment">;</span></span><br><span class="line">    returnType = [self _ffiTypeForEncode:str]<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Hook 的处理函数 <code>BHFFIClosureFunc</code> 中，可以获取到 Block 调用时传入的参数。为了让使用方对 <code>BLOCK_HAS_STRET</code> 无感知，需要将参数和返回值『纠正』回正常的顺序，并通过 <code>BHToken</code> 提供给使用者。这样就实现了动态修改 Block 任意参数和返回值的功能。</p><p><code>args</code> 是个指针数组，其中第一个指针又是个指向结构体返回值指针的指针，而 <code>token.retValue</code> 本应该是指向结构体返回值的指针。虽然有点绕，但是不难懂。</p><p>然而真的调用 Block 原实现的时候，还是需要用真正的参数列表和范沪指，所以加了 <code>realRetValue</code> 和 <code>realArgs</code> 分开存储原始传入的 <code>args</code> 和 <code>ret</code>。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static void BHFFIClosureFunc(ffi_cif *cif, void *<span class="keyword">ret</span>, void **<span class="keyword">args</span>, void *userdata)</span><br><span class="line">&#123;</span><br><span class="line">    BHToken *<span class="keyword">token</span> = (__bridge BHToken *)(userdata);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">token</span>.hasStret) &#123;</span><br><span class="line">        <span class="comment">// The first arg contains address of a pointer of returned struct.</span></span><br><span class="line">        <span class="keyword">token</span>.retValue = *((void **)<span class="keyword">args</span>[0]);</span><br><span class="line">        <span class="comment">// Other args move backwards.</span></span><br><span class="line">        <span class="keyword">token</span>.<span class="keyword">args</span> = <span class="keyword">args</span> + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">token</span>.retValue = <span class="keyword">ret</span>;</span><br><span class="line">        <span class="keyword">token</span>.<span class="keyword">args</span> = <span class="keyword">args</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">token</span>.realRetValue = <span class="keyword">ret</span>;</span><br><span class="line">    <span class="keyword">token</span>.realArgs = <span class="keyword">args</span>;</span><br><span class="line">    <span class="keyword">if</span> (BlockHookModeBefore == <span class="keyword">token</span>.mode) &#123;</span><br><span class="line">        [<span class="keyword">token</span> invokeHookBlock];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(BlockHookModeInstead == <span class="keyword">token</span>.mode &amp;&amp; [<span class="keyword">token</span> invokeHookBlock])) &#123;</span><br><span class="line">        [<span class="keyword">token</span> invokeOriginalBlock];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (BlockHookModeAfter == <span class="keyword">token</span>.mode) &#123;</span><br><span class="line">        [<span class="keyword">token</span> invokeHookBlock];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">token</span>.retValue = NULL;</span><br><span class="line">    <span class="keyword">token</span>.<span class="keyword">args</span> = NULL;</span><br><span class="line">    <span class="keyword">token</span>.realRetValue = NULL;</span><br><span class="line">    <span class="keyword">token</span>.realArgs = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>在测试用例 <a href="https://github.com/yulingtianxia/BlockHook/blob/master/BlockHookSample%20iOSTests/BlockHookSample_iOSTests.m" target="_blank" rel="noopener">BlockHookSample_iOSTests.m</a> 文件中包含了一些常用的使用示例，还有一些诸如改 Block 参数和返回值的骚操作。大家如果在使用中发现任何问题，或者有新的诉求，欢迎来提 issue：<a href="https://github.com/yulingtianxia/BlockHook/issues" target="_blank" rel="noopener">https://github.com/yulingtianxia/BlockHook/issues</a></p><p>哎这个月实在没啥写的了，又水了一篇文章。<br>有的大佬都不怎么更新博客了，导致 iOS 业界水平停滞不前，进而导致我还是一如既往的菜。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一年前，我开发了 &lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BlockHook&lt;/a&gt;，（应该是）填补了 Objective-C 业界在 Hook Block 技术领域的空白。但是对于 Block 的参数和返回值有限制，仅定制了 &lt;code&gt;CGRect&lt;/code&gt;, &lt;code&gt;CGSize&lt;/code&gt;, &lt;code&gt;CGPoint&lt;/code&gt; 等结构体，不支持自定义 struct。这次就把这个坑给填上。&lt;/p&gt;
&lt;p&gt;至此，&lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BlockHook&lt;/a&gt; 已支持 macOS 和 iOS 平台全架构、tvOS 和 watchOS 模拟器，&lt;code&gt;BlockHook.m&lt;/code&gt; 测试覆盖率达到 92% 以上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yulingtianxia.com/tags/Objective-C/"/>
    
      <category term="BlockHook" scheme="http://yulingtianxia.com/tags/BlockHook/"/>
    
  </entry>
  
  <entry>
    <title>音频情绪识别</title>
    <link href="http://yulingtianxia.com/blog/2019/03/30/Audio-Emotion-Recognition/"/>
    <id>http://yulingtianxia.com/blog/2019/03/30/Audio-Emotion-Recognition/</id>
    <published>2019-03-30T13:30:46.000Z</published>
    <updated>2019-05-26T10:08:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>如何识别声音所蕴含的情绪呢？在大部分场景下，人声的情绪更有意义。可以先将人声转文字，再通过 NLP 分析语义情绪。不过人类语言博大精深，一句『卧槽』的不同语调和语境下会有很多种意义，真的是卧槽啊！</p><p>于是我从音频特征提取入手，将人声分类识别为八种情绪，实现了两个方案并都得到了测试集 70% 以上的准确率：</p><ol><li>使用 VGGish 网络做特征提取，输入自定义网络进行训练。</li><li>使用音频库导出一系列特征作为输入向量，自定义网络进行训练。</li></ol><p>Python 工程和 iOS Sample 开源在 GitHub 上了：<a href="https://github.com/yulingtianxia/AudioEmotion" target="_blank" rel="noopener">https://github.com/yulingtianxia/AudioEmotion</a></p><a id="more"></a><h2 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h2><p>在音频领域数据集上，Google 提供的 AudioSet 很有名，数据量大标签也多。但是跟人声和情感的关联并不大。这里使用了 RAVDESS 数据，音频数据包含了说话和唱歌两大类数据，找了 24 位演员录制出 “neutral calm happy sad angry fearful disgust surprised” 八种情感。</p><h2 id="Turicreate-Sound-Classifier"><a href="#Turicreate-Sound-Classifier" class="headerlink" title="Turicreate Sound Classifier"></a>Turicreate Sound Classifier</h2><p>苹果推出的机器学习框架 Turicreate 降低了门槛，即便没有相关经验也可以轻松上手。训练后的模型参数可以导出为 Core ML 所使用的 mlmodel 文件，更方便集成到苹果的平台上。刚发布的 5.4 版本新增了 Sound Classifier，这可用于声音情绪识别任务上。</p><p>Turicreate 的 Sound Classifier 实现分三个阶段：</p><ol><li>音频预处理：使用 Hamming 窗口对语音进行分帧，对每一帧做短时傅里叶变换，然后利用信号幅值计算声谱图。将声谱映射到 64 阶 mel 滤波器组中计算 mel 声谱。最后通过控制时长，输出一个 (96, 64) 的矩阵。</li><li>VGGish 特征提取：Google 训练好的 CNN，它是基于 VGG 的变种，可用于将声音提取成 128 维特征。Google 的 AudioSet 号称是声音届的 ImageNet，它所提供的数据类型就包含从 VGGish 提取的特征。而 VGGish 模型是使用 YouTube-8M 训练出来的。</li><li>使用自定义神经网络训练，最后一层的节点数与标签数一致。</li></ol><p>这里还需要了解一个音频处理领域的一个概念：梅尔倒谱系数（Mel-scale Frequency Cepstral Coefficients，简称 MFCC）是在 Mel 标度频率域提取出来的倒谱参数，Mel标度描述了人耳频率的非线性特性。网上关于 MFCC 的资料很多，还有很多基于它的优化算法。第一步音频预处理也用到了。</p><p>其实数据预处理和特征提取的结果是可以复用的，在第一个版本发布后已经进行了优化： <a href="https://github.com/apple/turicreate/commit/e9b7ac6cad5a28894815aa4c5c9282163b97775b" target="_blank" rel="noopener">Sound Classifier: Allow Reusing Deep Features</a></p><p>Turicreate 固然爽，但是还存在一些问题。接下来详细讲一下：</p><h3 id="加载音频文件"><a href="#加载音频文件" class="headerlink" title="加载音频文件"></a>加载音频文件</h3><p>Turicreate 的 <code>load_audio</code> 方法加载音频文件时，很多 wav 会报错: “ Incomplete wav chunk”。导致训练样本大大减少。</p><p>看了下源码，是使用 <code>scipy</code> 的 <code>wavfile</code> 库读 wav 文件的，将其替换成 <code>librosa</code> 就 OK 了。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span>, sample_rate = librosa.load(<span class="title">cur_file_path</span>, <span class="title">sr</span>=<span class="type">None</span>, <span class="title">res_type</span>='<span class="title">scipy'</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> = <span class="keyword">data</span> * 32768</span></span><br><span class="line"><span class="meta"># sample_rate, data = _wavfile.read(cur_file_path)</span></span><br></pre></td></tr></table></figure><p>之所以还需要把 <code>data</code> 乘 32768 是为了将 (-1, 1) 的浮点数转为 16bit 整数表示。这样保证替换加载音频文件的接口后，结果数据不会有影响。</p><p>这段代码来自于 <code>audio_analysis.py</code>，我已经将修改后的版本提交了。</p><h3 id="自定义神经网络"><a href="#自定义神经网络" class="headerlink" title="自定义神经网络"></a>自定义神经网络</h3><p>Turicreate 自定义的神经网络结构为两层 100 个节点使用 RELU 激活函数的全连接层，最后接一层 label 个数节点的 softmax。这样简单的结构在官方 Demo 的 “ESC-10” 数据分类任务上表现还 OK，但是在声音情感预测上效果并不是很好。</p><p>既然是基于 VGGish 做 fine-tune，那就直接改 Turicreate 源码吧，在 <code>sound_classifier.py</code> 文件里。主要是改神经网络定义和导出模型到 Core ML 的方法。</p><p>在原有的网络结构上，增加了全连接层数和 BN 层，并使用 Dropout 层减轻过拟合的情况。当然，网络结构可以不断调整来得到更加的效果。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def _build_custom_neural_network(num_inputs, num_labels):</span><br><span class="line">    <span class="keyword">from</span> mxnet.gluon import nn</span><br><span class="line">    net = nn.Sequential(<span class="attribute">prefix</span>=<span class="string">'custom_'</span>)</span><br><span class="line">    with net.name_scope():</span><br><span class="line">        net.<span class="builtin-name">add</span>(nn.Dense(512, <span class="attribute">in_units</span>=num_inputs, <span class="attribute">activation</span>=<span class="string">'relu'</span>, <span class="attribute">prefix</span>=<span class="string">'dense0_'</span>))</span><br><span class="line">        net.<span class="builtin-name">add</span>(nn.BatchNorm())</span><br><span class="line">        net.<span class="builtin-name">add</span>(nn.Dropout(0.5))</span><br><span class="line">        net.<span class="builtin-name">add</span>(nn.Dense(256, <span class="attribute">activation</span>=<span class="string">'relu'</span>, <span class="attribute">prefix</span>=<span class="string">'dense1_'</span>))</span><br><span class="line">        net.<span class="builtin-name">add</span>(nn.BatchNorm())</span><br><span class="line">        net.<span class="builtin-name">add</span>(nn.Dropout(0.5))</span><br><span class="line">        net.<span class="builtin-name">add</span>(nn.Dense(128, <span class="attribute">activation</span>=<span class="string">'relu'</span>, <span class="attribute">prefix</span>=<span class="string">'dense2_'</span>))</span><br><span class="line">        net.<span class="builtin-name">add</span>(nn.BatchNorm())</span><br><span class="line">        net.<span class="builtin-name">add</span>(nn.Dropout(0.5))</span><br><span class="line">        net.<span class="builtin-name">add</span>(nn.Dense(64, <span class="attribute">activation</span>=<span class="string">'relu'</span>, <span class="attribute">prefix</span>=<span class="string">'dense3_'</span>))</span><br><span class="line">        net.<span class="builtin-name">add</span>(nn.BatchNorm())</span><br><span class="line">        net.<span class="builtin-name">add</span>(nn.Dropout(0.5))</span><br><span class="line">        net.<span class="builtin-name">add</span>(nn.Dense(num_labels, <span class="attribute">prefix</span>=<span class="string">'dense4_'</span>))</span><br><span class="line">    return net</span><br></pre></td></tr></table></figure><p>由于增加了 BN 和 Dropout，所以在生成 Core ML 模型文件的时候，需要判断下层的类型。增加对 BN 层的支持，忽略 Dropout 层。这里构建 Core ML 所需网络描述的 <code>builder</code> 是 coremltools 的 <code>NeuralNetworkBuilder</code>。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">input_name, output_name = input_name, <span class="number">0</span></span><br><span class="line">import mxnet as _mx</span><br><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span>, cur_layer <span class="keyword">in</span> enumerate(self._custom_classifier):</span><br><span class="line">output_name = str(i)</span><br><span class="line"><span class="keyword">if</span> type(cur_layer) == _mx<span class="selector-class">.gluon</span><span class="selector-class">.nn</span><span class="selector-class">.basic_layers</span><span class="selector-class">.Dense</span>:</span><br><span class="line">    W = cur_layer<span class="selector-class">.weight</span><span class="selector-class">.data</span>(ctx).asnumpy()</span><br><span class="line">    nC, nB = W.shape</span><br><span class="line">    Wb = cur_layer<span class="selector-class">.bias</span><span class="selector-class">.data</span>(ctx).asnumpy()</span><br><span class="line"></span><br><span class="line">    builder.add_inner_product(name=<span class="string">'inner_product_'</span>+str(i),</span><br><span class="line">                              W=W,</span><br><span class="line">                              b=Wb,</span><br><span class="line">                              input_channels=nB,</span><br><span class="line">                              output_channels=nC,</span><br><span class="line">                              has_bias=True,</span><br><span class="line">                              input_name=input_name,</span><br><span class="line">                              output_name=<span class="string">'inner_product_'</span>+output_name)</span><br><span class="line">    <span class="keyword">if</span> cur_layer<span class="selector-class">.act</span>:</span><br><span class="line">        builder.add_activation(<span class="string">"activation"</span>+str(i), <span class="string">'RELU'</span>, <span class="string">'inner_product_'</span>+output_name, output_name)</span><br><span class="line">elif type(cur_layer) == _mx<span class="selector-class">.gluon</span><span class="selector-class">.nn</span><span class="selector-class">.basic_layers</span><span class="selector-class">.BatchNorm</span>:</span><br><span class="line">    zeros = _np.zeros(nC)</span><br><span class="line">    ones = _np.ones(nC)</span><br><span class="line">    builder.add_batchnorm(name=<span class="string">'bn_layer_'</span>+str(i),</span><br><span class="line">                          channels=nC,</span><br><span class="line">                          gamma=ones,</span><br><span class="line">                          beta=zeros,</span><br><span class="line">                          mean=zeros,</span><br><span class="line">                          variance=ones,</span><br><span class="line">                          input_name=input_name,</span><br><span class="line">                          output_name=output_name)</span><br><span class="line">elif type(cur_layer) == _mx<span class="selector-class">.gluon</span><span class="selector-class">.nn</span><span class="selector-class">.basic_layers</span><span class="selector-class">.Dropout</span>:</span><br><span class="line">    continue</span><br><span class="line">input_name = output_name</span><br><span class="line"></span><br><span class="line">last_output = builder<span class="selector-class">.spec</span><span class="selector-class">.neuralNetworkClassifier</span><span class="selector-class">.layers</span>[-<span class="number">1</span>]<span class="selector-class">.output</span>[<span class="number">0</span>]</span><br><span class="line">builder.add_softmax(<span class="string">'softmax'</span>, last_output, self.target)</span><br></pre></td></tr></table></figure><h3 id="部署到-Core-ML"><a href="#部署到-Core-ML" class="headerlink" title="部署到 Core ML"></a>部署到 Core ML</h3><p>虽然生成了 mlmodel 模型文件，但是模型文件不包含第一步预处理的算法。需要依赖官方提供的 <code>libAudioPreprocessing.dylib</code>，只支持 64 位。 在使用 Core ML 预测之前，需要将 wav 文件按照输入格式切割，官方给了实例代码，但是有 bug。建议使用我提供的 iOS Sample。</p><h2 id="Put-features-to-Keras"><a href="#Put-features-to-Keras" class="headerlink" title="Put features to Keras"></a>Put features to Keras</h2><p>在这个方案中，先是提取出音频文件的一系列特征组成一个 26 维向量，再输入自定义神经网络中进行训练。这些音频特征包括：chromagram、RMS、spectral centroid、spectral bandwidth、spectral rolloff、zero-crossing rate、MFCC。</p><p>将音频特征提取后，与文件名和 label 一起保存在一个 csv 文件中。这部分代码实现在 <code>extract_audio_feature.py</code> 里。</p><p>然后使用 Keras 搭建一个比较简单的神经网络进行训练，这部分的逻辑与 Turicreate 中第三步类似，实现代码在 <code>train_audio.py</code> 里。</p><p>此方案参照了一个音乐分类的 Python Book 代码：<a href="https://gist.github.com/parulnith/7f8c174e6ac099e86f0495d3d9a4c01e" target="_blank" rel="noopener">Music_genre_classification.ipynb</a></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://zh.wikipedia.org/wiki/梅尔频率倒谱系数" target="_blank" rel="noopener">梅尔频率倒谱系数</a></p><p><a href="https://research.google.com/audioset/download.html" target="_blank" rel="noopener">AudioSet</a></p><p><a href="https://github.com/tensorflow/models/tree/master/research/audioset" target="_blank" rel="noopener">Models for AudioSet: A Large Scale Dataset of Audio Events</a></p><p><a href="https://apple.github.io/turicreate/docs/userguide/sound_classifier/" target="_blank" rel="noopener">Sound Classifier</a></p><p><a href="https://zenodo.org/record/1188976" target="_blank" rel="noopener">The Ryerson Audio-Visual Database of Emotional Speech and Song (RAVDESS)</a></p><p><a href="https://towardsdatascience.com/music-genre-classification-with-python-c714d032f0d8" target="_blank" rel="noopener">Music Genre Classification with Python</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何识别声音所蕴含的情绪呢？在大部分场景下，人声的情绪更有意义。可以先将人声转文字，再通过 NLP 分析语义情绪。不过人类语言博大精深，一句『卧槽』的不同语调和语境下会有很多种意义，真的是卧槽啊！&lt;/p&gt;
&lt;p&gt;于是我从音频特征提取入手，将人声分类识别为八种情绪，实现了两个方案并都得到了测试集 70% 以上的准确率：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 VGGish 网络做特征提取，输入自定义网络进行训练。&lt;/li&gt;
&lt;li&gt;使用音频库导出一系列特征作为输入向量，自定义网络进行训练。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Python 工程和 iOS Sample 开源在 GitHub 上了：&lt;a href=&quot;https://github.com/yulingtianxia/AudioEmotion&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/yulingtianxia/AudioEmotion&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Machine Leaning" scheme="http://yulingtianxia.com/tags/Machine-Leaning/"/>
    
  </entry>
  
  <entry>
    <title>Parallel Computation using MPS</title>
    <link href="http://yulingtianxia.com/blog/2019/02/28/Parallel-Computation-using-MPS/"/>
    <id>http://yulingtianxia.com/blog/2019/02/28/Parallel-Computation-using-MPS/</id>
    <published>2019-02-27T17:50:50.000Z</published>
    <updated>2019-07-20T09:51:45.781Z</updated>
    
    <content type="html"><![CDATA[<p>在照片质量评分组件 <a href="https://github.com/yulingtianxia/PhotoAssessment" target="_blank" rel="noopener">PhotoAssessment</a> 项目上，有些算法的实现是使用 CPU 运行的。通过使用 MPS(Metal Performance Shader) 在 GPU 上并行计算，显著提升了性能，算法执行耗时降低了 99.9% 以上。震惊，呵呵。随着性能上成百上千倍的提升，可以在相等时间内处理更大尺寸的图片，进而提升组件的准确度和用户体验。</p><p>至此，几乎所有图像处理与计算任务都交由 GPU 完成。之前利用 Sobel 算子边缘检测是使用了苹果封装好的 MPS 类，剩余的色彩分布指纹向量和饱和度均值当然都是需要自己写 Shader 的，现在终于补齐了。Metal Shading Language 与 GLSL 使用习惯和理念很相似，只不过 Metal Shader 的语法是基于 C++ 14 的。</p><p>关于整个组件的实现思路，可以查阅<a href="http://yulingtianxia.com/blog/2018/11/30/Photo-Assessment/">『使用 Metal 和 Core ML 评价照片质量』</a>。本篇文章所涉及到的 <a href="https://github.com/yulingtianxia/PhotoAssessment/blob/master/PhotoAssessment-Sample/Sources/PhotoAssessmentShaders.metal" target="_blank" rel="noopener">Shader 代码</a> 也在其中。</p><a id="more"></a><p>工程升级到 Swift 5 结果 CI 不支持，编不过哎。</p><h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p>对一张 4032x3024 彩色图片在 iPhone 8 Plus 上进行测试的 Benchmark 如下（单位：秒）：</p><p>计算平均饱和度：（耗时降低 99.90%）<br>CPU meanSaturation cost: 27.276064038276672<br>GPU meanSaturation cost: 0.02604210376739502</p><p>计算指纹向量算法：（耗时降低 99.28%）<br>CPU fingerprint cost: 8.9078871011734<br>GPU fingerprint cost: 0.06412196159362793</p><p>优化后的耗时降低幅度也跟图片本身有关，色彩分布更广的图片优化效果会更好。图片尺寸越大，优化效果越好。</p><p>再来看看 500x500 尺寸下的数据：</p><p>500x500 降采样到 50x50（包含降采样耗时）<br>cpu total cost: 0.3883340358734131<br>gpu total cost: 0.0030889511108398438</p><p>直接处理 500x500 尺寸图片<br>gpu total cost: 0.008553862571716</p><p>可以看出，降采样有一定耗时。即便是降采样到 50x50 这种很小的尺寸，在 CPU 上运行算法也会有较多的耗时。<strong>相比之下，直接 GPU 处理 500x500 尺寸图片具有更大的优势：耗时远小于降采样后跑 CPU，略高于降采样后跑 GPU，但能够处理更大尺寸更多信息，相当于有更高的准确率。</strong></p><p>实现这两个功能的 Shader kernel 函数分别封装成 Swift 类： <a href="https://github.com/yulingtianxia/PhotoAssessment/blob/master/PhotoAssessment-Sample/Sources/MPSSaturationKernel.swift" target="_blank" rel="noopener"><code>MPSSaturationKernel</code></a> 和 <a href="https://github.com/yulingtianxia/PhotoAssessment/blob/master/PhotoAssessment-Sample/Sources/MSPFingerprintImageKernel.swift" target="_blank" rel="noopener"><code>MSPFingerprintImageKernel</code></a>。</p><h2 id="Shader-的实现"><a href="#Shader-的实现" class="headerlink" title="Shader 的实现"></a>Shader 的实现</h2><p>Command Encoder 会使用 Texture、Buffer、Sampler、Pipeline 等内容构建出 Command，并装载到 Command Buffer 上。</p><p><img src="https://raw.githubusercontent.com/yulingtianxia/Blog-Hexo-Source/master/source/resources/MPS/command%20structure0.png" alt="from Apple Doc"></p><p>从 CPU 各个线程创建的 Command Buffer 都将会传入 Command Queue。运行在 GPU 上的 Shader 代码会处理这些 Command。</p><p><img src="https://raw.githubusercontent.com/yulingtianxia/Blog-Hexo-Source/master/source/resources/MPS/command%20structure1.png" alt="from Apple Doc"></p><p>Command Encoder 有三种：Render、Compute 和 Blit。区别在于用途和用法，但创建的 Command 都可以放入同一个 Command Buffer 中。</p><p><img src="https://raw.githubusercontent.com/yulingtianxia/Blog-Hexo-Source/master/source/resources/MPS/Cmd-Model-threads.png" alt="from Apple Doc"></p><p>为了在 GPU 上并行计算图片的饱和度和指纹向量，需要用到 Compute Command Encoder，并传入以下几个参数构建 Command：</p><ol><li>Texture：输入或输出用到的图像纹理</li><li>Buffer：可作为额外的入参或结果，可设定 CPU 和 GPU 间共享</li><li>Compute Pipeline State：用于配置 Shader 函数名，也可用于计算 threadgroup 相关信息。</li></ol><h3 id="Threadgroup"><a href="#Threadgroup" class="headerlink" title="Threadgroup"></a>Threadgroup</h3><p>GPU 并行计算时，每条线程处理一个像素。整个 Texture 看做一个 Grid，可以进一步划分成多个 threadgroup。</p><p><img src="https://raw.githubusercontent.com/yulingtianxia/Blog-Hexo-Source/master/source/resources/MPS/threadgroups.png" alt="from Apple Doc"></p><p>threadgroup 还会按照 GPU 能同时执行的线程数 <code>threadExecutionWidth</code> 被划分为 SIMD group。</p><p><img src="https://raw.githubusercontent.com/yulingtianxia/Blog-Hexo-Source/master/source/resources/MPS/SIMD%20group.png" alt="from Apple Doc"></p><p>为了达到更好的性能，需要将 threadgroup 包含的线程数量设定为 <code>threadExecutionWidth</code> 的整数倍。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">let w</span> = computePipelineState.threadExecutionWidth;</span><br><span class="line"><span class="attribute">let h</span> = computePipelineState.maxTotalThreadsPerThreadgroup / w;</span><br><span class="line"><span class="attribute">threadGroupSize</span> = MTLSize(width: w, height: h, depth: 1);</span><br></pre></td></tr></table></figure><p>在编写 Shader 时，可以通过参数获取到当前处理的像素所处的相对位置。在 C++ 14 中是使用属性的方式来标记参数用途。比如 <code>thread_position_in_grid</code> 指的是当前线程处理的像素在 Grid 中的位置。类似的属性很多，比如 <code>threadgroup_position_in_grid</code>, <code>thread_position_in_threadgroup</code>,<code>threads_per_threadgroup</code>, <code>simdgroup_index_in_threadgroup</code>, <code>thread_index_in_simdgroup</code> …</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kernel void</span><br><span class="line">rgb2hsvKernelNonuniform(texture2d&lt;float, access::<span class="built_in">read</span>&gt; inTexture <span class="string">[[texture(0)]]</span>,</span><br><span class="line">              texture2d&lt;float, access::<span class="built_in">write</span>&gt; outTexture <span class="string">[[texture(1)]]</span>,</span><br><span class="line">              uint2 gid <span class="string">[[thread_position_in_grid]]</span>)</span><br><span class="line">&#123;</span><br><span class="line">    float4 pixel = inTexture.<span class="built_in">read</span>(gid);</span><br><span class="line">    // 省略部分代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如传入的 <code>gid</code> 为 (9, 10)，那么就可以从 <code>inTexture</code> 中读取到此位置像素的数据。因为 Grid 坐标系是基于这个 Texture 的。</p><p><img src="https://raw.githubusercontent.com/yulingtianxia/Blog-Hexo-Source/master/source/resources/MPS/grid%20coordinates.png" alt="from Apple Doc"></p><h3 id="Non-uniform-Threadgroup-Size"><a href="#Non-uniform-Threadgroup-Size" class="headerlink" title="Non-uniform Threadgroup Size"></a>Non-uniform Threadgroup Size</h3><p>Command Encoder 需要知道要处理的 Grid 的分组情况，比如Grid 包含多少 threadgroup，每个 threadgroup 包含多少 thread。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> w = threadGroupSize.<span class="built_in">width</span>;</span><br><span class="line"><span class="built_in">let</span> h = threadGroupSize.<span class="built_in">height</span>;</span><br><span class="line"><span class="built_in">let</span> threadgroupsPerGrid = MTLSize(<span class="built_in">width</span>: (sourceTexture.<span class="built_in">width</span> + w - <span class="number">1</span>) / w, <span class="built_in">height</span>: (sourceTexture.<span class="built_in">height</span> + h - <span class="number">1</span>) / h, depth: <span class="number">1</span>);</span><br><span class="line">encoder?.dispatchThreadgroups(threadgroupsPerGrid, threadsPerThreadgroup: threadGroupSize)</span><br></pre></td></tr></table></figure><p>确定好这些信息后，GPU 就会开始按分组矩阵批量处理像素。但是因为 Grid 的尺寸是 Texture 的尺寸，长和宽不一定都能整除 threadgroup，所以处理到图片边缘的 threadgroup 时，会有一部分调用传入的 <code>gid</code> 超出了范围。此时要在 Shader 中做边界保护逻辑：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kernel void</span><br><span class="line">rgb2hsvKernel(texture2d&lt;float, access::<span class="built_in">read</span>&gt; inTexture <span class="string">[[texture(0)]]</span>,</span><br><span class="line">              texture2d&lt;float, access::<span class="built_in">write</span>&gt; outTexture <span class="string">[[texture(1)]]</span>,</span><br><span class="line">              uint2 gid <span class="string">[[thread_position_in_grid]]</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>((gid.x &gt;= outTexture.get_width()) || (gid.y &gt;= outTexture.get_height()))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    rgb2hsv(inTexture, outTexture, gid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是超范围的调用都被 <code>return</code> 掉了，GPU 的一些线程没利用上，造成了浪费:</p><p><img src="https://raw.githubusercontent.com/yulingtianxia/Blog-Hexo-Source/master/source/resources/MPS/underutilization%20of%20threads.png" alt="from Apple Doc"></p><p>为了提升性能，Metal 在部分 GPU 特性集上支持了 “Non-uniform Threadgroup Size”。可以允许存在不同 size 的 threadgroup：</p><p><img src="https://raw.githubusercontent.com/yulingtianxia/Blog-Hexo-Source/master/source/resources/MPS/nonuniform%20threadgroups.png" alt="from Apple Doc"></p><p>这样只需要传入 Grid 的 size，以及 threadgroup 的 size，Metal 就会自动划分边缘部分的 threadgroup size，充分利用好 GPU 的运算效率。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> threadsPerGrid = MTLSize(<span class="built_in">width</span>: sourceTexture.<span class="built_in">width</span>, <span class="built_in">height</span>: sourceTexture.<span class="built_in">height</span>, depth: <span class="number">1</span>);</span><br><span class="line">encoder?.dispatchThreads(threadsPerGrid, threadsPerThreadgroup: threadGroupSize)</span><br></pre></td></tr></table></figure><p>这样一来 Shader 部分的代码就不需要加边界判断了：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kernel void</span><br><span class="line">rgb2hsvKernelNonuniform(texture2d&lt;float, access::<span class="built_in">read</span>&gt; inTexture <span class="string">[[texture(0)]]</span>,</span><br><span class="line">              texture2d&lt;float, access::<span class="built_in">write</span>&gt; outTexture <span class="string">[[texture(1)]]</span>,</span><br><span class="line">              uint2 gid <span class="string">[[thread_position_in_grid]]</span>)</span><br><span class="line">&#123;</span><br><span class="line">    rgb2hsv(inTexture, outTexture, gid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过并不是所有系统和设备都支持这项特性。目前支持 Non-uniform Threadgroup Size 的 GPU Feature Set 如下：</p><ul><li>iOS11 GPUFamily4_v1</li><li>iOS12 GPUFamily4_v2</li><li>iOS12 GPUFamily5_v1</li><li>macOS13 GPUFamily1_v3</li><li>macOS14 GPUFamily1_v4</li><li>macOS14 GPUFamily2_v1</li></ul><p>所以目前我的策略是先判断是否支持 Non-uniform Threadgroup Size，然后决定使用的 Shader 函数版本、以及 Encoder 分发线程的方式。</p><h3 id="原子操作生成-Histogram"><a href="#原子操作生成-Histogram" class="headerlink" title="原子操作生成 Histogram"></a>原子操作生成 Histogram</h3><p>在计算指纹向量的时，并行将每个像素的内容处理完后，还需要统计成柱状图。比如处理完的像素种类一共有 <code>HistogramBufferSize</code> 种，需要统计每种类型的像素数量，可以声明一个 Buffer，包含长度为 <code>HistogramBufferSize</code> 的数组 <code>bucket</code>，将其传入 Shader 函数用于统计。</p><p>下面是用 Shader 实现的指纹向量生成代码，MPS 实现了部分 C++ 原子操作的接口，<code>atomic_fetch_add_explicit</code> 用于原子累加操作。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    atomic_int bucket[HistogramBufferSize];</span><br><span class="line">&#125; PAHistogramBuffer;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> fingerprint(texture2d&lt;<span class="type">uint</span>, access::read&gt; inTexture [[<span class="built_in">texture</span>(<span class="number">0</span>)]],</span><br><span class="line">                 device PAHistogramBuffer &amp;<span class="keyword">buffer</span> [[<span class="keyword">buffer</span>(<span class="number">0</span>)]],</span><br><span class="line">                 uint2 gid [[thread_position_in_grid]])</span><br><span class="line">&#123;</span><br><span class="line">    uint4 c = inTexture.read(gid);</span><br><span class="line">    <span class="type">uint</span> width = inTexture.get_width();</span><br><span class="line">    <span class="type">uint</span> height = inTexture.get_height();</span><br><span class="line">    <span class="type">uint</span> blockCount = <span class="number">2</span>;</span><br><span class="line">    <span class="type">uint</span> rowCount = <span class="built_in">min</span>(blockCount, height);</span><br><span class="line">    <span class="type">uint</span> countPerRow = <span class="built_in">min</span>(blockCount, width);</span><br><span class="line">    <span class="type">uint</span> hStep = width / countPerRow;</span><br><span class="line">    <span class="type">uint</span> vStep = height / rowCount;</span><br><span class="line">    <span class="type">uint</span> row = gid.y / vStep;</span><br><span class="line">    <span class="type">uint</span> col = gid.x / hStep;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// |-3bit-|-3bit-|-3bit-|-2bit-|</span></span><br><span class="line">    <span class="type">uint</span> result = (row * countPerRow + col) + ((c.y &gt;&gt; <span class="number">5</span>) &lt;&lt; <span class="number">2</span>) + ((c.z &gt;&gt; <span class="number">5</span>) &lt;&lt; <span class="number">5</span>) + ((c.w &gt;&gt; <span class="number">5</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    atomic_fetch_add_explicit(&amp;<span class="keyword">buffer</span>.bucket[result], <span class="number">1</span>, memory_order_relaxed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MPS 支持的原子操作值类型很有限，无法选择占用内存更低的类型，只好忍受 <code>atomic_int</code> 带来的 4 Byte 吧。只要控制好 <code>HistogramBufferSize</code>，问题应该不大。</p><h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><p>MPS 中获取向量内容的方式可谓是方便，但是也是有坑在里面的。比如要注意无论是 <code>xyzw</code> 还是 <code>rgba</code> 分量获取的内容都是从低地址到高地址排列的。比如传入的像素格式是 RGBA，那么 <code>rgba</code> 获取的值正好是反过来的。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RGBA</span><br><span class="line">wzyx  <span class="comment">// x低 w 高</span></span><br><span class="line">abgr  <span class="comment">// r低 a 高</span></span><br></pre></td></tr></table></figure><p>同样向 Texture 写数据的时候也要注意构造向量的时候，从左往右也是从低到高。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0x04030201</span></span><br><span class="line">outTexture.write(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), gid);</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://developer.apple.com/metal/Metal-Shading-Language-Specification.pdf" target="_blank" rel="noopener">https://developer.apple.com/metal/Metal-Shading-Language-Specification.pdf</a></li><li><a href="https://developer.apple.com/metal/Metal-Feature-Set-Tables.pdf" target="_blank" rel="noopener">https://developer.apple.com/metal/Metal-Feature-Set-Tables.pdf</a></li><li><a href="https://stackoverflow.com/questions/47738441/passing-textures-with-uint8-component-type-to-metal-compute-shader" target="_blank" rel="noopener">https://stackoverflow.com/questions/47738441/passing-textures-with-uint8-component-type-to-metal-compute-shader</a></li><li><a href="https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl" target="_blank" rel="noopener">https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在照片质量评分组件 &lt;a href=&quot;https://github.com/yulingtianxia/PhotoAssessment&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PhotoAssessment&lt;/a&gt; 项目上，有些算法的实现是使用 CPU 运行的。通过使用 MPS(Metal Performance Shader) 在 GPU 上并行计算，显著提升了性能，算法执行耗时降低了 99.9% 以上。震惊，呵呵。随着性能上成百上千倍的提升，可以在相等时间内处理更大尺寸的图片，进而提升组件的准确度和用户体验。&lt;/p&gt;
&lt;p&gt;至此，几乎所有图像处理与计算任务都交由 GPU 完成。之前利用 Sobel 算子边缘检测是使用了苹果封装好的 MPS 类，剩余的色彩分布指纹向量和饱和度均值当然都是需要自己写 Shader 的，现在终于补齐了。Metal Shading Language 与 GLSL 使用习惯和理念很相似，只不过 Metal Shader 的语法是基于 C++ 14 的。&lt;/p&gt;
&lt;p&gt;关于整个组件的实现思路，可以查阅&lt;a href=&quot;http://yulingtianxia.com/blog/2018/11/30/Photo-Assessment/&quot;&gt;『使用 Metal 和 Core ML 评价照片质量』&lt;/a&gt;。本篇文章所涉及到的 &lt;a href=&quot;https://github.com/yulingtianxia/PhotoAssessment/blob/master/PhotoAssessment-Sample/Sources/PhotoAssessmentShaders.metal&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Shader 代码&lt;/a&gt; 也在其中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Metal" scheme="http://yulingtianxia.com/tags/Metal/"/>
    
  </entry>
  
  <entry>
    <title>使用 OCLint 自定义 MVVM 规则</title>
    <link href="http://yulingtianxia.com/blog/2019/01/27/MVVM-Rules-for-OCLint/"/>
    <id>http://yulingtianxia.com/blog/2019/01/27/MVVM-Rules-for-OCLint/</id>
    <published>2019-01-27T11:00:51.000Z</published>
    <updated>2019-05-26T10:08:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在搞 iOS MVVM 框架，虽说是 N 年前就老生常谈的知识了，但设计模式毕竟是只一种规范，无法约束项目中所有程序员都去遵循。我做了个 OCLint 的自定义规则，对 ViewModel 运行静态检查。</p><p>然而过程中踩了不少坑，OCLint 的官方 Repo 早已失效，可以使用我修改后基于 LLVM 7 的版本：<a href="https://github.com/yulingtianxia/oclint/tree/llvm-7.0" target="_blank" rel="noopener">https://github.com/yulingtianxia/oclint/tree/llvm-7.0</a></p><p>伸手党也可以使用我写的<a href="https://github.com/yulingtianxia/oclint/releases/download/0.18.10/install-0.18.10" target="_blank" rel="noopener">脚本</a>直接安装，已包含 MVVM 规则。</p><a id="more"></a><h2 id="编译-OCLint"><a href="#编译-OCLint" class="headerlink" title="编译 OCLint"></a>编译 OCLint</h2><p>编译 OCLint 时，会先下载 LLVM 等项目。由于 LLVM 源码废弃了在 SVN 上的版本管理，将其迁移到了 Git 上，所以目前各种版本的 OCLint 都无法编译了。而且最新版本的 OCLint 还是基于 LLVM 5 的！我从作者的 Repo 那发现有 LLVM 7 的 branch，依然无法编译，只好自己动手改了。</p><p>虽然 Git 上的提交与历史 SVN 提交记录有映射，但是经过实践发现并不精准可信。编译时需要用到 llvm-project 下的 llvm，cfe 和 compile-rt，而且三个 repo 的 release 版本一定要一致。然而  LLVM 在 Git 上同一个 release 的代码却无法编译通过。更离谱的是即便 LLVM 在 GitHub 上把整个 llvm-project 作为一个 repo，依然无法将其 release 版本编译通过。</p><p>算了，Git 不靠谱，还是改下 OCLint 的代码，从官网直接下以前打包好的吧。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">llvm</span> = <span class="string">'http://releases.llvm.org/7.0.0/llvm'</span></span><br><span class="line"><span class="attr">clang</span> = <span class="string">'http://releases.llvm.org/7.0.0/cfe'</span></span><br><span class="line"><span class="attr">clang_rt</span> = <span class="string">'http://releases.llvm.org/7.0.0/compiler-rt'</span></span><br></pre></td></tr></table></figure><p>我把最终可以正常编译的 0.18.10 版本发了个非官方的 release 包，macOS 亲测 ok：<a href="https://github.com/yulingtianxia/oclint/releases/tag/0.18.10" target="_blank" rel="noopener">https://github.com/yulingtianxia/oclint/releases/tag/0.18.10</a></p><p>嫌麻烦不想编译的，可以直接跑我提供的脚本来安装已经编译好的 0.18.10 版本。以前安装过 OCLint 旧版本的可以先备份下，因为会被覆盖安装。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate -O install-oclint https:<span class="regexp">//gi</span>thub.com<span class="regexp">/yulingtianxia/</span>oclint<span class="regexp">/releases/</span>download<span class="regexp">/0.18.10/i</span>nstall-<span class="number">0.18</span>.<span class="number">10</span></span><br><span class="line">chmod +x install-oclint</span><br><span class="line">.<span class="regexp">/install-oclint</span></span><br></pre></td></tr></table></figure><h2 id="自定义规则"><a href="#自定义规则" class="headerlink" title="自定义规则"></a>自定义规则</h2><p>网上有很多介绍如何编写自定义规则的文章，这里假设已经成功编译好 OCLint，总体流程如下。</p><h3 id="创建规则"><a href="#创建规则" class="headerlink" title="创建规则"></a>创建规则</h3><p>使用 oclint-scripts 文件夹下的 scaffoldRule 脚本创建一个新规则，并指定模板。注意规则名不需要带 “Rule”:</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oclint-scripts/scaffoldRule MVVM -<span class="built_in">t</span> ASTVisitor</span><br></pre></td></tr></table></figure><h3 id="生成调试工程"><a href="#生成调试工程" class="headerlink" title="生成调试工程"></a>生成调试工程</h3><p>创建一个文件夹用于生成调试 Rule 的工程。我已经创建好了：<a href="https://github.com/yulingtianxia/oclint/tree/llvm-7.0/oclint-xcodeproject" target="_blank" rel="noopener">https://github.com/yulingtianxia/oclint/tree/llvm-7.0/oclint-xcodeproject</a></p><p>运行 xcode-debug.sh 脚本即可使用 oclint-rules 文件夹的内容创建一个 Xcode 工程。因为这里是想调试刚刚创建的 MVVM 规则，所以选择 oclint-rules。理论上可以修改脚本参数使用其他文件夹创建 Xcode 工程。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /bin/sh -e</span></span><br><span class="line"></span><br><span class="line">cmake -G Xcode -D <span class="attribute">CMAKE_CXX_COMPILER</span>=../build/llvm-install/bin/clang++  -D <span class="attribute">CMAKE_C_COMPILER</span>=../build/llvm-install/bin/clang -D <span class="attribute">OCLINT_BUILD_DIR</span>=../build/oclint-core -D <span class="attribute">OCLINT_SOURCE_DIR</span>=../oclint-core -D <span class="attribute">OCLINT_METRICS_SOURCE_DIR</span>=../oclint-metrics -D <span class="attribute">OCLINT_METRICS_BUILD_DIR</span>=../build/oclint-metrics -D <span class="attribute">LLVM_ROOT</span>=../build/llvm-install/ <span class="built_in">..</span>/oclint-rules</span><br></pre></td></tr></table></figure><p>每个规则都有对应的 Scheme，选择我们自定义的 MVVMRule，添加启动参数。<code>-R</code> 传入自定义的规则名，这里使用调试工程生成的 Debug 目录。接着传入一个随便写的测试用文件 <code>TestViewModel.m</code>，此文件所依赖的 Framework 等环境参数也需要传入。别忘了需要把我贴的绝对路径修改成你电脑上的路径。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-R <span class="regexp">/Users/</span>yangxiaoyu<span class="regexp">/Code/</span>oclint<span class="regexp">/oclint-xcodeproject/</span>rules.dl<span class="regexp">/Debug /</span>Users<span class="regexp">/yangxiaoyu/</span>Code<span class="regexp">/oclint/</span>oclint-rules-test<span class="regexp">/OCLintTest/</span>OCLintTest/TestViewModel.m  -- -x objective-c </span><br><span class="line">-isystem <span class="regexp">/Users/</span>yangxiaoyu<span class="regexp">/Code/</span>oclint<span class="regexp">/build/</span>oclint-release<span class="regexp">/lib/</span>clang<span class="regexp">/7.0.0/</span>include</span><br><span class="line">-iframework <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/</span>iPhoneSimulator.platform<span class="regexp">/Developer/</span>SDKs<span class="regexp">/iPhoneSimulator.sdk/</span>System<span class="regexp">/Library/</span>Frameworks</span><br><span class="line">-isystem <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/</span>iPhoneSimulator.platform<span class="regexp">/Developer/</span>SDKs<span class="regexp">/iPhoneSimulator.sdk/</span>usr/include</span><br></pre></td></tr></table></figure><p>为了能够调试运行，还需要在 Scheme 的 Info 下选择 Executable 为编译好的 oclint 的可执行文件。oclint-0.18.10 文件由于后缀名问题不允许被选择为 Executable，删掉后缀名的数字就可以了。这样就可以无需重新编译 OCLint 直接运行调试了！</p><h3 id="实现规则"><a href="#实现规则" class="headerlink" title="实现规则"></a>实现规则</h3><p>在 MVVM 设计模式下，我想让 ViewModel 的属性都是只读的。因为我只想通过与 Model 的数据绑定来更新 ViewModel 的值，或是在其内部更新状态。现在我需要实现一个规则来找出那些非只读属性。</p><p>先找几个自带的规则例子看看，结合 <a href="https://clang.llvm.org/doxygen/" target="_blank" rel="noopener">Clang AST 文档</a>学习下各种数据结构的定义。如果不知道自己的测试代码如何下手，可以用 <code>clang</code> 命令将测试代码转化为 <a href="http://clang.llvm.org/docs/IntroductionToTheClangAST.html" target="_blank" rel="noopener">Clang AST</a>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">clang</span> <span class="selector-tag">-Xclang</span> <span class="selector-tag">-ast-dump</span> <span class="selector-tag">-fsyntax-only</span> <span class="selector-tag">TestViewModel</span><span class="selector-class">.m</span></span><br></pre></td></tr></table></figure><p>思路是遍历每个后缀名为 <code>ViewModel</code> 类的 Interface 中的所有 Property，判断每个 Property 的 Attribute，如果包含 <code>readwrite</code> 就触发 warning。提高优先级可以产生 error。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Visit ObjCImplementationDecl */</span></span><br><span class="line">bool VisitObjCImplementationDecl(ObjCImplementationDecl *node)</span><br><span class="line">&#123;</span><br><span class="line">    ObjCInterfaceDecl *<span class="class"><span class="keyword">interface</span> = <span class="title">node</span>-&gt;<span class="title">getClassInterface</span></span>();</span><br><span class="line">    </span><br><span class="line">    bool isViewModel = <span class="class"><span class="keyword">interface</span>-&gt;<span class="title">getName</span></span>().endswith(<span class="string">"ViewModel"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!isViewModel) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (auto property = <span class="class"><span class="keyword">interface</span>-&gt;<span class="title">instprop_begin</span></span>(),</span><br><span class="line">         propertyEnd = <span class="class"><span class="keyword">interface</span>-&gt;<span class="title">instprop_end</span></span>(); property != propertyEnd; property++)</span><br><span class="line">    &#123;</span><br><span class="line">        clang::ObjCPropertyDecl *propertyDecl = (clang::ObjCPropertyDecl *)*property;</span><br><span class="line">        <span class="keyword">if</span> (propertyDecl-&gt;getName().startswith(<span class="string">"UI"</span>)) &#123;</span><br><span class="line">            addViolation(propertyDecl, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        auto attrs = propertyDecl-&gt;getPropertyAttributes();</span><br><span class="line">        bool isReadwrite = (attrs &amp; ObjCPropertyDecl::PropertyAttributeKind::OBJC_PR_readwrite) &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (isReadwrite &amp;&amp; isViewModel) &#123;</span><br><span class="line">            addViolation(propertyDecl, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集成到-Xcode"><a href="#集成到-Xcode" class="headerlink" title="集成到 Xcode"></a>集成到 Xcode</h2><p>先放一张集成后的效果：</p><p><img src="http://yulingtianxia.com/resources/QQ20190127-175054@2x.png" alt></p><p>在 CI 运行静态检查可以减少一部分人工 Code Review 的成本，缺点是发现问题滞后，解决问题有一定成本。而如果在本地 Xcode 运行静态检查，则可把问题扼杀在摇篮之中，缺点是占用开发机资源。</p><p>如何在 Xcode 中集成 OCLint 静态检查，官方有很详细的文档，图文并茂: <a href="https://oclint-docs.readthedocs.io/en/stable/guide/xcode.html" target="_blank" rel="noopener">https://oclint-docs.readthedocs.io/en/stable/guide/xcode.html</a></p><p>美中不足的是 Xcode Run Script 欠一点火候，可以参考下下面我提供的脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">which</span> oclint 2&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'oclint exist'</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">wget --no-check-certificate -O install-oclint https://github.com/yulingtianxia/oclint/releases/download/0.18.10/install-0.18.10</span><br><span class="line">chmod +x install-oclint</span><br><span class="line">./install-oclint</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">which</span> xcpretty 2&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'xcpretty exist'</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">sudo gem install xcpretty</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;SRCROOT&#125;</span></span><br><span class="line">xcodebuild clean</span><br><span class="line">xcodebuild | xcpretty -r json-compilation-database --output compile_commands.json</span><br><span class="line">oclint-json-compilation-database -- -report-type xcode</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>我只是简单的写了一个 ViewModel 的规则来跑通和验证整个流程，其实 MVVM 设计模式里还有更多的规则需要实现，比如 ViewModel 中不能引入 <code>UIKit</code> 等。欢迎有兴趣的同学提 PR！</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="http://oclint.org" target="_blank" rel="noopener">OCLint</a></li><li><a href="http://releases.llvm.org/download.html#7.0.0" target="_blank" rel="noopener">LLVM Download Page</a></li><li><a href="https://github.com/llvm/llvm-project" target="_blank" rel="noopener">llvm-project</a></li><li><a href="http://clang.llvm.org/docs/IntroductionToTheClangAST.html" target="_blank" rel="noopener">Introduction to the Clang AST</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在搞 iOS MVVM 框架，虽说是 N 年前就老生常谈的知识了，但设计模式毕竟是只一种规范，无法约束项目中所有程序员都去遵循。我做了个 OCLint 的自定义规则，对 ViewModel 运行静态检查。&lt;/p&gt;
&lt;p&gt;然而过程中踩了不少坑，OCLint 的官方 Repo 早已失效，可以使用我修改后基于 LLVM 7 的版本：&lt;a href=&quot;https://github.com/yulingtianxia/oclint/tree/llvm-7.0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/yulingtianxia/oclint/tree/llvm-7.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;伸手党也可以使用我写的&lt;a href=&quot;https://github.com/yulingtianxia/oclint/releases/download/0.18.10/install-0.18.10&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;脚本&lt;/a&gt;直接安装，已包含 MVVM 规则。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yulingtianxia.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>DirtyWords for Xcode - 做个文明的程序员</title>
    <link href="http://yulingtianxia.com/blog/2018/12/30/Dirty-Words-for-Xcode/"/>
    <id>http://yulingtianxia.com/blog/2018/12/30/Dirty-Words-for-Xcode/</id>
    <published>2018-12-30T03:26:27.000Z</published>
    <updated>2019-05-26T10:08:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>开发者经常会在代码中看到各类脏话，有吐槽产品的瞎改早晚还会改回来的，有吐槽这块代码写的太烂无法直视的，或是干脆心情不好就一顿骂。公司内部的项目想必是无数天坑 f*ck 无数，连对外开源的项目也难逃一劫，比如前一段时间 <a href="https://bugs.openjdk.java.net/browse/JDK-8215217" target="_blank" rel="noopener">OpenJDK</a> 就因为脏话太多火了一把。</p><p>于是我做了一个 Xcode 插件来寻找代码中的脏话，将其高亮可以被选中，作为一个强提示让开发者修改。目前逻辑还只是简单替换而已，代码在这里：<a href="https://github.com/yulingtianxia/DirtyWords-for-Xcode" target="_blank" rel="noopener">DirtyWords-for-Xcode</a></p><p>为了体现汉字的博大精深，瞎画了个 icon，见笑了：</p><p><img src="https://github.com/yulingtianxia/DirtyWords-for-Xcode/blob/master/images/%E8%89%B9.png?raw=true" alt></p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="AppStore"><a href="#AppStore" class="headerlink" title="AppStore"></a>AppStore</h3><p><a href="https://itunes.apple.com/cn/app/dirtywords-for-xcode/id1447526628?mt=12" target="_blank" rel="noopener">DirtyWords for Xcode</a></p><h3 id="GitHub-Release"><a href="#GitHub-Release" class="headerlink" title="GitHub Release"></a>GitHub Release</h3><p>直接从 GitHub Release 页面下载最新的安装包：<br><a href="https://github.com/yulingtianxia/DirtyWords-for-Xcode/releases" target="_blank" rel="noopener">https://github.com/yulingtianxia/DirtyWords-for-Xcode/releases</a></p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>用法很简单，反正目前也就这么一个功能。Editer -&gt; Dirty Words -&gt; Highlight</p><p><img src="https://github.com/yulingtianxia/DirtyWords-for-Xcode/blob/master/images/usage.png?raw=true" alt></p><p>例如下图中的 “fuck” 就会被高亮，可以文明用语代之。</p><p><img src="https://github.com/yulingtianxia/DirtyWords-for-Xcode/blob/master/images/highlight.png?raw=true" alt></p><p>如果在 Editor 菜单中找不到的话，打开系统偏好设置 -&gt; 拓展，并勾选 “DirtyWords for Xcode” 拓展项.</p><p><img src="https://github.com/yulingtianxia/DirtyWords-for-Xcode/blob/master/images/appui.png?raw=true" alt></p><p>可以给 DirtyWords 自定义快捷键。 Xcode &gt; Preferences &gt; Key Bindings &gt; 搜索 “Dirty Words”.</p><p><img src="https://github.com/yulingtianxia/DirtyWords-for-Xcode/blob/master/images/keybindings.png?raw=true" alt></p><h2 id="脏词黑名单"><a href="#脏词黑名单" class="headerlink" title="脏词黑名单"></a>脏词黑名单</h2><p>脏词列表文件跟随 app 打包进去了。在拓展加载完成后，也会通过网络下载 <a href="https://github.com/yulingtianxia/DirtyWords-for-Xcode/blob/master/SourceEditorExtension/dirtywords" target="_blank" rel="noopener">dirtywords</a> 文件进行更新。这样方便以后调整脏词列表，也欢迎大家提 PR 补充。</p><p>在收集脏词的过程中真是长了见识了，不搜不知道一搜吓一跳，哈哈。有<a href="https://github.com/LDNOOBW/List-of-Dirty-Naughty-Obscene-and-Otherwise-Bad-Words" target="_blank" rel="noopener">各国语言版的</a>，还有据说是 <a href="https://github.com/RobertJGabriel/Google-profanity-words" target="_blank" rel="noopener">Google 版的</a>。</p><p>因为分词会比较耗性能，代码中有些 API 其实是触碰脏词的，比如 “UIButton” 中包含了 “butt”，所以有些脏词需要从黑名单剔除，避免误判。不过我觉得 “fuck” 这种词无论怎么组合都难洗白的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开发者经常会在代码中看到各类脏话，有吐槽产品的瞎改早晚还会改回来的，有吐槽这块代码写的太烂无法直视的，或是干脆心情不好就一顿骂。公司内部的项目想必是无数天坑 f*ck 无数，连对外开源的项目也难逃一劫，比如前一段时间 &lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-8215217&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OpenJDK&lt;/a&gt; 就因为脏话太多火了一把。&lt;/p&gt;
&lt;p&gt;于是我做了一个 Xcode 插件来寻找代码中的脏话，将其高亮可以被选中，作为一个强提示让开发者修改。目前逻辑还只是简单替换而已，代码在这里：&lt;a href=&quot;https://github.com/yulingtianxia/DirtyWords-for-Xcode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;DirtyWords-for-Xcode&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为了体现汉字的博大精深，瞎画了个 icon，见笑了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yulingtianxia/DirtyWords-for-Xcode/blob/master/images/%E8%89%B9.png?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用 Metal 和 Core ML 评价照片质量</title>
    <link href="http://yulingtianxia.com/blog/2018/11/30/Photo-Assessment/"/>
    <id>http://yulingtianxia.com/blog/2018/11/30/Photo-Assessment/</id>
    <published>2018-11-30T14:53:14.000Z</published>
    <updated>2019-05-26T10:08:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>如何评价一张照片的质量呢？</p><p>用算法可以客观地评价照片质量，也可以人为主观地给照片打分，并运用机器学习来训练模型。</p><p>我用 Swift 写了个 <a href="https://github.com/yulingtianxia/PhotoAssessment" target="_blank" rel="noopener">Demo</a>。用苹果的 Metal 跑一些算法得出客观评分，再用 Core ML 预测主观评分。得到照片评分后，就可以检测相似照片，并从中挑选最优的照片推荐给用户。</p><p><a href="https://github.com/yulingtianxia/PhotoAssessment" target="_blank" rel="noopener">Demo</a> 中展示了图片在 NIMA 模型预测结合人脸识别的主观评分、图片的 HSB 色彩空间、以及边缘检测结果的平均值和方差。代码兼容 iOS 和 macOS。下面示例图片拍摄自胡里山炮王和西塘。</p><p><img src="https://github.com/yulingtianxia/Blog-Hexo-Source/blob/master/source/resources/PhotoAssessment/AssessmentResult1.png?raw=true" alt><img src="https://github.com/yulingtianxia/Blog-Hexo-Source/blob/master/source/resources/PhotoAssessment/AssessmentResult2.png?raw=true" alt></p><a id="more"></a><h2 id="常规算法"><a href="#常规算法" class="headerlink" title="常规算法"></a>常规算法</h2><p>目前业界有很多衡量照片质量的维度，可以通过调整各个维度占的权重来计算照片的最终得分。常用的衡量维度都是一些图形学上的客观因素：</p><ul><li>饱和度（HSB/HSV 色彩空间中的 S）</li><li>亮度（HSB/HSV 色彩空间中的 B/V）</li><li>模糊度（边缘检测、二维离散傅里叶）</li><li>颜色分布（线性直方图分布）</li></ul><p>得出的结果可能还需要设定阈值来过滤掉一些质量比较差的照片，然后做归一化和调整加权系数，最终得到照片的评分。具体权重值没有统一的参考标准，需根据业务的需求不断调试和摸索。以上列的这些标准都可以找到一些通用的算法实现，甚至用 OpenCV 分分钟的事儿。但是对于移动客户端来说，OpenCV 可能并不是个好的选择。苹果的 <code>Metal</code> 技术更适合发挥其软硬件结合的优势，在性能和安装包上均有优势。</p><p>iOS 无法直接创建 HSB 色彩空间，需要借助 <code>UIColor</code> 等 API 将其他色彩空间颜色转换成 HSB 对应的值。于是我尝试使用 <code>Metal</code> 实现边缘检测算法，相关代码可以在 <a href="https://github.com/yulingtianxia/PhotoAssessment/blob/master/PhotoAssessment-Sample/Sources/PhotoMPSProcessor.swift" target="_blank" rel="noopener">PhotoMPSProcessor.swift</a> 上找到。</p><p>边缘检测有很多种实现，这里我使用的是 Sobel 算子。MPS 提供了很多 对图片做卷积运算的 Filter，其中就包含 <code>MPSImageSobel</code>。MPS 也提供了 <code>MPSImageLaplacian</code>，不过 Laplacian 算子对噪声处理较差，实际效果不好。各种算子的原理和介绍可以参考这篇简介：<a href="https://www.jianshu.com/p/2334bee37de5" target="_blank" rel="noopener">数字图像 - 边缘检测原理 - Sobel, Laplace, Canny算子</a></p><p>苹果的 <code>MetalKit</code> 拥有更简洁的 API，可以更方便地应用 <code>Metal</code> 技术。比如加载图片可以通过 <code>MTKTextureLoader</code> 几行代码轻松搞定。然而在实际应用中却发现是个大坑，比如 rgba16 格式的图片就会报错：”Image decoding failed”。<code>MTKTextureLoader</code> 应该是只能加载单通道 8 bit 的图片数据，毕竟外部没有传每个像素字节数，解析时估计写死了这个值。所以还是老老实实的用 <code>MTLTextureDescriptor</code> 描述好 Filter 的数据输入输出格式，并创建好对应的 <code>MTLTexture</code> 吧。</p><p>Sobel 算子卷积运算后的方差值可以用来检测模糊程度。下面的代码用了两个 Filter 串联起来，三种格式的数据：rgba8[w<em>h]-&gt;r8[w</em>h]-&gt;r8[2*1]。也就是 RGBA 色彩空间图片转成含有边缘信息的灰度图（如下所示），最后出计算均值和方差。</p><p><img src="https://github.com/yulingtianxia/Blog-Hexo-Source/blob/master/source/resources/PhotoAssessment/SobelImageFilter.png?raw=true" alt="PhotoAssessment"></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="keyword">public</span> func edgeDetect(<span class="string">imagePixels:</span> [Int32], <span class="string">width:</span> Int, <span class="string">height:</span> Int, _ <span class="string">block:</span> <span class="meta">@escaping</span> (_ <span class="string">mean:</span> Int8, _ <span class="string">variance:</span> Int8) -&gt; Void) -&gt; Void &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Make sure the current device supports MetalPerformanceShaders.</span></span><br><span class="line">    guard MPSSupportsMTLDevice(device) <span class="keyword">else</span> &#123;</span><br><span class="line">        print(<span class="string">"Metal Performance Shaders not Supported on current Device"</span>)</span><br><span class="line">        block(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var pixels = imagePixels</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// TextureDescriptors</span></span><br><span class="line">    let sobelSrcTextureDescriptor = MTLTextureDescriptor.texture2DDescriptor(<span class="string">pixelFormat:</span> .rgba8Snorm, <span class="string">width:</span> width, <span class="string">height:</span> height, <span class="string">mipmapped:</span> <span class="literal">false</span>)</span><br><span class="line">    sobelSrcTextureDescriptor.usage = [.shaderWrite, .shaderRead]</span><br><span class="line">    </span><br><span class="line">    let sobelDesTextureDescriptor = MTLTextureDescriptor.texture2DDescriptor(<span class="string">pixelFormat:</span> .r8Snorm, <span class="string">width:</span> width, <span class="string">height:</span> height, <span class="string">mipmapped:</span> <span class="literal">false</span>)</span><br><span class="line">    sobelDesTextureDescriptor.usage = [.shaderWrite, .shaderRead]</span><br><span class="line">    </span><br><span class="line">    let varianceTextureDescriptor = MTLTextureDescriptor.texture2DDescriptor(<span class="string">pixelFormat:</span> .r8Snorm, <span class="string">width:</span> <span class="number">2</span>, <span class="string">height:</span> <span class="number">1</span>, <span class="string">mipmapped:</span> <span class="literal">false</span>)</span><br><span class="line">    varianceTextureDescriptor.usage = [.shaderWrite, .shaderRead]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Textures</span></span><br><span class="line">    guard let <span class="string">sobelSrcTexture:</span> MTLTexture = device?.makeTexture(descriptor: sobelSrcTextureDescriptor) <span class="keyword">else</span> &#123;</span><br><span class="line">        print(<span class="string">"make sobelSrcTexture failed"</span>)</span><br><span class="line">        block(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    guard let <span class="string">sobelDesTexture:</span> MTLTexture = device?.makeTexture(descriptor: sobelDesTextureDescriptor) <span class="keyword">else</span> &#123;</span><br><span class="line">        print(<span class="string">"make sobelDesTexture failed"</span>)</span><br><span class="line">        block(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    guard let <span class="string">varianceTexture:</span> MTLTexture = device?.makeTexture(descriptor: varianceTextureDescriptor) <span class="keyword">else</span> &#123;</span><br><span class="line">        print(<span class="string">"make varianceTexture failed"</span>)</span><br><span class="line">        block(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Fill sobelSrcTexture with pixels</span></span><br><span class="line">    let sobelRegion = MTLRegionMake2D(<span class="number">0</span>, <span class="number">0</span>, width, height)</span><br><span class="line">    sobelSrcTexture.replace(<span class="string">region:</span> sobelRegion, <span class="string">mipmapLevel:</span> <span class="number">0</span>, <span class="string">withBytes:</span> &amp;pixels, <span class="string">bytesPerRow:</span> <span class="number">4</span> * width)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Run Image Filters</span></span><br><span class="line">    <span class="keyword">if</span> let commandBuffer = commandQueue?.makeCommandBuffer() &#123;</span><br><span class="line">        sobel?.encode(commandBuffer: commandBuffer, <span class="string">sourceTexture:</span> sobelSrcTexture, <span class="string">destinationTexture:</span> sobelDesTexture)</span><br><span class="line">        meanAndVariance?.encode(commandBuffer: commandBuffer, <span class="string">sourceTexture:</span> sobelDesTexture, <span class="string">destinationTexture:</span> varianceTexture)</span><br><span class="line">        commandBuffer.addCompletedHandler &#123; (buffer) <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            var result = [Int8](repeatElement(<span class="number">0</span>, <span class="string">count:</span> <span class="number">2</span>))</span><br><span class="line">            let region = MTLRegionMake2D(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            varianceTexture.getBytes(&amp;result, <span class="string">bytesPerRow:</span> <span class="number">1</span> * <span class="number">2</span>, <span class="string">from:</span> region, <span class="string">mipmapLevel:</span> <span class="number">0</span>)</span><br><span class="line">            block(result.first!, result.last!)</span><br><span class="line">            </span><br><span class="line"><span class="comment">//                let grayImage = self.imageOf(grayTexture: sobelDesTexture)</span></span><br><span class="line">        &#125;</span><br><span class="line">        commandBuffer.commit()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        print(<span class="string">"make CommandBuffer failed"</span>)</span><br><span class="line">        block(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常规做法都是利用客观评价指标来打分，可以通过设定阈值来过滤掉不符合要求的照片，但没能像大脑一样通过读懂图片的内容来评判质量。</p><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p>Google AI Blog 在 2017 年底发表过一篇博客：<a href="https://ai.googleblog.com/2017/12/introducing-nima-neural-image-assessment.html" target="_blank" rel="noopener">Introducing NIMA: Neural Image Assessment</a>。讲述了通过神经网络迁移学习来预测图片评分方法。损失函数为 EMD (earth mover’s distance)，分数分布范围是 1-10 分。先用一些已有的模型在 ImageNet 上预训练，再加个 10 节点的全连接层使用 AVA 等数据集 fune-tune。预测结果是 10 个分数的分布，而不是直接给出评分，所以可以进一步计算出期望分和方差等。</p><p>虽然论文没有给出源码或者训练好的模型，但是网上可以搜到一些第三方的实现。最后使用苹果提供的 coremltools 将其他机器学习框架的模型转成苹果的 Core ML 模型。</p><p>在网上搜索到了几个还算不错的开源实现：</p><ul><li><a href="https://github.com/idealo/image-quality-assessment" target="_blank" rel="noopener">idealo/image-quality-assessment</a>：使用 Keras + Docker + AWS 实现，MobileNet 的完成度较高，提供了 aesthetic 和 technical 两种训练好的评分模型。Keras 模型可以直接转成 mlmodel。</li><li><a href="https://github.com/titu1994/neural-image-assessment" target="_blank" rel="noopener">titu1994/neural-image-assessment</a>：使用 Keras 实现，提供了训练好的几种模型。效果最好的为 NASNet Mobile，loss = 0.067。Keras 模型可以直接转成 mlmodel。</li><li><a href="https://github.com/truskovskiyk/nima.pytorch" target="_blank" rel="noopener">truskovskiyk/nima.pytorch</a>：使用 pytorch 实现，完成度一般，只提供了 MobileNetV2 模型（loss = 0.08）。pytorch  模型需要先转为 ONNX，然后再转成 mlmodel 格式。</li></ul><p>经过反复试验与对比结果，最终使用了第一个开源实现的 MobileNet。在这个过程中踩了不少坑：</p><ol><li>机器学习涉及到的 python 库更新幅度较大，甚至连官方文档更新都严重滞后，更别提网上找的 demo 了。想跑通网上找的代码？不存在的。</li><li>既然官方文档不可信，只能看代码中的注释，在摸索中写。依然会有各种各样的报错，大部分都是版本兼容问题。虽然 coremltools 官网有说兼容的最低版本，但也千万不要直接用最高版本的 Keras 和 TensorFlow。我用的 Keras 2.1.3 和 TensorFlow 1.10，亲测 OK。</li><li>pytorch 转 ONNX 再转 mlmodel 更是麻烦，不得不吐槽机器学习相关的 python 库版本兼容性是真的差，API 说改就改，以为自己是 Swift 么？对于新手来说很不友好，过程几乎就是：改-&gt;报错-&gt;Google-&gt;改-&gt;继续报错。。。官网 demo 从来没跑通过，跟没有一样，不存在的。</li></ol><p>转换模型和权重使用的 python 代码放在这里：<a href="https://github.com/yulingtianxia/PhotoAssessment/blob/master/ConvertMLModel/NIMA/nima.py" target="_blank" rel="noopener">nima.py</a></p><p>最后转化的 mlmodel 包含在 PhotoAssessment-Sample 工程中：<a href="https://github.com/yulingtianxia/PhotoAssessment/blob/master/PhotoAssessment-Sample/Sources/MobileNet.mlmodel" target="_blank" rel="noopener">MobileNet.mlmodel</a></p><p>在得到 mlmodel 后，可以使用苹果的 Vision 框架加载模型，用 <code>VNImageRequestHandler</code> 请求处理静态图片。串联上 Vision 框架的 <code>VNDetectFaceRectanglesRequest</code> 可以顺便检测出人脸，为照片评分提供更多的参考。比如有人脸的照片可能是个加分项。</p><p>PS: 这里原本还加入了神经网络识别面部表情，但是由于准确率不高且不同表情的评分难以主观衡量，所以最后去掉了。</p><p>这部分的代码实现在这里： <a href="https://github.com/yulingtianxia/PhotoAssessment/blob/master/PhotoAssessment-Sample/Sources/PhotoMLProcessor.swift" target="_blank" rel="noopener">PhotoMLProcessor.swift</a></p><h2 id="照片相似度"><a href="#照片相似度" class="headerlink" title="照片相似度"></a>照片相似度</h2><p>我 2016 年曾经写过一篇文章：<a href="http://yulingtianxia.com/blog/2016/01/17/search-for-similar-images/">如何自制一款寻找相似图片的 Mac 工具</a>，原理是通过 RGBA 色彩空间和像素相对位置构造出一个特征向量，然后计算特征向量之间的余弦相似度作为照片的相似度。这种做法在处理移动客户端照片时可以进一步优化：</p><ol><li>手机拍照可以去掉 alpha 通道</li><li>需要对照片降采样，降低计算量</li><li>手机拍照的尺寸相同，宽高比因素可以去掉</li><li>手机拍照具有时序性，只计算比较时间相邻的照片的相似度</li></ol><p>计算特征向量的实现如下：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@objc</span> public class func fingerprintFor(imagePixels: [<span class="built_in">Int32</span>], width: <span class="built_in">Int</span>, height: <span class="built_in">Int</span>) -&gt; [<span class="built_in">UInt32</span>: Double] &#123;</span><br><span class="line">    </span><br><span class="line">    func downsample(component: <span class="built_in">UInt8</span>) -&gt; <span class="built_in">UInt32</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UInt32</span>(component / <span class="number">16</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func downsample(x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span>) -&gt; <span class="built_in">UInt32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> rowCount: <span class="built_in">Int</span> = min(<span class="number">4</span>, height)</span><br><span class="line">        <span class="keyword">let</span> countPerRow: <span class="built_in">Int</span> = min(<span class="number">4</span>, width)</span><br><span class="line">        <span class="keyword">let</span> hStep = width / countPerRow</span><br><span class="line">        <span class="keyword">let</span> vStep = height / rowCount</span><br><span class="line">        <span class="keyword">let</span> row = y / vStep</span><br><span class="line">        <span class="keyword">let</span> col = x / hStep</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UInt32</span>(row * countPerRow + col);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var bucket = [<span class="built_in">UInt32</span>: <span class="built_in">UInt</span>]()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span> ..&lt; height &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; width &#123;</span><br><span class="line">            <span class="keyword">let</span> color = imagePixels[width * j + i]</span><br><span class="line">            <span class="keyword">let</span> r = downsample(component: color.r()) &lt;&lt; <span class="number">24</span></span><br><span class="line">            <span class="keyword">let</span> g = downsample(component: color.g()) &lt;&lt; <span class="number">16</span></span><br><span class="line">            <span class="keyword">let</span> b = downsample(component: color.b()) &lt;&lt; <span class="number">8</span></span><br><span class="line">            <span class="keyword">let</span> location = downsample(x: i, y: j) &lt;&lt; <span class="number">12</span></span><br><span class="line">            <span class="keyword">let</span> fingerprint = r | g | b | location</span><br><span class="line">            bucket[fingerprint] = (bucket[fingerprint] ?? <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result: [<span class="built_in">UInt32</span>: Double] = bucket.mapValues &#123; (oldValue) -&gt; Double <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> newValue = Double(oldValue) / Double(imagePixels.count)</span><br><span class="line">        <span class="keyword">return</span> newValue</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为输入都是像素数组，降采样使用 <code>MPSImageBilinearScale</code>，实现细节类似于上面讲的边缘检测。代码在 <a href="https://github.com/yulingtianxia/PhotoAssessment/blob/master/PhotoAssessment-Sample/Sources/PhotoMPSProcessor.swift" target="_blank" rel="noopener">PhotoMPSProcessor.swift</a> 里。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>算法可以通过调整阈值来平衡准确度与性能。比如降采样的尺寸和相似度阈值都是可以影响到最终结果和性能开销的。这里不再展开讨论。使用 Vision + Core ML 预测图片和人脸识别依然耗时较久，处理 500 张图片可能要几十秒，在生产环境下批量处理图片时需要注意。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://github.com/yulingtianxia/PhotoAssessment" target="_blank" rel="noopener">yulingtianxia/PhotoAssessment</a></li><li><a href="https://www.jianshu.com/p/2334bee37de5" target="_blank" rel="noopener">数字图像 - 边缘检测原理 - Sobel, Laplace, Canny算子</a></li><li><a href="https://github.com/idealo/image-quality-assessment" target="_blank" rel="noopener">idealo/image-quality-assessment</a></li><li><a href="https://github.com/titu1994/neural-image-assessment" target="_blank" rel="noopener">titu1994/neural-image-assessment</a></li><li><a href="https://github.com/truskovskiyk/nima.pytorch" target="_blank" rel="noopener">truskovskiyk/nima.pytorch</a></li><li><a href="https://arxiv.org/abs/1709.05424" target="_blank" rel="noopener">NIMA: Neural Image Assessment</a></li><li><a href="https://ai.googleblog.com/2017/12/introducing-nima-neural-image-assessment.html" target="_blank" rel="noopener">Introducing NIMA: Neural Image Assessment</a></li><li><a href="https://developer.apple.com/documentation/coreml" target="_blank" rel="noopener">Core ML</a></li><li><a href="https://github.com/apple/coremltools" target="_blank" rel="noopener">apple/coremltools</a></li><li><a href="https://forums.developer.apple.com/thread/97218" target="_blank" rel="noopener">MTKTextureLoader fails for 16-big images</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何评价一张照片的质量呢？&lt;/p&gt;
&lt;p&gt;用算法可以客观地评价照片质量，也可以人为主观地给照片打分，并运用机器学习来训练模型。&lt;/p&gt;
&lt;p&gt;我用 Swift 写了个 &lt;a href=&quot;https://github.com/yulingtianxia/PhotoAssessment&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Demo&lt;/a&gt;。用苹果的 Metal 跑一些算法得出客观评分，再用 Core ML 预测主观评分。得到照片评分后，就可以检测相似照片，并从中挑选最优的照片推荐给用户。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/yulingtianxia/PhotoAssessment&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Demo&lt;/a&gt; 中展示了图片在 NIMA 模型预测结合人脸识别的主观评分、图片的 HSB 色彩空间、以及边缘检测结果的平均值和方差。代码兼容 iOS 和 macOS。下面示例图片拍摄自胡里山炮王和西塘。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yulingtianxia/Blog-Hexo-Source/blob/master/source/resources/PhotoAssessment/AssessmentResult1.png?raw=true&quot; alt&gt;&lt;img src=&quot;https://github.com/yulingtianxia/Blog-Hexo-Source/blob/master/source/resources/PhotoAssessment/AssessmentResult2.png?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Machine Leaning" scheme="http://yulingtianxia.com/tags/Machine-Leaning/"/>
    
      <category term="Metal" scheme="http://yulingtianxia.com/tags/Metal/"/>
    
  </entry>
  
  <entry>
    <title>Class written in Swift</title>
    <link href="http://yulingtianxia.com/blog/2018/10/28/Class-written-in-Swift/"/>
    <id>http://yulingtianxia.com/blog/2018/10/28/Class-written-in-Swift/</id>
    <published>2018-10-27T17:13:46.000Z</published>
    <updated>2019-05-26T10:08:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前 <a href="https://github.com/yulingtianxia/TBUIAutoTest" target="_blank" rel="noopener">TBUIAutoTest</a> 有个 <a href="https://github.com/yulingtianxia/TBUIAutoTest/issues/7" target="_blank" rel="noopener">issue</a>，我发现原因跟 Swift 有关，在解决问题时顺带稍微研究了下 Swift 编写的类。</p><a id="more"></a><h2 id="Swift-Class-与-Ivar"><a href="#Swift-Class-与-Ivar" class="headerlink" title="Swift Class 与 Ivar"></a>Swift Class 与 Ivar</h2><p>纯粹的 Swift 类（没继承自 <code>NSObject</code>）在 Runtime 上有很大的坑。虽然 Runtime 的接口都能调用，但因为 <code>Class</code> 实现和构成有很大差异，所以需要谨慎对待。比如 Swift 没有 <code>Ivar</code> 的概念，相应的 Runtime 接口也只是尽可能的封装，不保证返回的内容正确。Swift 将成员变量和属性统一起来，并统一存储和管理。</p><p>其实如果 Swift 类的属性类型是继承自 <code>NSObject</code> 的话，还是可以通过 <code>Ivar</code> 相关 Runtime 函数获取到内容的。这也是 <a href="https://github.com/yulingtianxia/TBUIAutoTest" target="_blank" rel="noopener">TBUIAutoTest</a> 能够兼容 Swift 的原因。有些 Objective-C 类型在 Swift 有对应的替代，比如 <code>NSString</code> 与 <code>String</code>。编译器会自动转换接口和类型，但在这些类型上的属性获取 Ivar 依然有些问题。比如使用 <a href="https://github.com/opensource-apple/objc4/blob/881b875d7aada4cbfc154e022e1297c9526de747/runtime/objc-class.mm#L360" target="_blank" rel="noopener">object_getIvar</a> 就会 <code>BAD_ACCESS</code>。</p><h2 id="Swift-Class-Runtime-Name"><a href="#Swift-Class-Runtime-Name" class="headerlink" title="Swift Class Runtime Name"></a>Swift Class Runtime Name</h2><p>在比较早的 Swift 版本，debug 时我们看到的 Swift 的类名都是一串很长很乱的字符串，其实那是经过 Objective-C Runtime Mangle 后的产物。大概的规则如下：</p><ol><li>前缀是 “_Tt”</li><li>如果是 Class，还会再加一个 “C”，Protocol 会跟着一个 “P”</li><li>Module名连着类名，并在每个名字前面标记字符串长度。</li></ol><p>如今 Swift 正酝酿着一套新的 Mangle 规则，但要等 Objective-C Runtime 那边实现好新的 Demangle 后才能实施！有兴趣可以看下 <a href="https://github.com/apple/swift/blob/1982d024a93b3246edecf6bf42530a835ffc479f/lib/AST/ASTMangler.cpp#L419" target="_blank" rel="noopener">mangleObjCRuntimeName</a> 函数的实现。</p><p>现在 lldb 中打印 Swift 类型更加友好了，但是底层还是会生成一个 Runtime Name。在 <code>$(SWIFT_MODULE_NAME)-Swift.h</code> 文件中可以看到 Swift AST 对应 Objective-C 的头文件，里面就有 Swift Runtime Name。Swift 源码里有个 <a href="https://github.com/apple/swift/blob/master/lib/PrintAsObjC/PrintAsObjC.cpp" target="_blank" rel="noopener">PrintAsObjC.cpp</a> 文件，它的作用就是生成 Swift AST 头文件。</p><p>举个栗子：使用 <code>NSClassFromString(@&quot;_TtC19ClassWrittenInSwift11AppDelegate&quot;)</code> 获取到的类是 <code>ClassWrittenInSwift</code> Module 中的 <code>AppDelegate</code> 类。</p><h2 id="Swift-Class-Check"><a href="#Swift-Class-Check" class="headerlink" title="Swift Class Check"></a>Swift Class Check</h2><p>如何判断一个类是否用 Swift 写的呢？Runtime 中 <code>Class</code> 是有标志位的，只是没对外暴露接口而已。映射到 Runtime 源码中 <code>Class</code> 的内存模型，将标志位取出即可，关键代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">yxy_objc_object</span> &#123;</span></span><br><span class="line">    <span class="keyword">yxy_isa_t</span> isa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class is a Swift class</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IS_SWIFT         (1UL&lt;&lt;0)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">yxy_class_data_bits_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// Values are the FAST_ flags above.</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">getBit</span><span class="params">(<span class="keyword">uintptr_t</span> bit)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bits &amp; bit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSwift</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBit(FAST_IS_SWIFT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">yxy_objc_class</span> :</span> yxy_objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="keyword">yxy_cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    <span class="keyword">yxy_class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">isWrittenInSwift</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls || !object_isClass(cls)) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">yxy_objc_class</span> *<span class="title">objc_cls</span> = (__<span class="title">bridge</span> <span class="title">struct</span> <span class="title">yxy_objc_class</span> *)<span class="title">cls</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> isSwift = objc_cls-&gt;bits.isSwift();</span><br><span class="line">    <span class="keyword">return</span> isSwift;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现很简单，封装了下：<a href="https://github.com/yulingtianxia/ClassWrittenInSwift/blob/master/ClassWrittenInSwiftKit/Source/ClassWrittenInSwift.mm" target="_blank" rel="noopener">ClassWrittenInSwift</a></p><p>哎，自己的 Repo 真是越来越水了。</p><h2 id="Swift-Class-Lazy-Property"><a href="#Swift-Class-Lazy-Property" class="headerlink" title="Swift Class Lazy Property"></a>Swift Class Lazy Property</h2><p>Swift 类的 <code>lazy</code> 属性的存储比较特殊，毕竟是懒加载。它的属性名有个后缀 “.storage”，所以在 Runtime 里获取属性名时要注意，使用时是要过滤掉后缀的。</p><p>写了个简单的接口获取 Swift 类中的 <code>lazy</code> 属性名列表，代码同样放在 <a href="https://github.com/yulingtianxia/ClassWrittenInSwift/blob/master/ClassWrittenInSwiftKit/Source/ClassWrittenInSwift.mm" target="_blank" rel="noopener">ClassWrittenInSwift</a> 里面了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前 &lt;a href=&quot;https://github.com/yulingtianxia/TBUIAutoTest&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TBUIAutoTest&lt;/a&gt; 有个 &lt;a href=&quot;https://github.com/yulingtianxia/TBUIAutoTest/issues/7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;issue&lt;/a&gt;，我发现原因跟 Swift 有关，在解决问题时顺带稍微研究了下 Swift 编写的类。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://yulingtianxia.com/tags/Swift/"/>
    
      <category term="Runtime" scheme="http://yulingtianxia.com/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>GitHub 虚假 Star 净网行动</title>
    <link href="http://yulingtianxia.com/blog/2018/09/16/Fuck-Fake-GitHub-Stars/"/>
    <id>http://yulingtianxia.com/blog/2018/09/16/Fuck-Fake-GitHub-Stars/</id>
    <published>2018-09-16T08:20:55.000Z</published>
    <updated>2019-05-26T10:08:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>前一阵子看到一篇文章 <a href="https://juejin.im/post/5b8c9310f265da4361530560" target="_blank" rel="noopener">《石锤 github 买 star 行为》</a>，第一反应是很震惊。是真的很震惊，因为文章中提到的 CocoaDebug 我也 star 了，没想到竟然涉嫌购买 star 炒作，蒙蔽了好多人的双眼。没错，我就是跟风 star，看别的大神 star 啥就顺手 star。 也有的人看 Trending 上啥火顺手 star，甚至用脚本自动 star。</p><p>这条黑产背后到底隐藏着什么？GitHub 上还有哪些大笨蛋也曾靠买 Star 蒙蔽了大神们的双眼呢？我写了个简单的程序用于挖掘基于 Star 的关系链，并进行聚类分析。然后从 CocoaDebug 这个 repo 入手，沿着关系链一层层深挖下去。</p><p>用数据说话，结果一定也会让你大开眼界。正义可能会迟到，但绝不会缺席！</p><p>项目源码：<a href="https://github.com/yulingtianxia/FuckFakeGitHubStars" target="_blank" rel="noopener">FuckFakeGitHubStars</a></p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>用 GitHub 的 API 获取 repo 有哪些用户 star 了，然后再看看这些用户都 star 了哪些 repo。</li><li>将 star 行为相似的用户和 repo 聚类</li><li>疑似黑产的用户集合一般数量较多，且每个用户 star 的 repo 并不多。将这种集合纳入黑名单。（肯定会有误判，但影响不大）</li><li>计算 repo 的 star 中黑名单用户占比。</li><li>继续遍历黑名单中的用户，挖掘下一层关系链，揪出更多花钱买 star 的 repo。</li></ol><h2 id="爆料"><a href="#爆料" class="headerlink" title="爆料"></a>爆料</h2><p><strong>郑重声明</strong>：</p><ol><li>结果不一定准确，仅做参考，毕竟黑名单有误判。</li><li>买 Star 都只是推测，没有交易记录就没有实锤。本文仅是分析 GitHub 社区这一有趣而又奇妙的的现象。</li><li>不排除有人恶意给别人的 Repo 买 Star 的情况，也说不定有人注册了一堆账号喜欢没事给别人 Star 呢！</li><li>由于脚本是广度优先搜索，每个 batch 跑完结果都会更准确。跑完整个 GitHub 需要巨长的时间。跑的 batch 越多，有些 Repo 就越能露出马脚。</li></ol><p>由于数据量实在是太大了，而且也受限于 GitHub API 请求频率的限制和 CPU 计算的耗时，在上面思路中的第五步中只运行了一部分。当然，全部深挖都只是时间问题，无奈数据量级的恐怖，先把阶段性成果输出下。</p><ol><li><p>从 CocoaDebug 入手挖掘出的疑似黑产账号达到了900左右。</p></li><li><p>CocoaDebug 有 30% 左右的 Star 可能是买的。</p></li><li><p>在 <a href="https://juejin.im/post/5b8c9310f265da4361530560" target="_blank" rel="noopener">《石锤 github 买 star 行为》</a> 文章中跟 CocoaDebug 一起被揭露的『难兄难弟』所购买的 Star 更为夸张，超过了半数：</p> <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">repo owner<span class="regexp">/name: baoleiji/</span>QilinBaoleiji stargazer <span class="string">num:</span> <span class="number">1447</span> black <span class="string">percent:</span><span class="number">0.5770559778852798</span></span><br><span class="line">repo owner<span class="regexp">/name: 3348375016/</span>ITSecrets stargazer <span class="string">num:</span> <span class="number">1589</span> black <span class="string">percent:</span><span class="number">0.5173064820641913</span></span><br></pre></td></tr></table></figure><p> 当然，再深挖跑一轮数据可能会发现这个比例更大。</p></li><li><p>Jinxiansen 的 SwiftServerSide-Vapor 曾在 8 月 5 日登上了 Trending，当日收获 104个 Star。如果我没记错的话，mattt 大神也 star 并 follow 过（现在发现又取关了，果然即便蒙蔽了大神的双眼那也只是暂时的事儿）。神奇的是，这个 repo 中有 105 个 Star 疑似来自黑产。附上<a href="https://www.v2ex.com/t/471479" target="_blank" rel="noopener">这篇 V 站的贴子更有趣</a>。这哥们写的另外一个 JHUD 也是同理。</p> <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo owner<span class="regexp">/name: Jinxiansen/</span>SwiftServerSide-Vapor stargazer <span class="string">num:</span> <span class="number">583</span> black <span class="string">percent:</span><span class="number">0.18010291595197256</span></span><br></pre></td></tr></table></figure></li><li><p>UCodeUStory 的 S-MVP，你慢慢涨 Star 就能逃得了么？</p> <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo owner<span class="regexp">/name: UCodeUStory/</span>S-MVP stargazer <span class="string">num:</span> <span class="number">1103</span> black <span class="string">percent:</span><span class="number">0.28014505893019037</span></span><br></pre></td></tr></table></figure></li><li><p>买一个 Star 到底要多少钱啊，有的 repo 还不到一百个 Star，占比还不低呢，也不多买点，真抠啊（我甚至怀疑是黑产为了伪装自己的账号，随意 star 了一些没花钱买 star 的库）：</p> <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">repo owner<span class="regexp">/name: jianhaod/</span>Kaggle stargazer <span class="string">num:</span> <span class="number">37</span> black <span class="string">percent:</span><span class="number">0.5945945945945946</span></span><br><span class="line">repo owner<span class="regexp">/name: whsgzcy/</span>DEMOS_TO_MySelf_Android stargazer <span class="string">num:</span> <span class="number">63</span> black <span class="string">percent:</span><span class="number">0.4603174603174603</span></span><br></pre></td></tr></table></figure></li><li><p>搞区块链的？7月7日那天涨了 246 个 star，一算比例还真差不多：</p> <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo owner<span class="regexp">/name: DeuroIO/</span>erc20-ico-onchain-technical-analysis stargazer <span class="string">num:</span> <span class="number">512</span> black <span class="string">percent:</span><span class="number">0.427734375</span></span><br></pre></td></tr></table></figure></li><li><p>仿豆瓣的、仿知乎的。MelonRice 还有个放虎扑的，我脚本还没扫到它，手动点进去一看 star 的人，还是那尿性，也都 star 了前面那位 Jinxiansen。</p> <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">repo owner<span class="regexp">/name: jianxiaoBai/</span>douban stargazer <span class="string">num:</span> <span class="number">288</span> black <span class="string">percent:</span><span class="number">0.3715277777777778</span></span><br><span class="line">repo owner<span class="regexp">/name: MelonRice/</span>zhihudaily_flutter stargazer <span class="string">num:</span> <span class="number">163</span> black <span class="string">percent:</span><span class="number">0.2085889570552147</span></span><br></pre></td></tr></table></figure></li></ol><p>因为找出来的数据太多了，这里就不逐个去看了，这里只是随便拎几个出来。</p><p>要是 GitHub API 没有请求限频，再搞个云服务器成天跑，再做个前端页面支持查找，就完美了。要是家里有矿，说不定还能上 GPU 搞神经网络在线学习？！</p><p>我好担心被这些人报复啊。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>直接看 <a href="https://github.com/yulingtianxia/FuckFakeGitHubStars/blob/master/README.md" target="_blank" rel="noopener">README.md</a> 吧。</p><p>因为 GitHub API 用到的 token 没有上传，所以需要填你自己的 token 才可以抓数据。而且我只上传了部分数据，生成的 json 文件太大了，又懒得用数据库。</p><p>最终的可读性比较强的信息输出在 log 里，没有上传。有兴趣的可以自己跑下。</p><h2 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h2><p>技术栈就是 python3 + GraphQL。</p><p><code>REPOSITORY_STARGAZERS.json</code> 存储了 repo 有哪些用户 star 了。<code>USER_STAR_REPOSITORIES.json</code> 存储了用户 star 了哪些 repo。repo 或用户都是一个 node，都有唯一的 node ID。这样就构成了一张有向图。再根据节点的出度或入度集合将节点使用 Jaccard 相似度进行聚类。节点的详细信息以及与其他节点的相似度信息都保存在 <code>NODE_ID_CONTENT.json</code> 中。整理出的疑似黑产黑名单用户保存在 <code>BLACK_LIST.json</code>。</p><p>最初的设想是在这张巨大的有向图中广度优先遍历，层层扒皮。后来迫于面对现实，就只跑了两层，先有个阶段性结论。可以分析单个 repo star 的黑产占比，想把全网数据一网打尽需要耗费更多的时间成本。</p><p>本项目用到的技术都是现学现卖，纯粹是玩票性质，代码烂的一逼，求轻喷。某大神都深入 Python 底层实现原理开课赚钱了，我还在这边查语法边写垃圾代码，差距太大了哎！</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>愿以后 GitHub 能够清静些，虽然我大清自有国情在，但也别让一些别有用心之人一条臭鱼坏了一坨粥。</p><p>写这篇文章的时候，强台风『山竹』还在蹂躏着深圳。</p><p>就做了一点微小的工作，谢谢大家。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一阵子看到一篇文章 &lt;a href=&quot;https://juejin.im/post/5b8c9310f265da4361530560&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《石锤 github 买 star 行为》&lt;/a&gt;，第一反应是很震惊。是真的很震惊，因为文章中提到的 CocoaDebug 我也 star 了，没想到竟然涉嫌购买 star 炒作，蒙蔽了好多人的双眼。没错，我就是跟风 star，看别的大神 star 啥就顺手 star。 也有的人看 Trending 上啥火顺手 star，甚至用脚本自动 star。&lt;/p&gt;
&lt;p&gt;这条黑产背后到底隐藏着什么？GitHub 上还有哪些大笨蛋也曾靠买 Star 蒙蔽了大神们的双眼呢？我写了个简单的程序用于挖掘基于 Star 的关系链，并进行聚类分析。然后从 CocoaDebug 这个 repo 入手，沿着关系链一层层深挖下去。&lt;/p&gt;
&lt;p&gt;用数据说话，结果一定也会让你大开眼界。正义可能会迟到，但绝不会缺席！&lt;/p&gt;
&lt;p&gt;项目源码：&lt;a href=&quot;https://github.com/yulingtianxia/FuckFakeGitHubStars&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FuckFakeGitHubStars&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="GitHub" scheme="http://yulingtianxia.com/tags/GitHub/"/>
    
      <category term="瞎折腾" scheme="http://yulingtianxia.com/tags/%E7%9E%8E%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>iOS 自动化测试标签生成工具接入指南</title>
    <link href="http://yulingtianxia.com/blog/2018/08/13/TBUIAutoTest-Usage/"/>
    <id>http://yulingtianxia.com/blog/2018/08/13/TBUIAutoTest-Usage/</id>
    <published>2018-08-12T16:24:45.000Z</published>
    <updated>2019-05-26T10:08:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/yulingtianxia/TBUIAutoTest" target="_blank" rel="noopener">TBUIAutoTest</a> 可以帮开发人员生成UI 控件的标签，便于自动化测试。只需一行代码或一个配置，几乎所有的 iOS Native UI 都会在运行时生成一个页面内唯一且不变的标签。不仅节省了开发人员手动为每个 UI 控件加标签的时间，也节省了测试人员与开发人员的沟通成本。</p><a id="more"></a><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>目前已经有 QQ、今日头条、兴趣部落、NOW直播等几十款 App 接入 <a href="https://github.com/yulingtianxia/TBUIAutoTest" target="_blank" rel="noopener">TBUIAutoTest</a>。阿里系自动化测试开源框架 <a href="https://github.com/macacajs/iosHookViewId" target="_blank" rel="noopener">Macaca</a> 也在使用此方案，服务阿里多款 App。</p><p>以往的工作流程是：</p><ol><li>测试同学梳理出需要加标签的 UI 控件，通过截图标注给开发同学。</li><li>开发同学按照标注，给相应的 UI 控件手写代码添加标签。（花时间起唯一的标签名，增加安装包体积）</li><li>测试同学使用工具抓取控件树，查看控件标签，编写脚本。</li></ol><p>如果使用 <a href="https://github.com/yulingtianxia/TBUIAutoTest" target="_blank" rel="noopener">TBUIAutoTest</a>，只需要简化成一个步骤：</p><ol><li>测试同学使用工具抓取控件树，查看控件标签，编写脚本。</li></ol><p>而且几乎是<strong>一劳永逸</strong>的，后续新增的代码也会在运行时生成标签，<strong>以不变应万变</strong>！</p><p>近些年苹果的自动化测试框架经历过一些变化，但是始终是使用无障碍化相关的 API 来获取控件树和标签。</p><p>实现的思路和原理：<a href="http://yulingtianxia.com/blog/2016/03/28/Add-UITest-Label-for-UIAutomation/">为 UIAutomation 添加自动化测试标签的探索</a></p><h2 id="集成方式"><a href="#集成方式" class="headerlink" title="集成方式"></a>集成方式</h2><h3 id="手动拖拽文件"><a href="#手动拖拽文件" class="headerlink" title="手动拖拽文件"></a>手动拖拽文件</h3><p>将 TBUIAutoTest 文件夹内的所有文件加入到工程中即可。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TBUIAutoTest.h</span><br><span class="line">TBUIAutoTest.m</span><br><span class="line">UIImage+TBUIAutoTest.h</span><br><span class="line">UIImage+TBUIAutoTest.m</span><br><span class="line">UIResponder+TBUIAutoTest.h</span><br><span class="line">UIResponder+TBUIAutoTest.m</span><br><span class="line">UIView+TBUIAutoTest.h</span><br><span class="line">UIView+TBUIAutoTest.m</span><br></pre></td></tr></table></figure><h3 id="CocoaPods"><a href="#CocoaPods" class="headerlink" title="CocoaPods"></a>CocoaPods</h3><p>首先要安装 CocoaPods：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem <span class="keyword">install</span> cocoapods</span><br></pre></td></tr></table></figure><p>在 <code>Podfile</code> 中添加 TBUIAutoTest。需要将 “MyApp” 替换成自己的名字：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">source <span class="string">'https://github.com/CocoaPods/Specs.git'</span></span><br><span class="line"><span class="keyword">platform</span> :ios, <span class="string">'6.0'</span></span><br><span class="line">use_frameworks!</span><br><span class="line">target <span class="string">'MyApp'</span> <span class="keyword">do</span></span><br><span class="line">pod <span class="string">'TBUIAutoTest'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>最后需要运行下面的命令行安装下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="keyword">install</span></span><br></pre></td></tr></table></figure><h3 id="Carthage"><a href="#Carthage" class="headerlink" title="Carthage"></a>Carthage</h3><p>首先要通过 homebrew 安装 Carthage:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span>update</span><br><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>carthage</span><br></pre></td></tr></table></figure><p>然后在 <code>Cartfile</code> 文件中添加</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">github</span> <span class="string">"yulingtianxia/TBUIAutoTest"</span></span><br></pre></td></tr></table></figure><p>运行 <code>carthage update</code> 命令来获取 <code>TBUIAutoTest.framework</code>，将其拖拽到工程中使用即可。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ul><li><code>kAutoTestUITurnOnKey</code> ：是否生成 UI 标签</li><li><code>kAutoTestUILongPressKey</code> ：是否开启长按弹窗显示 UI 标签</li></ul><p><a href="https://github.com/yulingtianxia/TBUIAutoTest" target="_blank" rel="noopener">TBUIAutoTest</a> 会在 <code>+ load</code> 方法中从 <code>NSUserDefaults</code> 中读取 <code>kAutoTestUITurnOnKey</code> 和 <code>kAutoTestUILongPressKey</code> 的值。所以在设置这两个 Key 之后，一般需要下次启动 App 才生效。这里推荐拉一条自动化测试专用分支，通过宏控制在 App 启动更早的时机设置这两个 Key。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kAutoTestUITurnOnKey;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kAutoTestUILongPressKey;</span><br><span class="line">[<span class="built_in">NSUserDefaults</span>.standardUserDefaults setBool:<span class="literal">YES</span> forKey:kAutoTestUITurnOnKey];</span><br><span class="line">[<span class="built_in">NSUserDefaults</span>.standardUserDefaults setBool:<span class="literal">YES</span> forKey:kAutoTestUILongPressKey];</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>系统一些自带的 UI 控件的 <code>isAccessibilityElement</code> 属性默认是 <code>YES</code>，但是如果想让自定义的 UI 控件能够被捕获，需要手动将其设为 <code>YES</code>。除此之外还有一些容器控件之间的嵌套场景，需要在容器类中实现 <code>UIAccessibilityContainer</code>，这样才能捕获到容器控件内的子视图。最简单的一种实现如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - UIAccessibilityContainer</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#ifdef AUTO_TEST_ENV</span></span><br><span class="line">-(<span class="built_in">BOOL</span>)isAccessibilityElement</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)accessibilityElementCount</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> subviews] count];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)accessibilityElementAtIndex:(<span class="built_in">NSInteger</span>)index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> subviews] objectAtIndex:index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)indexOfAccessibilityElement:(<span class="keyword">id</span>)element</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> subviews] indexOfObject:element];</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><p>对于那种绘制上去的 UI，但非使用原生 UI 控件的场景，就需要自己创建 <code>UIAccessibilityElement</code> 对象，并手动设置标签了。这部分其实都是 App 无障碍化的知识，具体细节可以参考苹果官方文档：<a href="https://developer.apple.com/documentation/uikit/accessibility/uiaccessibilitycontainer?language=objc" target="_blank" rel="noopener">https://developer.apple.com/documentation/uikit/accessibility/uiaccessibilitycontainer?language=objc</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/yulingtianxia/TBUIAutoTest&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TBUIAutoTest&lt;/a&gt; 可以帮开发人员生成UI 控件的标签，便于自动化测试。只需一行代码或一个配置，几乎所有的 iOS Native UI 都会在运行时生成一个页面内唯一且不变的标签。不仅节省了开发人员手动为每个 UI 控件加标签的时间，也节省了测试人员与开发人员的沟通成本。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MessageThrottle Safety</title>
    <link href="http://yulingtianxia.com/blog/2018/07/31/MessageThrottle-Safety/"/>
    <id>http://yulingtianxia.com/blog/2018/07/31/MessageThrottle-Safety/</id>
    <published>2018-07-30T16:50:24.000Z</published>
    <updated>2019-05-26T10:08:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/yulingtianxia/MessageThrottle" target="_blank" rel="noopener">MessageThrottle</a> 是我开发的Objective-C 节流限频组件，其原理基于 Hook 消息转发流程，在运行时应用了一套节流限频的规则。</p><p>新版本再次提升性能的同时，确保了 hook 流程、多线程操作、规则管理的安全性，支持了持久化规则，并对 KVO 等场景进行兼容。<a href="https://github.com/yulingtianxia/MessageThrottle" target="_blank" rel="noopener">MessageThrottle</a> 的代码测试覆盖率在 80% 以上，在编写测试用例的同时也发现了一些安全隐患，有些甚至是业界知名开源库都没有发现和解决的。</p><p>本文是关于 <a href="https://github.com/yulingtianxia/MessageThrottle" target="_blank" rel="noopener">MessageThrottle</a> 的第四篇文章。前三篇如下：</p><ul><li><a href="http://yulingtianxia.com/blog/2017/11/05/Objective-C-Message-Throttle-and-Debounce/">Objective-C Message Throttle and Debounce</a></li><li><a href="http://yulingtianxia.com/blog/2017/12/15/Associated-Object-and-Dealloc/">Associated Object 与 Dealloc</a></li><li><a href="http://yulingtianxia.com/blog/2018/05/31/MessageThrottle-Performance-Benchmark-and-Optimization/">MessageThrottle Performance Benchmark and Optimization</a></li></ul><a id="more"></a><p>主要类的关系如下图，虚线为 <code>weak</code> 属性。</p><p><img src="http://yulingtianxia.com/resources/MessageThrottle1.png" alt></p><h2 id="继承链消息转发缺陷"><a href="#继承链消息转发缺陷" class="headerlink" title="继承链消息转发缺陷"></a>继承链消息转发缺陷</h2><p>由于是在消息转发流程搞事情，把所有消息都经由一个统一的路由函数 <code>mt_forwardInvocation</code> 进行处理。子类和父类不能同时 Hook 同一个方法，原因是如果子类的方法调用了父类方法，那么父类的方法调用走到统一路由函数 <code>mt_forwardInvocation</code> 的时候，『调用父类方法』这一信息早已经丢失了，接着会转发给子类的方法实现，从而造成死循环。最后 crash。</p><p>解决方法就是在 Hook 之前判断关系链，如果已经有子类或者父类被 Hook 了就报错，无法继续 Hook。</p><p>在消息转发流程将所有消息通过统一的路由函数处理并转发这件事的缺陷就是丢失了类的信息，因为全都『统一』到同一个函数处理了，而不是在各自类的内部处理。诸如 Aspects 等业界知名开源库也有此问题。</p><p><img src="http://yulingtianxia.com/resources/MessageThrottle2.png" alt></p><h2 id="兼容-KVO、其他-Hook-框架"><a href="#兼容-KVO、其他-Hook-框架" class="headerlink" title="兼容 KVO、其他 Hook 框架"></a>兼容 KVO、其他 Hook 框架</h2><p>首先先了解下 KVO 的原理：当监听类型为 <code>A</code> 的对象 <code>a</code> 时，会动态创建 <code>A</code> 的子类 <code>NSKVONotifying_A</code>，并把 <code>a</code> 的类型改成 <code>NSKVONotifying_A</code>。<code>NSKVONotifying_A</code> 会覆写监听的属性村粗方法，以及 <code>class</code> 方法，让外部以为 <code>a</code> 的类型依然是 <code>A</code>。</p><p>其余开源框架在 hook 一个对象的时候，也是通过加前缀或后缀动态创建子类，然后覆写相关方法。继承链总有先来后到，这时候问题就来了。</p><p>使用 <code>class</code> 方法获取到的类型可能是被『篡改过』的类，使用 <code>objc_getClass()</code> 函数获取到的才是真正的类。KVO 的做法是在用 <code>objc_getClass()</code> 获取到真正的类之后，直接创建带 <code>NSKVONotifying_</code> 前缀的子类。</p><p><img src="http://yulingtianxia.com/resources/MessageThrottle3.png" alt></p><p>如图所示，MessageThrottle 在 hook 一个对象的时候也会动态创建带前缀 <code>MTSubclassPrefix</code> 的子类，但是不会像 KVO 那样无脑创建，而是先判断通过 <code>class</code> 与 <code>objc_getClass()</code> 获取到的类是否相同。如果不同，则说明已经有现成的子类了，直接在 <code>objc_getClass()</code> 获取的类中 hook 就行了。这里是借鉴了 Aspects 的做法。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Class cls<span class="comment">;</span></span><br><span class="line">Class statedClass = [target class]<span class="comment">;</span></span><br><span class="line">Class <span class="keyword">baseClass </span>= object_getClass(target)<span class="comment">;</span></span><br><span class="line">NSString *className = NSStringFromClass(<span class="keyword">baseClass);</span></span><br><span class="line"><span class="keyword"> </span>   </span><br><span class="line">if ([className hasPrefix:MTSubclassPrefix]) &#123;</span><br><span class="line">   cls = <span class="keyword">baseClass;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br><span class="line"><span class="keyword">else </span>if (mt_object_isClass(target)) &#123;</span><br><span class="line">   cls = target<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">else if (statedClass != <span class="keyword">baseClass) </span>&#123;</span><br><span class="line">   cls = <span class="keyword">baseClass;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br><span class="line"><span class="keyword">else </span>&#123;</span><br><span class="line">   const char *<span class="keyword">subclassName </span>= [MTSubclassPrefix stringByAppendingString:className].UTF8String<span class="comment">;</span></span><br><span class="line">   Class <span class="keyword">subclass </span>= objc_getClass(<span class="keyword">subclassName);</span></span><br><span class="line"><span class="keyword"> </span>  </span><br><span class="line">   if (<span class="keyword">subclass </span>== nil) &#123;</span><br><span class="line">       <span class="keyword">subclass </span>= objc_allocateClassPair(<span class="keyword">baseClass, </span><span class="keyword">subclassName, </span><span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">       if (<span class="keyword">subclass </span>== nil) &#123;</span><br><span class="line">           NSLog(@<span class="string">"objc_allocateClassPair failed to allocate class %s."</span>, <span class="keyword">subclassName);</span></span><br><span class="line"><span class="keyword"> </span>          return NO<span class="comment">;</span></span><br><span class="line">       &#125;</span><br><span class="line">       mt_hookedGetClass(<span class="keyword">subclass, </span>statedClass)<span class="comment">;</span></span><br><span class="line">       mt_hookedGetClass(object_getClass(<span class="keyword">subclass), </span>statedClass)<span class="comment">;</span></span><br><span class="line">       objc_registerClassPair(<span class="keyword">subclass);</span></span><br><span class="line"><span class="keyword"> </span>  &#125;</span><br><span class="line">   object_setClass(target, <span class="keyword">subclass);</span></span><br><span class="line"><span class="keyword"> </span>  cls = <span class="keyword">subclass;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><p>有来就有回，如果要 remove KVO 或 hook 呢？肯定无法确保各个框架或 KVO add 和 remove『先入后出』的顺序，所以必然要做兼容处理。</p><p>在 revert hook 的时候需要判断真实类型的前缀是否是 <code>MTSubclassPrefix</code>。如果是，则将实例对象的类型还原回去。最后会判断是否还有其他相同类型的对象也被 hook 了，如果没有，则可以对这个类 revert hook。</p><p>添加 KVO 和应用限频规则有先后顺序，移除 KVO 和废除限频规则也有先后顺序，那么可以排列组合出四种结果：</p><table><thead><tr><th>初始类为 A</th><th>先添加 KVO</th><th>先应用限频规则</th></tr></thead><tbody><tr><td><strong>先移除 KVO</strong></td><td><code>A</code></td><td><code>A</code></td></tr><tr><td><strong>先废除限频规则</strong></td><td><code>A</code></td><td><code>_MessageThrottle_A</code></td></tr></tbody></table><p>PS: <code>MTSubclassPrefix</code> 常量内容就是 <code>_MessageThrottle_</code>。</p><p>因为通过 <code>MTDealloc</code> 记录了 hook 的类，所以 revert hook 的时候使用的是当初 hook 的类，而不是当前实例对象真实的类。这主要是针对上面表格中的 『先应用限频规则，先废除限频规则』的情况。在废除规则的时候，真实的类为 <code>NSKVONotifying__MessageThrottle_A</code>，而当初应用规则时 hook 的类为 <code>_MessageThrottle_A</code>。这里要注意区分处理下。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">BOOL</span> mt_recoverMethod(<span class="keyword">id</span> target, SEL selector, SEL aliasSelector)</span><br><span class="line">&#123;</span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="keyword">if</span> (mt_object_isClass(target)) &#123;</span><br><span class="line">        cls = target;</span><br><span class="line">        <span class="keyword">if</span> ([MTEngine.defaultEngine containsSelector:selector onTargetsOfClass:cls]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        MTDealloc *mtDealloc = objc_getAssociatedObject(target, selector);</span><br><span class="line">        <span class="comment">// get class when apply rule on target.</span></span><br><span class="line">        cls = mtDealloc.cls;</span><br><span class="line">        <span class="comment">// target current real class name</span></span><br><span class="line">        <span class="built_in">NSString</span> *className = <span class="built_in">NSStringFromClass</span>(object_getClass(target));</span><br><span class="line">        <span class="keyword">if</span> ([className hasPrefix:MTSubclassPrefix]) &#123;</span><br><span class="line">            Class originalClass = <span class="built_in">NSClassFromString</span>([className stringByReplacingOccurrencesOfString:MTSubclassPrefix withString:<span class="string">@""</span>]);</span><br><span class="line">            <span class="built_in">NSCAssert</span>(originalClass != <span class="literal">nil</span>, <span class="string">@"Original class must exist"</span>);</span><br><span class="line">            <span class="keyword">if</span> (originalClass) &#123;</span><br><span class="line">                object_setClass(target, originalClass);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ([MTEngine.defaultEngine containsSelector:selector onTarget:cls] ||</span><br><span class="line">            [MTEngine.defaultEngine containsSelector:selector onTargetsOfClass:cls]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mt_revertHook(cls, selector, aliasSelector);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Revert-Hook-的缺陷"><a href="#Revert-Hook-的缺陷" class="headerlink" title="Revert Hook 的缺陷"></a>Revert Hook 的缺陷</h2><p>前提：子类和父类都实现了同一个方法，并且子类的方法会调用 <code>super</code> 的方法。</p><p>在 Aspects 中有两种异常场景：</p><h3 id="先-Hook-父类，然后-revert，接着-Hook-子类。最后调用子类实例对象方法。"><a href="#先-Hook-父类，然后-revert，接着-Hook-子类。最后调用子类实例对象方法。" class="headerlink" title="先 Hook 父类，然后 revert，接着 Hook 子类。最后调用子类实例对象方法。"></a>先 Hook 父类，然后 revert，接着 Hook 子类。最后调用子类实例对象方法。</h3><p>结果是只执行了父类的方法，子类的方法没执行到。</p><p>原因是当子类没有对应的方法和实现时，<code>instancesRespondToSelector:</code> 会判断在继承链上查找是否有父类实现了方法。在 hook 某个方法前如果只通过 <code>instancesRespondToSelector:</code> 来判断是否已经添加过 <code>aliasSelector</code> 的话，是不够严谨的。父类 hook 后会添加 <code>aliasSelector</code> 方法，revert 后这个方法还在。hook 子类的时候因为判断出已经有 <code>aliasSelector</code> 方法了就没给子类添加该方法，实际上子类是继承的父类的实现，结果就是只执行了父类的方法实现。</p><p>MessageThrottle 的解决方案是通过比较父类和子类的 <code>Method</code> 是否相同。如果 <code>instancesRespondToSelector:</code> 方法返回 <code>YES</code> 并且父类和子类的 <code>Method</code> 相同，那么就说明子类的 Method 是来自父类的，仍然需要为子类添加 <code>aliasSelector</code> 对应的方法。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> char *typeEncoding = method_getTypeEncoding(targetMethod);</span><br><span class="line"><span class="function"><span class="keyword">Method</span> <span class="title">targetAliasMethod</span> = <span class="title">class_getInstanceMethod</span><span class="params">(cls, aliasSelector)</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">Method</span> <span class="title">targetAliasMethodSuper</span> = <span class="title">class_getInstanceMethod</span><span class="params">(superCls, aliasSelector)</span>;</span></span><br><span class="line"><span class="keyword">if</span> (![cls instancesRespondToSelector:aliasSelector] || targetAliasMethod == targetAliasMethodSuper) <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  __unused BOOL addedAlias = class_addMethod(cls, aliasSelector, method_getImplementation(targetMethod), typeEncoding);</span></span><br><span class="line"><span class="comment">  NSCAssert(addedAlias, @"Original implementation for %@ is already copied to %@ on %@", NSStringFromSelector(selector), NSStringFromSelector(aliasSelector), cls);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line">class_replaceMethod(cls, <span class="keyword">selector</span>, mt_getMsgForwardIMP(statedClass, <span class="keyword">selector</span>), typeEncoding);</span><br></pre></td></tr></table></figure><p>测试了下 Aspects 的表现，果然是只调用了父类的实现，这是一个很大的漏洞。</p><h3 id="先-Hook-子类，然后-revert，接着-Hook-父类。最后调用子类实例对象方法。"><a href="#先-Hook-子类，然后-revert，接着-Hook-父类。最后调用子类实例对象方法。" class="headerlink" title="先 Hook 子类，然后 revert，接着 Hook 父类。最后调用子类实例对象方法。"></a>先 Hook 子类，然后 revert，接着 Hook 父类。最后调用子类实例对象方法。</h3><p>结果是 crash。</p><p>因为 Objective-C Runtime 没有提供移除方法的 API，所以在 revert hook 的时候，无法将 hook 过的 <code>forwardInvocation:</code> 方法彻底复原，只能塞入 <code>NSObject</code> 的默认实现（IMP）。</p><ol><li><p>当子类的方法调用 <code>super</code> 方法时，因为父类的方法被 hook 了（通过替换 <code>IMP</code> 为 <code>_objc_msgForward</code>），会触发调用 <code>forwardInvocation:</code> 方法。但是子类的 <code>forwardInvocation:</code> 方法曾经被 Hook 过，所以此时不再是直接调用父类的实现，而是调用子类自己的实现，那么结果就是找不到方法，抛异常。</p></li><li><p>如果子类没被 hook 过，子类是没有 <code>forwardInvocation:</code> 方法的，会调用父类的方法实现。因为父类被 hook 了，所以会走 MessageThrottle 的消息转发流程，所以是不会出问题的。</p></li></ol><p>两者差别在于，调用 <code>forwardInvocation:</code> 方法时，已经 Hook 过的类会调用自己的实现，而不会调用父类的实现。</p><p>MessageThrottle 解决方案是记录所有 Hook 过的类，在 Hook 其他类之前先判断下是否已经有子类被 Hook 过。如果有，则作降级处理，打 Log 报错，不能继续 Hook。</p><p>这个方案虽然不完美，但总比抛异常 crash 好。连 Aspects 也没有注意到这点，亲测会 crash。</p><h2 id="规则持久化"><a href="#规则持久化" class="headerlink" title="规则持久化"></a>规则持久化</h2><p>如果限频规则只存在于内存中，那么其实是很不安全的。</p><p>有些场景下限频的周期很长，比如为了减少某条协议请求后台的次数，要求客户端一小时内最多请求一次。如果在一小时内 App 进程杀掉了然后又打开 App，这样就需要限频规则信息能够持久化存储，下次打开 App 读取并应用上次保存的规则。</p><p>对于 <code>target</code> 为类或元类、<code>MTPerformModeFirstly</code> 模式下且限频周期大于 5 秒的规则，MessageThrottle 会自动将其标记为持久化规则。</p><p>可以通过设置 <code>MTRule</code> 的 <code>persistent</code> 属性为 <code>YES</code>，来标记规则为需要持久化。对于 <code>target</code> 为实例对象的规则持久化是无意义的，因为进程杀掉后，实例对象的生命周期也就结束了，规则也就自动失效了。</p><p><code>MTRule</code> 中只有一部分数据能够持久化，一些动态的内容无法持久化，比如队列、block 等。需要注意区分类对象和元类。</p><p>可以使用 <code>savePersistentRules</code> 方法来保存持久化规则。对于 iOS、macOS 和 tvOS，会在收到 Terminate 通知时自动调用 <code>savePersistentRules</code> 方法。</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>每个 <code>MTRule</code> 都对应着一个递归锁，保证了此规则上的方法调用是线程安全的。<br>存储所有 target-selector 映射关系的 <code>MTEngine</code> 添加和废除规则涉及到对 <code>NSMapTable</code> 和 <code>NSMutableSet</code> 的操作，使用一个互斥锁来保证 <code>apply</code>、<code>discard</code> 和 <code>allRules</code> 等方法的线程安全。当一个 <code>MTRule</code> 在多个线程被频繁 <code>apply</code> 和 <code>discard</code> 的同时也可能会有这个 <code>MTRule</code> 的方法在多个线程频繁调用，所以还需要在 <code>apply</code> 和 <code>discard</code> 方法里也加一层 <code>MTRule</code> 的递归锁。</p><p>当然，如果在 hook 或 revert 的过程中调用了方法，但是没有走 MessageThrottle 的转发逻辑的话，还是有可能出现多线程问题。但这样的概率很低，我用下面类似的代码进行测试是 OK 的：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(<span class="name">dispatch_get_global_queue</span>(<span class="name">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">   for (<span class="name">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 10000; i ++) &#123;</span></span><br><span class="line">       dispatch_async(<span class="name">dispatch_get_global_queue</span>(<span class="name">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">           [rule apply]<span class="comment">;</span></span><br><span class="line">       &#125;)<span class="comment">;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line">dispatch_async(<span class="name">dispatch_get_global_queue</span>(<span class="name">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">   for (<span class="name">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 10000; i ++) &#123;</span></span><br><span class="line">       dispatch_async(<span class="name">dispatch_get_global_queue</span>(<span class="name">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">           [self.stub foo:[NSDate date]]<span class="comment">;</span></span><br><span class="line">       &#125;)<span class="comment">;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line">dispatch_async(<span class="name">dispatch_get_global_queue</span>(<span class="name">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">   for (<span class="name">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 10000; i ++) &#123;</span></span><br><span class="line">       dispatch_async(<span class="name">dispatch_get_global_queue</span>(<span class="name">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">           [rule discard]<span class="comment">;</span></span><br><span class="line">       &#125;)<span class="comment">;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line">dispatch_async(<span class="name">dispatch_get_global_queue</span>(<span class="name">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">   for (<span class="name">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 10000; i ++) &#123;</span></span><br><span class="line">       dispatch_async(<span class="name">dispatch_get_global_queue</span>(<span class="name">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">           [self.stub foo:[NSDate date]]<span class="comment">;</span></span><br><span class="line">       &#125;)<span class="comment">;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>因为 <code>MTPerformModeLast</code> 和 <code>MTPerformModeDebounce</code> 都是延时执行模式，所以有可能在延时的过程中，规则已经被废弃了，但是依然会调用到 <code>[invocation invoke]</code>，而此时需要注意 <code>invocation</code> 的 <code>selector</code>。如果规则已经被废弃了，需要使用原始的 <code>selector</code>，而不是 <code>aliasSelector</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/yulingtianxia/MessageThrottle&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MessageThrottle&lt;/a&gt; 是我开发的Objective-C 节流限频组件，其原理基于 Hook 消息转发流程，在运行时应用了一套节流限频的规则。&lt;/p&gt;
&lt;p&gt;新版本再次提升性能的同时，确保了 hook 流程、多线程操作、规则管理的安全性，支持了持久化规则，并对 KVO 等场景进行兼容。&lt;a href=&quot;https://github.com/yulingtianxia/MessageThrottle&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MessageThrottle&lt;/a&gt; 的代码测试覆盖率在 80% 以上，在编写测试用例的同时也发现了一些安全隐患，有些甚至是业界知名开源库都没有发现和解决的。&lt;/p&gt;
&lt;p&gt;本文是关于 &lt;a href=&quot;https://github.com/yulingtianxia/MessageThrottle&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MessageThrottle&lt;/a&gt; 的第四篇文章。前三篇如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2017/11/05/Objective-C-Message-Throttle-and-Debounce/&quot;&gt;Objective-C Message Throttle and Debounce&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2017/12/15/Associated-Object-and-Dealloc/&quot;&gt;Associated Object 与 Dealloc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2018/05/31/MessageThrottle-Performance-Benchmark-and-Optimization/&quot;&gt;MessageThrottle Performance Benchmark and Optimization&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yulingtianxia.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>追踪 Objective-C Block 代码定义的位置</title>
    <link href="http://yulingtianxia.com/blog/2018/06/24/Objective-C-Block-Mangle-Name/"/>
    <id>http://yulingtianxia.com/blog/2018/06/24/Objective-C-Block-Mangle-Name/</id>
    <published>2018-06-24T09:19:03.000Z</published>
    <updated>2019-05-26T10:08:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前写了一篇文章<a href="http://yulingtianxia.com/blog/2018/03/31/Track-Block-Arguments-of-Objective-C-Method/">《追踪 Objective-C 方法中的 Block 参数对象》</a>，利用 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 和 Objective-C 的动态特性实现对 block 对象执行和销毁的追踪。本文在此基础上，通过 Mach-O 文件格式获取 Mangle Name 并根据 Clang 源码实现对其解析，探寻如何追踪 block 代码定义的位置。</p><p>主要代码已经整合到 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 1.0.2 版本中。</p><a id="more"></a><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>能想到的最直接的方法就是获取 block 内部 invoke 函数的内存地址，并找到这个地址对应的 image，然后根据对基地址的偏移量，利用 dYSM 文件存储的符号表查找到对应代码位置。这属于很常规的操作了，即便没有 dYSM 文件，用 Mach-O 反汇编也能知道 block 定义在哪个方法的大概位置。</p><p>本文完？？？</p><p>太水了！！！</p><p>如果只需要知道 block 定义在哪个方法里的话，其实有更简单的方法呀！在程序运行时就能知道的，不用那么多麻烦的后续操作。解决思路如下：</p><ol><li>通过读取每个 Mach-O 镜像文件的符号表，建立 block invoke 函数偏移地址到符号名的映射。</li><li>获取到的符号名是经过 Clang 处理后的 mangle name，根据生成规则反推出 block invoke 函数实现代码位置。</li></ol><h2 id="Mach-O-文件格式"><a href="#Mach-O-文件格式" class="headerlink" title="Mach-O 文件格式"></a>Mach-O 文件格式</h2><p>网上关于 Mach-O 文件的介绍一大堆，这里不再赘述。其实就是个二进制文件格式定义，照着文档写代码读二进制内容罢了。苹果也提供了 Mach-O 文件数据结构的定义，直接用就行了。当二进制镜像被加载到虚拟内存中后，就可以通过计算各种偏移量来按图索骥了。下面的代码将 <code>_hunt_blocks_for_image</code> 注册为镜像加载后的回调函数，这行代码执行前已经加载的镜像也会回调此函数：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_dyld_register_func_for_add_image(<span class="name">_hunt_blocks_for_image</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><code>_hunt_blocks_for_image</code> 函数会读取一个 Mach-O 文件中的符号表。具体操作是先从遍历 Load Commands 入手，找到 <code>__LINKEDIT</code> 段的基地址以及符号表数据的偏移量及其字符串表的偏移量。然后遍历符号表，获取到符号地址和符号名的偏移量。如果符号名中包含 <code>_block_invoke</code> 则说明是 block 实现函数，然后用字典保存符号地址到符号名的映射。</p><p>遍历 Load Commands 时要注意，不同类型的 Load Command 数据类型也不一样，但是肯定会有 <code>cmd</code> 和 <code>cmdsize</code> 这两个字段。可以凭借 <code>cmd</code> 简单区分其数据结构。比如符号表的 <code>cmd</code> 是 <code>LC_SYMTAB</code>，其数据结构为 <code>symtab_command</code>。比如常见的 <code>cmd</code> 为 <code>LC_SEGMENT</code> 的『段』可以靠 <code>segname</code> 区分，类型有 <code>__PAGEZERO</code> <code>__TEXT</code> <code>__DATA</code> <code>__LINKEDIT</code> <code>__OBJC</code> 等等，有的『段』下面还有很多『节』(Section)。<code>__PAGEZERO</code> 段在可执行文件才有，大小跟架构有关，是虚拟内存基地址。符号表是一个 <code>nlist</code> 数组，保存着每个符号的一些信息，这里只用到了符号地址和符号名。</p><p>因为使用 <code>NSMapTable</code> 存储符号地址和符号名的映射，所以需要用 <code>pthread_mutex_t</code> 确保线程安全。</p><p><code>_hunt_blocks_for_image</code> 函数实现如下。我觉得我思想解释的够明白了，对于看过 fishhook 源码的人来说应该很简单。实在看不懂就自己对照着 MachOView 和苹果文档，随便找个方法计算一遍偏移量就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> NSMapTable *block_invoke_mangle_cache;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> block_invoke_mangle_cache_mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _hunt_blocks_for_image(<span class="keyword">const</span> struct mach_header *header, <span class="keyword">intptr_t</span> slide) &#123;</span><br><span class="line">    Dl_info info;</span><br><span class="line">    <span class="keyword">if</span> (dladdr(header, &amp;info) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">segment_command_t</span> *cur_seg_cmd;</span><br><span class="line">    <span class="keyword">segment_command_t</span> *linkedit_segment = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">segment_command_t</span> *pagezero_segment = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">symtab_command</span>* <span class="title">symtab_cmd</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uintptr_t</span> cur = (<span class="keyword">uintptr_t</span>)header + <span class="keyword">sizeof</span>(<span class="keyword">mach_header_t</span>);</span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123;</span><br><span class="line">        cur_seg_cmd = (<span class="keyword">segment_command_t</span> *)cur;</span><br><span class="line">        <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_LINKEDIT) == <span class="number">0</span>) &#123;</span><br><span class="line">                linkedit_segment = cur_seg_cmd;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(SEG_PAGEZERO, cur_seg_cmd-&gt;segname) == <span class="number">0</span>) &#123;</span><br><span class="line">                pagezero_segment = (<span class="keyword">segment_command_t</span>*)cur_seg_cmd;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SYMTAB) &#123;</span><br><span class="line">            symtab_cmd = (struct symtab_command*)cur_seg_cmd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!symtab_cmd || !linkedit_segment ) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uintptr_t</span> linkedit_base = (<span class="keyword">uintptr_t</span>)slide + linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff;</span><br><span class="line">    <span class="keyword">nlist_t</span> *symtab = (<span class="keyword">nlist_t</span> *)(linkedit_base + symtab_cmd-&gt;symoff);</span><br><span class="line">    <span class="keyword">char</span> *strtab = (<span class="keyword">char</span> *)(linkedit_base + symtab_cmd-&gt;stroff);</span><br><span class="line">    </span><br><span class="line">    pthread_mutex_lock(&amp;block_invoke_mangle_cache_mutex);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!block_invoke_mangle_cache) &#123;</span><br><span class="line">        block_invoke_mangle_cache = [NSMapTable mapTableWithKeyOptions:NSPointerFunctionsOpaqueMemory | NSMapTableObjectPointerPersonality valueOptions:NSPointerFunctionsCopyIn];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; symtab_cmd-&gt;nsyms; i++) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> strtab_offset = symtab[i].n_un.n_strx;</span><br><span class="line">        <span class="keyword">char</span> *symbol_name = strtab + strtab_offset;</span><br><span class="line">        <span class="keyword">bool</span> symbol_name_longer_than_1 = symbol_name[<span class="number">0</span>] &amp;&amp; symbol_name[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (!symbol_name_longer_than_1) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">uintptr_t</span> block_addr = (<span class="keyword">uintptr_t</span>)info.dli_fbase + symtab[i].n_value - (pagezero_segment ? pagezero_segment-&gt;vmsize : <span class="number">0</span>);</span><br><span class="line">        NSString *symbolName = [NSString stringWithUTF8String:&amp;symbol_name[<span class="number">1</span>]];</span><br><span class="line">        NSRange range = [symbolName rangeOfString:@<span class="string">"_block_invoke"</span>];</span><br><span class="line">        <span class="keyword">if</span> (range.location != NSNotFound &amp;&amp; range.location &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            [block_invoke_mangle_cache setObject:symbolName forKey:(__bridge id)(<span class="keyword">void</span> *)block_addr];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pthread_mutex_unlock(&amp;block_invoke_mangle_cache_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Block-Mangle-Name"><a href="#Block-Mangle-Name" class="headerlink" title="Block Mangle Name"></a>Block Mangle Name</h2><p>Clang 7.0.0 源码的 <a href="https://clang.llvm.org/doxygen/Mangle_8cpp_source.html#l00060" target="_blank" rel="noopener">Mangle.cpp</a> 文件实现了 Objective-C 和 block 的 mangle name。只需要看 <code>mangleBlock</code> 和 <code>mangleGlobalBlock</code> 两个函数即可大概了解 block mangle name 的生成规则。</p><ol><li>全局 block：block 变量名 + <code>_block_invoke</code> + <code>discriminator</code>。详见 <code>mangleGlobalBlock</code> 函数实现。</li><li>其他 block：<code>__</code> + block 代码所处的函数或方法的 mangle name + <code>_block_invoke</code> + <code>discriminator</code>。详见 <code>mangleBlock</code> 函数实现。</li></ol><p>需要注意的是 <code>discriminator</code> 是从第二个才开始显示的。比如在 <code>Foo</code> 类的 <code>bar</code> 方法中定义了两个 block，那么这两个 block 的 mangle name 就是 <code>__10_-[Foo bar]_block_invoke</code> 和 <code>__10_-[Foo bar]_block_invoke_2</code>。在 gcc 里稍有区别，第一个 block 的 mangle name 也会显示 <code>discriminator</code>。前面的 “10” 是方法名 <code>-[Foo bar]</code> 的字符串长度。这部分属于 Objective-C 方法名的 mangle name 规则，C++ 函数也有类似的规则，不仅用数字保存字符串长度，还有其他字母表示方法类型和参数类型等。这里不展开细讲了，看源码都能找到。</p><p>于是只要能拿到 mangle name，就能推断出定义 block 代码所处的位置咯。不带 <code>__</code> 的就是全局 block 咯？我并没有打算写代码来解析下 mangle name 的规则，还是交给调用方去使用吧。</p><p><a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 的 <code>BHToken</code> 类新增了 <code>mangleName</code> 属性，只需要使用原始的 invoke 函数地址作为 Key 即可从字典里获得这个 block 对应的 <code>mangleName</code>:</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)mangleName</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable">_mangleName</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;block_invoke_mangle_cache_mutex);</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">_originInvoke</span>) &#123;</span><br><span class="line">            <span class="variable">_mangleName</span> = [block_invoke_mangle_cache objectForKey:(<span class="variable">__bridge</span> id)<span class="variable">_originInvoke</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;block_invoke_mangle_cache_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="variable">_mangleName</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个多次 hook 的问题。所谓的 <code>_originInvoke</code> 只是这次 hook 相对的原始实现函数，它可能处在多次 hook 中的一环，而不是最原始的 block 实现，此时是拿不到 <code>mangleName</code>。所以需要用第一次 hook block 的 token 来获取 <code>mangleName</code>。PS:想搞倒是可以搞，把 hook block 产生的 token 都保存起来，然后按照 <code>_originInvoke</code> 和 <code>_replacementInvoke</code> 顺藤摸瓜就行，不难，顺便还能解决 <code>remove</code> 操作的顺序问题。我懒的搞，目前场景太小意义不大。</p><p>想了解 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 原理的，可以看这篇文章：<a href="http://yulingtianxia.com/blog/2018/02/28/Hook-Objective-C-Block-with-Libffi/">Hook Objective-C Block with Libffi</a>。（继续疯狂炒冷饭。。。）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 和 <a href="https://github.com/yulingtianxia/BlockTracker" target="_blank" rel="noopener">BlockTracker</a> 都已经支持获取 block 的 mangle name 了。</p><p>不知道 dyld 3 强制应用后会不会对此有影响，我就是遍历这个二进制文件自己的符号表而已呀，动态重定向的我又不 care。反正 fishhook 到时候估计是 gg 了，因为 dyld 3 会在加载时解析所有符号表，也就是固定下来了，没跳板了。</p><p>然而我还是这么菜，赶在月底前写了个篇幅短小全是常识的大水文。。。</p><p>本文完。。。</p><p>太水了！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前写了一篇文章&lt;a href=&quot;http://yulingtianxia.com/blog/2018/03/31/Track-Block-Arguments-of-Objective-C-Method/&quot;&gt;《追踪 Objective-C 方法中的 Block 参数对象》&lt;/a&gt;，利用 &lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BlockHook&lt;/a&gt; 和 Objective-C 的动态特性实现对 block 对象执行和销毁的追踪。本文在此基础上，通过 Mach-O 文件格式获取 Mangle Name 并根据 Clang 源码实现对其解析，探寻如何追踪 block 代码定义的位置。&lt;/p&gt;
&lt;p&gt;主要代码已经整合到 &lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BlockHook&lt;/a&gt; 1.0.2 版本中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yulingtianxia.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>MessageThrottle Performance Benchmark and Optimization</title>
    <link href="http://yulingtianxia.com/blog/2018/05/31/MessageThrottle-Performance-Benchmark-and-Optimization/"/>
    <id>http://yulingtianxia.com/blog/2018/05/31/MessageThrottle-Performance-Benchmark-and-Optimization/</id>
    <published>2018-05-30T18:01:50.000Z</published>
    <updated>2019-05-26T10:08:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/yulingtianxia/MessageThrottle" target="_blank" rel="noopener">MessageThrottle</a> 是我开发的Objective-C 节流限频组件，其原理基于 Hook 消息转发流程，所以相比直接调用方法，会有一些性能上的损耗。本篇文章记录了对其性能进行测试的结果，并通过使用 <code>NSMapTable</code> 改进存储结构和缓存来对性能进行大幅度的优化。</p><p>这是你从未体验过的船新版本。</p><a id="more"></a><p>关于 <a href="https://github.com/yulingtianxia/MessageThrottle" target="_blank" rel="noopener">MessageThrottle</a> 最初的实现原理可以参考 <a href="http://yulingtianxia.com/blog/2017/11/05/Objective-C-Message-Throttle-and-Debounce/">Objective-C Message Throttle and Debounce</a>。</p><h2 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a>Benchmark</h2><p>Xcode 自带的单元测试框架可以很方便的测量一个方法的执行效率，<code>measureBlock</code> 里的代码会被执行十次，测试结束后会得到每次执行耗时，以及平均数和方差。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testPerformanceExample &#123;</span><br><span class="line">    <span class="comment">// This is an example of a performance test case.</span></span><br><span class="line">    <span class="built_in">NSDate</span> *date = [<span class="built_in">NSDate</span> date];</span><br><span class="line">    [<span class="keyword">self</span> measureBlock:^&#123;</span><br><span class="line">        <span class="comment">// Put the code you want to measure the time of here.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">                [<span class="keyword">self</span>.sstub foo:date];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>性能损耗大多发生在消息转发流程上的处理，为了能够校准基线，需要让每次消息发送都执行。MessageThrottle 1.2.0 刚刚支持了让某些条件下消息永远执行的特性：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setUp &#123;</span><br><span class="line">    [<span class="keyword">super</span> setUp];</span><br><span class="line">    <span class="comment">// Put setup code here. This method is called before the invocation of each test method in the class.</span></span><br><span class="line">    self.sstub = [SuperStub <span class="keyword">new</span>];</span><br><span class="line">    MTRule *rule = [self.sstub <span class="string">mt_limitSelector:</span><span class="meta">@selector</span>(<span class="string">foo:</span>) <span class="string">oncePerDuration:</span><span class="number">0.01</span> <span class="string">usingMode:</span>MTPerformModeDebounce];</span><br><span class="line">    rule.alwaysInvokeBlock =  ^(MTRule *rule, NSDate *date) &#123;</span><br><span class="line">        <span class="keyword">return</span> YES; <span class="comment">// 让消息永远都执行</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调整 <code>foo:</code> 方法的耗时来得到调用不同耗时函数的测试结果。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">foo:</span>(NSDate *)arg &#123;</span><br><span class="line">    [NSThread <span class="string">sleepForTimeInterval:</span><span class="number">0.0001</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终得到一组数据，测试机器为 iPhone 8 plus。</p><table><thead><tr><th>执行模式\被调用方法耗时</th><th>0.0001</th><th>0.001</th></tr></thead><tbody><tr><td>不使用 MT</td><td>0.118(baseline)</td><td>1.17(baseline)</td></tr><tr><td>MT 立即执行</td><td>0.135(14.4%worse)</td><td>1.33(13.8%worse)</td></tr><tr><td>MT debounce 0.01s</td><td>0.0281(76.2%better)</td><td>0.0279(97.6%better)</td></tr></tbody></table><ol><li>测试的基准数据为不使用 MessageThottle，直接调用方法。</li><li>使用 MessageThottle 后，消息转发流程会带来多余的耗时会导致性能下降，而且被调用方法耗时越少，性能下降得越明显（比较两列数据）。</li><li>如果加了消息限频，会忽略掉一部分调用，这样当出现大量频繁调用时，方法真正执行的次数很少，性能反而大大提升了（第三行数据）</li></ol><h2 id="Optimization"><a href="#Optimization" class="headerlink" title="Optimization"></a>Optimization</h2><p>通过性能优化，将消息转发流程产生的耗时降低了将近 50%。并加强了线程安全。</p><table><thead><tr><th>执行模式\被调用方法耗时</th><th>0.0001</th><th>0.001</th></tr></thead><tbody><tr><td>不使用 MT</td><td>0.118(baseline)</td><td>1.17(baseline)</td></tr><tr><td>MT 立即执行</td><td>0.135(14.4%worse)</td><td>1.33(13.8%worse)</td></tr><tr><td>性能优化后</td><td>0.126(6.88%worse)</td><td>1.25(6.93%worse)</td></tr></tbody></table><p>为了方便管理和查看所有的 <code>MTRule</code>，使用了 <code>MTEngine</code> 单例进行中心化的管理。获取一个 <code>MTRule</code> 之前，需要先用 <code>target</code> 和 <code>selector</code> 生成一个描述字符串，然后用这个字符串作为 Key 在 <code>MTEngine</code> 的字典里查询对应的 <code>MTRule</code> 对象。每次应用和废除规则、消息发送时都要频繁从 <code>MTEngine</code> 获取 <code>MTRule</code> 对象，由此也产生了大量开销。这里的性能瓶颈主要有两点：</p><ol><li>生成描述字符串造成的开销。</li><li>从 <code>MTEngine</code> 加锁的字典获取 <code>MTRule</code> 的等待开销。</li></ol><p>应用和废除规则的时候，这两点开销并不明显。但当所有应用规则的消息发送都要经过这两步的时候，这俨然成了拥堵的重灾区。当然治理方案也是相对的：</p><ol><li><p>改进 <code>MTEngine</code> 中字典的存储结构，使用 <code>NSMapTable</code> 替换 <code>NSMutableDictionary</code>。因为 <code>NSMapTable</code> 支持将任意指针作为 Key 且无需持有，可以将 <code>target</code> 作为 Key，Value 为这个 <code>target</code> 对应的 <code>selector</code> 集合。<code>MTEngine</code> 不再持有 <code>MTRule</code> 对象，而只是存储了所有应用规则的 <code>target</code> 及其 <code>selector</code>。而 <code>MTRule</code> 对象改为由其 <code>target</code> 通过 AssociatedObject 的方式持有，可以很方便通过 <code>selector</code> 存取。当 <code>target</code> 销毁后，它关联的 <code>MTRule</code> 对象也会被销毁，<code>NSMapTable</code> 也会自动移除那些键或值为 <code>nil</code> 的数据。下面是 <code>MTEngine</code> 封装了 <code>NSMapTable</code> 字典对应的便捷方法。</p> <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">_targetSELs = [<span class="built_in">NSMapTable</span> weakToStrongObjectsMapTable];</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加 target-selector 记录</span></span><br><span class="line">- (<span class="keyword">void</span>)addSelector:(SEL)selector onTarget:(<span class="keyword">id</span>)target</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!target) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSMutableSet</span> *selectors = [<span class="keyword">self</span>.targetSELs objectForKey:target];</span><br><span class="line">    <span class="keyword">if</span> (!selectors) &#123;</span><br><span class="line">        selectors = [<span class="built_in">NSMutableSet</span> set];</span><br><span class="line">    &#125;</span><br><span class="line">    [selectors addObject:<span class="built_in">NSStringFromSelector</span>(selector)];</span><br><span class="line">    [<span class="keyword">self</span>.targetSELs setObject:selectors forKey:target];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移除 target-selector 记录</span></span><br><span class="line">- (<span class="keyword">void</span>)removeSelector:(SEL)selector onTarget:(<span class="keyword">id</span>)target</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!target) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSMutableSet</span> *selectors = [<span class="keyword">self</span>.targetSELs objectForKey:target];</span><br><span class="line">    <span class="keyword">if</span> (!selectors) &#123;</span><br><span class="line">        selectors = [<span class="built_in">NSMutableSet</span> set];</span><br><span class="line">    &#125;</span><br><span class="line">    [selectors removeObject:<span class="built_in">NSStringFromSelector</span>(selector)];</span><br><span class="line">    [<span class="keyword">self</span>.targetSELs setObject:selectors forKey:target];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//是否存在 target-selector 记录</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)containsSelector:(SEL)selector onTarget:(<span class="keyword">id</span>)target</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span>.targetSELs objectForKey:target] containsObject:<span class="built_in">NSStringFromSelector</span>(selector)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//是否存在 target-selector 记录，未指定具体 target，但 target 的类型为 cls 即可</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)containsSelector:(SEL)selector onTargetsOfClass:(Class)cls</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span> target <span class="keyword">in</span> [[<span class="keyword">self</span>.targetSELs keyEnumerator] allObjects]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mt_object_isClass(target) &amp;&amp;</span><br><span class="line">            [target isMemberOfClass:cls] &amp;&amp;</span><br><span class="line">            [[<span class="keyword">self</span>.targetSELs objectForKey:target] containsObject:<span class="built_in">NSStringFromSelector</span>(selector)]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>每个 <code>MTRule</code> 有自己独立的递归锁，这样避免了在 <code>forwardInvocation</code> 里千军万马过独木桥的拥堵，且不妨碍递归调用的场景。存取 <code>MTEngine</code> 的字典依然使用普通的互斥锁。这两个锁都使用性能较好的 <code>pthread_mutex_t</code> 实现。</p> <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> // 初始化递归锁</span><br><span class="line"> pthread_mutexattr_t <span class="meta">attr</span><span class="comment">;</span></span><br><span class="line"> pthread_mutexattr_init(&amp;<span class="meta">attr</span>)<span class="comment">;</span></span><br><span class="line"> pthread_mutexattr_settype(&amp;<span class="meta">attr</span>, PTHREAD_MUTEX_RECURSIVE)<span class="comment">;</span></span><br><span class="line"> pthread_mutex_t mutex = mtDealloc.invokeLock<span class="comment">;</span></span><br><span class="line"> pthread_mutex_init(&amp;mutex, &amp;<span class="meta">attr</span>)<span class="comment">;</span></span><br><span class="line"> objc_setAssociatedObject(rule.target, rule.<span class="keyword">selector, </span>mtDealloc, OBJC_ASSOCIATION_RETAIN)<span class="comment">;</span></span><br><span class="line">     </span><br><span class="line"><span class="symbol">...</span></span><br><span class="line"></span><br><span class="line"> // 消息转发时保证线程安全</span><br><span class="line"> static void mt_forwardInvocation(__unsafe_unretained id assignSlf, <span class="keyword">SEL </span><span class="keyword">selector, </span>NSInvocation *invocation)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">SEL </span>originalSelector = invocation.<span class="keyword">selector;</span></span><br><span class="line"><span class="keyword"> </span>    <span class="keyword">SEL </span>fixedOriginalSelector = mt_aliasForSelector(originalSelector)<span class="comment">;</span></span><br><span class="line">     <span class="meta">if</span> (![assignSlf respondsToSelector:fixedOriginalSelector]) &#123;</span><br><span class="line">         mt_executeOrigForwardInvocation(assignSlf, <span class="keyword">selector, </span>invocation)<span class="comment">;</span></span><br><span class="line">         return<span class="comment">;</span></span><br><span class="line">     &#125;</span><br><span class="line">     MTDealloc *mtDealloc = objc_getAssociatedObject(invocation.target, <span class="keyword">selector);</span></span><br><span class="line"><span class="keyword"> </span>    pthread_mutex_t mutex = mtDealloc.invokeLock<span class="comment">;</span></span><br><span class="line">     pthread_mutex_lock(&amp;mutex)<span class="comment">;</span></span><br><span class="line">     mt_handleInvocation(invocation, fixedOriginalSelector)<span class="comment">;</span></span><br><span class="line">     pthread_mutex_unlock(&amp;mutex)<span class="comment">;</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>MTEngine</code> 中字典的存储结构的改进不仅提高了性能，还让设计思路更清晰。在添加或废除规则的时候，旧方案需要遍历所有的 <code>MTRule</code> 对象，然后通过检查 <code>target</code> 和 <code>selector</code> 来判断规则是否相互干扰；新方案直接存储了 <code>target</code> 和对应的 <code>selector</code> 数组，声明如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMapTable</span>&lt;<span class="keyword">id</span>, <span class="built_in">NSMutableSet</span>&lt;<span class="built_in">NSString</span> *&gt; *&gt; *targetSELs;</span><br></pre></td></tr></table></figure><p>这样的存储方式可以更高效地找到某个对象或类的某个方法是否被限频了，增删规则也更快。</p><p>在 Hook 某个方法的时候，会给它生成一个新的方法名，这就又涉及到字符串拼接的开销。解决方案是使用缓存来映射两个 <code>SEL</code> 指针，又要用到 <code>NSMapTable</code> 大显神威了。这又将节省 6% 左右的 CPU 耗时！需要注意的是创建 <code>NSMapTable</code> 时的选项，以及存取时的类型强转：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化 NSMapTable 缓存</span></span><br><span class="line">_aliasSelectorCache = [<span class="built_in">NSMapTable</span> mapTableWithKeyOptions:<span class="built_in">NSPointerFunctionsOpaqueMemory</span> | <span class="built_in">NSMapTableObjectPointerPersonality</span> valueOptions:<span class="built_in">NSPointerFunctionsOpaqueMemory</span> | <span class="built_in">NSMapTableObjectPointerPersonality</span>];</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在方法内部使用缓存优化性能</span></span><br><span class="line"><span class="keyword">static</span> SEL mt_aliasForSelector(SEL selector)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;alias_selector_mutex);</span><br><span class="line">    SEL aliasSelector = (__bridge <span class="keyword">void</span> *)[MTEngine.defaultEngine.aliasSelectorCache objectForKey:(__bridge <span class="keyword">id</span>)(<span class="keyword">void</span> *)selector];</span><br><span class="line">    <span class="keyword">if</span> (!aliasSelector) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *selectorName = <span class="built_in">NSStringFromSelector</span>(selector);</span><br><span class="line">        aliasSelector = <span class="built_in">NSSelectorFromString</span>([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"__mt_%@"</span>, selectorName]);</span><br><span class="line">        [MTEngine.defaultEngine.aliasSelectorCache setObject:(__bridge <span class="keyword">id</span>)(<span class="keyword">void</span> *)aliasSelector forKey:(__bridge <span class="keyword">id</span>)(<span class="keyword">void</span> *)selector];</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;alias_selector_mutex);</span><br><span class="line">    <span class="keyword">return</span> aliasSelector;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能有人会担心直接缓存 <code>SEL</code> 指针会不会命中率很低。因为所有名字相同的方法都拥有同一个唯一的 <code>SEL</code>，所以可以很快速地用直接指针地址判等。可以参考<a href="https://stackoverflow.com/questions/11051528/understanding-uniqueness-of-selectors-in-objective-c?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa" target="_blank" rel="noopener">这里</a>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>更新 <a href="https://github.com/yulingtianxia/MessageThrottle" target="_blank" rel="noopener">MessageThrottle</a> 到最新版即可获取到更快更强更安全的 Objective 消息节流限频功能，一行代码搞定频繁调用的问题。</p><p>新版本在废除消息的时候，也增强了对合法性和安全性的检查。（说白了就是改 bug）</p><p>理论上我的另一个组件 <a href="https://github.com/yulingtianxia/BlockTracker" target="_blank" rel="noopener">BlockTracker</a> 也可以按照本文的方案优化性能了，嘿嘿，有时间搞下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/yulingtianxia/MessageThrottle&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MessageThrottle&lt;/a&gt; 是我开发的Objective-C 节流限频组件，其原理基于 Hook 消息转发流程，所以相比直接调用方法，会有一些性能上的损耗。本篇文章记录了对其性能进行测试的结果，并通过使用 &lt;code&gt;NSMapTable&lt;/code&gt; 改进存储结构和缓存来对性能进行大幅度的优化。&lt;/p&gt;
&lt;p&gt;这是你从未体验过的船新版本。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yulingtianxia.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Colorful Rounded Rect Dash Border</title>
    <link href="http://yulingtianxia.com/blog/2018/04/30/Colorful-Rounded-Rect-Dash-Border/"/>
    <id>http://yulingtianxia.com/blog/2018/04/30/Colorful-Rounded-Rect-Dash-Border/</id>
    <published>2018-04-30T09:25:44.000Z</published>
    <updated>2019-05-26T10:08:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>产品经理要求做个能展示进度的分段彩色外环，大概长这样：</p><p><img src="https://github.com/yulingtianxia/YXYDashLayer/blob/master/Assets/YXYDashLayer.gif?raw=true" alt></p><p>花了两天左右来实现和优化，记录下踩坑经历。</p><p>组件已经开源，取个名字叫 <code>YXYDashLayer</code> 吧：<a href="https://github.com/yulingtianxia/YXYDashLayer" target="_blank" rel="noopener">https://github.com/yulingtianxia/YXYDashLayer</a></p><a id="more"></a><h2 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h2><p>因为考虑到要做成稍微通用一些的组件，最底层的 <code>YXYMaskDashLayer</code> 接口设计如下。其他类的属性也都是对它的封装。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 分段的间隙</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> dashGap;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 线宽</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> dashWidth;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 矩形的圆角半径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> dashCornerRadius;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 分段总数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> totalCount;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 需要显示哪些分段的 index</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSNumber</span> *&gt; *showIndexes;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 刷新整个Layer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)refresh;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 仅刷新 Dash 的 totalCount、dashGap 和 showIndexes</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)refreshDash;</span><br></pre></td></tr></table></figure><p>因为有些属性改变后并不需要重新绘制 path，为了实现更好的性能，所以还提供了一个只刷新 dash 数据的接口 <code>refreshDash</code>。</p><p>具体使用的例子可以运行 Demo 程序。</p><h2 id="思路很重要"><a href="#思路很重要" class="headerlink" title="思路很重要"></a>思路很重要</h2><p>之前的样式是个圆形的分段外环，而且是纯色的，看了下以前的代码，是按照弧度均分后，从顶部开始按顺时针一段一段 path 组合起来的。用 <code>UIBezierPath</code> 的 <code>+ bezierPathWithArcCenter:radius:startAngle:endAngle:clockwise:</code> 方法即可画出来。</p><p>然而现在改成了圆角矩形的，要按照周长均分来画分段，实现方式完全不同。因为圆形只是圆角矩形的一种特殊情况，所以需要另一种更通用的实现方式。因为借鉴了圆形分段一段段画的思想，最开始想到的也是一段段画圆角矩形，需要把整个圆角矩形划分成 9 个区域（四个四分之一圆弧，四条直线，顶部直线需要分成两块），还要对圆角和直线部分的边界处理，涉及到大量的计算。我刚开始要这么干的时候，觉得这么做有点笨，肯定有更简单的方案。</p><p><code>CAShapeLayer</code> 的 <code>lineDashPattern</code> 和 <code>lineDashPhase</code> 属性就可以实现这个需求了，之前一直被旧代码的方案限制了思路。真是退一步海阔天空啊。原本跟产品说这有 5 天工作量，结果半个小时就写出个 demo，哈哈。然后用剩下的时间继续完善打磨，做成通用组件。</p><h2 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h2><ol><li>先用贝塞尔曲线画一个圆角矩形(就叫 <code>path</code> 吧)</li><li><code>path.CGPath</code> 赋值给 <code>CAShapeLayer</code> 实例（就叫 <code>maskLayer</code> 吧）</li><li>根据线宽、分段间隙、<code>path</code> 周长、总分段数、要展示的分段 index，可计算出 <code>lineDashPattern</code> 和 <code>lineDashPhase</code> 的值，刷新 <code>maskLayer</code></li><li>将 <code>maskLayer</code> 赋值给 <code>CAGradientLayer</code> 实例的 <code>mask</code>。调整 <code>colors</code> 等属性即可实现一个彩色渐变分段圆角矩形外圈。</li><li>将多个这样的 <code>CAGradientLayer</code> 实例重叠在一起，即可实现个别分段『高亮』效果。比如一个 layer 当做底色，另一个放上面当做灰色进度条。（PS：本文最开始的 gif 就是这样）</li></ol><p>这里面踩坑最多的就是前 3 个步骤，计算时需要考虑到一些边界条件。</p><h3 id="画圆角矩形的坑"><a href="#画圆角矩形的坑" class="headerlink" title="画圆角矩形的坑"></a>画圆角矩形的坑</h3><p><code>+ bezierPathWithRoundedRect:cornerRadius:</code> 方法是可以直接画出一个圆角矩形的，但是路径的起始点并没确定。表面上看上去是从顶部直线左端开始顺时针画，然而会有向右的一些偏差。这样就无法精确计算出 <code>lineDashPhase</code> 的值，导致画出来的效果不对称了。</p><p>于是我这里干脆自己画个圆角矩形，代码也很简单。由于要考虑到线宽，所以需要计算下真正的圆角半径和外接矩形尺寸，顺时针画四段直线四段四分之一圆弧即可。下面的代码是写在 <code>CAShapeLayer</code> 子类里的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line"><span class="keyword">self</span>.dashRect = <span class="built_in">CGRectInset</span>(<span class="keyword">self</span>.bounds, <span class="keyword">self</span>.dashWidth / <span class="number">2</span>, <span class="keyword">self</span>.dashWidth / <span class="number">2</span>);</span><br><span class="line"><span class="built_in">CGFloat</span> width = <span class="keyword">self</span>.dashRect.size.width;</span><br><span class="line"><span class="built_in">CGFloat</span> height = <span class="keyword">self</span>.dashRect.size.height;</span><br><span class="line"><span class="keyword">self</span>.realDashCornerRadius = MIN(<span class="keyword">self</span>.dashCornerRadius - <span class="keyword">self</span>.dashWidth / <span class="number">2</span>, width / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">self</span>.realDashCornerRadius = MAX(<span class="number">0</span>, <span class="keyword">self</span>.realDashCornerRadius);</span><br><span class="line"><span class="built_in">CGPoint</span> center = <span class="built_in">CGPointMake</span>(<span class="keyword">self</span>.frame.size.width / <span class="number">2</span>, <span class="keyword">self</span>.frame.size.height / <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">[path moveToPoint:<span class="built_in">CGPointMake</span>(center.x - width / <span class="number">2</span> + <span class="keyword">self</span>.realDashCornerRadius, center.y - height / <span class="number">2</span>)];</span><br><span class="line">    </span><br><span class="line">[path addLineToPoint:<span class="built_in">CGPointMake</span>(center.x + width / <span class="number">2</span> - <span class="keyword">self</span>.realDashCornerRadius, center.y - height / <span class="number">2</span>)];</span><br><span class="line">    </span><br><span class="line">[path addArcWithCenter:<span class="built_in">CGPointMake</span>(center.x + width / <span class="number">2</span> - <span class="keyword">self</span>.realDashCornerRadius, center.y - height / <span class="number">2</span> + <span class="keyword">self</span>.realDashCornerRadius) radius:<span class="keyword">self</span>.realDashCornerRadius startAngle:M_PI_2 * <span class="number">3</span> endAngle:<span class="number">0</span> clockwise:<span class="literal">YES</span>];</span><br><span class="line">    </span><br><span class="line">[path addLineToPoint:<span class="built_in">CGPointMake</span>(center.x + width / <span class="number">2</span>, center.y + height / <span class="number">2</span> - <span class="keyword">self</span>.realDashCornerRadius)];</span><br><span class="line">    </span><br><span class="line">[path addArcWithCenter:<span class="built_in">CGPointMake</span>(center.x + width / <span class="number">2</span> - <span class="keyword">self</span>.realDashCornerRadius, center.y + height / <span class="number">2</span> - <span class="keyword">self</span>.realDashCornerRadius) radius:<span class="keyword">self</span>.realDashCornerRadius startAngle:<span class="number">0</span> endAngle:M_PI_2 clockwise:<span class="literal">YES</span>];</span><br><span class="line">    </span><br><span class="line">[path addLineToPoint:<span class="built_in">CGPointMake</span>(center.x - width / <span class="number">2</span> + <span class="keyword">self</span>.realDashCornerRadius, center.y + height / <span class="number">2</span>)];</span><br><span class="line">    </span><br><span class="line">[path addArcWithCenter:<span class="built_in">CGPointMake</span>(center.x - width / <span class="number">2</span> + <span class="keyword">self</span>.realDashCornerRadius, center.y + height / <span class="number">2</span> - <span class="keyword">self</span>.realDashCornerRadius) radius:<span class="keyword">self</span>.realDashCornerRadius startAngle:M_PI_2 endAngle:M_PI clockwise:<span class="literal">YES</span>];</span><br><span class="line">    </span><br><span class="line">[path addLineToPoint:<span class="built_in">CGPointMake</span>(center.x - width / <span class="number">2</span>, center.y - height / <span class="number">2</span> + <span class="keyword">self</span>.realDashCornerRadius)];</span><br><span class="line">    </span><br><span class="line">[path addArcWithCenter:<span class="built_in">CGPointMake</span>(center.x - width / <span class="number">2</span> + <span class="keyword">self</span>.realDashCornerRadius, center.y - height / <span class="number">2</span> + <span class="keyword">self</span>.realDashCornerRadius) radius:<span class="keyword">self</span>.realDashCornerRadius startAngle:M_PI endAngle:M_PI_2 * <span class="number">3</span> clockwise:<span class="literal">YES</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.totalLength = (width + height) * <span class="number">2</span> - <span class="keyword">self</span>.realDashCornerRadius * <span class="number">8</span> + M_PI * <span class="keyword">self</span>.realDashCornerRadius * <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">self</span>.lineWidth = <span class="keyword">self</span>.dashWidth;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">self</span>.path = path.CGPath;</span><br></pre></td></tr></table></figure><p>上面的代码也计算出了周长，用于下一步的分段长度计算。</p><h3 id="处理边界值"><a href="#处理边界值" class="headerlink" title="处理边界值"></a>处理边界值</h3><p>圆角矩形的周长已经算出来了，外部提供了 <code>dashGap</code>，但是绘制时真正的分段间隙是需要考虑到线宽和分段总数的。因为线的边缘会有个半圆，半径为二分之一线宽。当只有一个分段的时候画一个完整的圆角矩形，不需要有间隙了。如果分段总数过多导致计算的分段长度 <code>pieceLength</code> 小于 0，需要计算能展示出来分段数的最大值 <code>realTotalCount</code>，并重新计算分段长度 <code>pieceLength</code>。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGFloat</span> realDashGap = (<span class="keyword">self</span>.totalCount == <span class="number">1</span>) ? <span class="number">0</span> : <span class="keyword">self</span>.dashGap + <span class="keyword">self</span>.dashWidth;</span><br><span class="line"><span class="built_in">NSUInteger</span> realTotalCount = <span class="keyword">self</span>.totalCount;</span><br><span class="line"><span class="built_in">CGFloat</span> pieceLength = <span class="keyword">self</span>.totalLength / <span class="keyword">self</span>.totalCount - realDashGap;</span><br><span class="line"><span class="keyword">if</span> (pieceLength &lt; <span class="number">0</span>) &#123;</span><br><span class="line">   pieceLength = <span class="number">0</span>;</span><br><span class="line">   realTotalCount = <span class="keyword">self</span>.totalLength / realDashGap;</span><br><span class="line">   pieceLength = <span class="keyword">self</span>.totalLength / realTotalCount - realDashGap;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"Can't show! Reduce total count or dash gap! Real Total Count: %lu, Real Dash Gap:%ff"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)realTotalCount, realDashGap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dash-策略"><a href="#Dash-策略" class="headerlink" title="Dash 策略"></a>Dash 策略</h3><p><code>lineDashPhase</code> 可以理解为 dash 距离 path 起始点的距离，想让 dash 从顶部中间开始，需要设置初始值：二分之一外接矩形宽度的减去圆角半径，再加上二分之一 <code>realDashGap</code>。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self.lineDashPhase </span>= - (<span class="keyword">self.dashRect.size.width </span>/ <span class="number">2</span> - <span class="keyword">self.realDashCornerRadius </span>+ realDashGap / <span class="number">2</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>然后就是顺时针画需要展示的分段。输入是一个 <code>showIndexes</code> 数组，比如一共有 10 个分段，想展示的是前两个和最后一个分段，那么 <code>showIndexes</code> 的内容就是 <code>@[@0, @1, @9]</code>。此时 <code>lineDashPattern</code> 的值就应该是（<code>pieceLength</code> 就是每个分段的长度）：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@[</span><span class="meta">@pieceLength,</span> <span class="meta">@realDashGap,</span> <span class="meta">@pieceLength,</span> <span class="meta">@(realDashGap</span> <span class="symbol">*</span> 8 + pieceLength <span class="symbol">*</span> 7), <span class="meta">@pieceLength,</span> <span class="meta">@realDashGap]</span></span><br></pre></td></tr></table></figure><p>如果 <code>showIndexes</code> 的内容是 <code>@[@1, @2, @9]</code>，可不可以让 <code>lineDashPattern</code> 数组前面填 <code>@0</code> 呢？</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@[</span><span class="meta">@0,</span> <span class="meta">@(pieceLength</span> + realDashGap), <span class="meta">@pieceLength,</span> <span class="meta">@realDashGap,</span> <span class="meta">@pieceLength,</span> <span class="meta">@(realDashGap</span> <span class="symbol">*</span> 7 + pieceLength <span class="symbol">*</span> 6), <span class="meta">@pieceLength,</span> <span class="meta">@realDashGap]</span></span><br></pre></td></tr></table></figure><p>因为把 <code>lineCap</code> 设为了 <code>kCALineCapRound</code>，即便长度为 0 路径也会展示成为一个圆点，半径就是线宽。然而安卓系统对应的 API 在这种情况就不会绘制出圆点。为此 iOS 更麻烦一点，需要再次调整<code>lineDashPhase</code> 的值来『越过』前面几个分段。具体的实现代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSMutableArray</span>&lt;<span class="type">NSNumber</span> *&gt; *dashPattern = [<span class="type">NSMutableArray</span> arrayWithCapacity:<span class="number">2</span> * realTotalCount];</span><br><span class="line"><span class="type">NSInteger</span> needsMovePhaseCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; realTotalCount; i ++) &#123;</span><br><span class="line">   <span class="keyword">if</span> ([<span class="keyword">self</span>.showIndexes containsObject:@(i)]) &#123;</span><br><span class="line">       [dashPattern addObject:@(pieceLength)];</span><br><span class="line">       [dashPattern addObject:@(realDashGap)];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (dashPattern.<span class="built_in">count</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           dashPattern[dashPattern.<span class="built_in">count</span> - <span class="number">1</span>] = @(dashPattern[dashPattern.<span class="built_in">count</span> - <span class="number">1</span>].doubleValue + pieceLength + realDashGap);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">self</span>.lineDashPhase -= (pieceLength + realDashGap);</span><br><span class="line">           needsMovePhaseCount ++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (needsMovePhaseCount &gt; <span class="number">0</span> &amp;&amp; dashPattern.<span class="built_in">count</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">   dashPattern[dashPattern.<span class="built_in">count</span> - <span class="number">1</span>] = @(dashPattern[dashPattern.<span class="built_in">count</span> - <span class="number">1</span>].doubleValue + (pieceLength + realDashGap) * needsMovePhaseCount);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.showIndexes.<span class="built_in">count</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="keyword">self</span>.lineDashPattern = dashPattern;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一开始做这种需求我是拒绝的，交互有点复杂啊，用户看不懂啊，说白了还是不知道咋实现心里没底啊！然而要是没有这种需求，也就没有这篇月末大水文了。</p><p>我真是越来越水了，只会写 UI 了，还是搞底层的逆向大佬们牛逼啊！Hank 老师教教我！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;产品经理要求做个能展示进度的分段彩色外环，大概长这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yulingtianxia/YXYDashLayer/blob/master/Assets/YXYDashLayer.gif?raw=true&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;花了两天左右来实现和优化，记录下踩坑经历。&lt;/p&gt;
&lt;p&gt;组件已经开源，取个名字叫 &lt;code&gt;YXYDashLayer&lt;/code&gt; 吧：&lt;a href=&quot;https://github.com/yulingtianxia/YXYDashLayer&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/yulingtianxia/YXYDashLayer&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yulingtianxia.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>追踪 Objective-C 方法中的 Block 参数对象</title>
    <link href="http://yulingtianxia.com/blog/2018/03/31/Track-Block-Arguments-of-Objective-C-Method/"/>
    <id>http://yulingtianxia.com/blog/2018/03/31/Track-Block-Arguments-of-Objective-C-Method/</id>
    <published>2018-03-31T15:44:39.000Z</published>
    <updated>2019-08-11T14:22:22.513Z</updated>
    
    <content type="html"><![CDATA[<p>很多方法最后一个参数是类似于 <code>completionBlock</code> 这种回调，然而有些 API 实现一些异常逻辑时会忘记调用传入的 Block 参数（当然这肯定是 bug 啦），或者存在多次调用。在调试的时候可能会碰到这种大坑，需要追踪下 Block 参数何时调用了，甚至是否调用过。如果不方便直接在 Block 实现中加代码，或者没有源码的情况下，就需要无侵入式地追踪 Block 参数对象。</p><p><a href="https://github.com/yulingtianxia/BlockTracker" target="_blank" rel="noopener">BlockTracker</a> 可以追踪方法调用时传入的 Block 类型的参数的执行和销毁。基于 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 实现。本文讲述了它的使用方法和实现原理。</p><a id="more"></a><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>只需要调用 <code>bt_trackBlockArgOfSelector:callback:</code> 方法，就能在对应方法执行传入的 block 参数被调用和销毁的时候得到回调。回调中的内容包含了 <code>block</code> 对象，回调类型，<code>block</code> 已经执行的次数，执行 <code>block</code> 的参数、返回值，堆栈信息。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BTTracker *tracker = [<span class="keyword">self</span> bt_trackBlockArgOfSelector:<span class="keyword">@selector</span>(performBlock:) callback:^(<span class="keyword">id</span>  _Nullable block, BlockTrackerCallbackType type, <span class="built_in">NSInteger</span> invokeCount, <span class="keyword">void</span> * _Nullable * _Null_unspecified args, <span class="keyword">void</span> * _Nullable result, <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; * _Nonnull callStackSymbols) &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"%@ invoke count = %ld"</span>, BlockTrackerCallbackTypeInvoke == type ? <span class="string">@"BlockTrackerCallBackTypeInvoke"</span> : <span class="string">@"BlockTrackerCallBackTypeDead"</span>, (<span class="keyword">long</span>)invokeCount);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>当你不想追踪这个方法执行时传入的 block 参数时，也可以停止追踪：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[tracker stop]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>举个栗子，现在有个方法叫 <code>performBlock:</code>，只是简单地调用了 <code>block</code> 参数：</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">void</span>)performBlock:(<span class="built_in">void</span>(^)(<span class="built_in">void</span>))<span class="keyword">block</span> &#123;</span><br><span class="line">    <span class="keyword">block</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用两次这个方法，每次都传入不同的 block 实现：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__block NSString *word = @<span class="string">"I'm a block"</span><span class="comment">;</span></span><br><span class="line">[self performBlock:^&#123;</span><br><span class="line">   NSLog(@<span class="string">"add '!!!' to word"</span>)<span class="comment">;</span></span><br><span class="line">   word = [word stringByAppendingString:@<span class="string">"!!!"</span>]<span class="comment">;</span></span><br><span class="line">&#125;]<span class="comment">;</span></span><br><span class="line">[self performBlock:^&#123;</span><br><span class="line">   NSLog(@<span class="string">"%@"</span>, word)<span class="comment">;</span></span><br><span class="line">&#125;]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>因为执行两次方法传入的是两个不同的 block 对象，所以会追踪两个 block 对象的执行和销毁，打印的 log 如下：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add '!!!' to word</span><br><span class="line">BlockTrackerCallBackTypeInvoke<span class="built_in"> invoke </span>count = 1</span><br><span class="line">I'm a block!!!</span><br><span class="line">BlockTrackerCallBackTypeInvoke<span class="built_in"> invoke </span>count = 1</span><br><span class="line">BlockTrackerCallBackTypeDead<span class="built_in"> invoke </span>count = 1</span><br><span class="line">BlockTrackerCallBackTypeDead<span class="built_in"> invoke </span>count = 1</span><br></pre></td></tr></table></figure><p>在 block 对象销毁的时候<br>你可以尝试着把 <code>performBlock:</code> 的实现改成这样试试：</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">void</span>)performBlock:(<span class="built_in">void</span>(^)(<span class="built_in">void</span>))<span class="keyword">block</span> &#123;</span><br><span class="line">    <span class="keyword">block</span>();</span><br><span class="line">    <span class="keyword">block</span>();</span><br><span class="line">    <span class="keyword">block</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>原理很简单，就是 Hook 方法后再 Hook 下 Block，流程大致如下：</p><ol><li>利用 Objective-C Runtime 机制 Hook 某个方法，参考 <a href="https://github.com/yulingtianxia/MessageThrottle" target="_blank" rel="noopener">MessageThrottle</a> 的实现原理。</li><li>在方法真正执行前，使用 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 先 Hook 所有 Block 类型的参数。Hook 模式为 <code>BlockHookModeAfter</code> 和 <code>BlockHookModeDead</code>。</li><li>在 Block 执行后更新执行次数，并将相关信息回调给 Tracker。销毁后也会回调给 Tracker。</li></ol><p>流程大概很简单，复用以前代码。这里主要讲下 Track 的逻辑。</p><h3 id="过滤方法的-Block-参数"><a href="#过滤方法的-Block-参数" class="headerlink" title="过滤方法的 Block 参数"></a>过滤方法的 Block 参数</h3><p>在 <code>bt_trackBlockArgOfSelector:callback:</code> 里获取方法的 Type Encoding 后判断是否含有 Block 类型的参数，并将 Block 参数的 Index 保存到 <code>BTTracker</code> 的 <code>blockArgIndex</code> 属性。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (nullable <span class="keyword">BTTracker </span>*)<span class="keyword">bt_trackBlockArgOfSelector:(SEL)selector </span>callback:(<span class="keyword">BlockTrackerCallbackBlock)callback</span></span><br><span class="line"><span class="keyword">&#123;</span></span><br><span class="line"><span class="keyword"> </span>   Class cls = <span class="keyword">bt_classOfTarget(self);</span></span><br><span class="line"><span class="keyword"> </span>   </span><br><span class="line">    Method <span class="keyword">originMethod </span>= class_getInstanceMethod(cls, selector)<span class="comment">;</span></span><br><span class="line">    if (!<span class="keyword">originMethod) </span>&#123;</span><br><span class="line">        return nil<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    const char *<span class="keyword">originType </span>= (char *)method_getTypeEncoding(<span class="keyword">originMethod);</span></span><br><span class="line"><span class="keyword"> </span>   if (![[NSString stringWithUTF8String:<span class="keyword">originType] </span>containsString:@<span class="string">"@?"</span>]) &#123;</span><br><span class="line">        return nil<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    NSMutableArray *<span class="keyword">blockArgIndex </span>= [NSMutableArray array]<span class="comment">;</span></span><br><span class="line">    int argIndex = <span class="number">0</span><span class="comment">; // return type is the first one</span></span><br><span class="line">    while(<span class="keyword">originType </span>&amp;&amp; *<span class="keyword">originType)</span></span><br><span class="line"><span class="keyword"> </span>   &#123;</span><br><span class="line">        <span class="keyword">originType </span>= <span class="keyword">BHSizeAndAlignment(originType, </span>NULL, NULL, NULL)<span class="comment">;</span></span><br><span class="line">        if ([[NSString stringWithUTF8String:<span class="keyword">originType] </span>hasPrefix:@<span class="string">"@?"</span>]) &#123;</span><br><span class="line">            [<span class="keyword">blockArgIndex </span><span class="keyword">addObject:@(argIndex)];</span></span><br><span class="line"><span class="keyword"> </span>       &#125;</span><br><span class="line">        argIndex++<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">BTTracker </span>*tracker = <span class="keyword">BTEngine.defaultEngine.trackers[bt_methodDescription(self, </span>selector)]<span class="comment">;</span></span><br><span class="line">    if (!tracker) &#123;</span><br><span class="line">        tracker = [[<span class="keyword">BTTracker </span>alloc] initWithTarget:self selector:selector]<span class="comment">;</span></span><br><span class="line">        tracker.callback = callback<span class="comment">;</span></span><br><span class="line">        tracker.<span class="keyword">blockArgIndex </span>= [<span class="keyword">blockArgIndex </span>copy]<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    return [tracker apply] ? tracker : nil<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>bt_trackBlockArgOfSelector:callback:</code> 方法返回的 <code>BTTracker</code> 对象也保存了 <code>callback</code> 回调。</p><h3 id="执行-Callback"><a href="#执行-Callback" class="headerlink" title="执行 Callback"></a>执行 Callback</h3><p>遍历之前保存的 Block 参数 Index 列表 <code>blockArgIndex</code>，从 <code>NSInvocation</code> 中取到 Block 参数后，就可以 Hook 了。Block 的执行次数保存到了 <code>BHToken</code> 上，每次执行都会累加。在 Block 执行或销毁后都会调用 <code>callback</code>，只是传的参数稍有不同。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">NSNumber</span> *index <span class="keyword">in</span> tracker.blockArgIndex) &#123;</span><br><span class="line">   <span class="keyword">if</span> (index.integerValue &lt; invocation.methodSignature.numberOfArguments) &#123;</span><br><span class="line">       __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> block;</span><br><span class="line">       [invocation getArgument:&amp;block atIndex:index.integerValue];</span><br><span class="line">       __<span class="keyword">weak</span> <span class="keyword">typeof</span>(block) weakBlock = block;</span><br><span class="line">       __<span class="keyword">weak</span> <span class="keyword">typeof</span>(tracker) weakTracker = tracker;</span><br><span class="line">       BHToken *tokenAfter = [block block_hookWithMode:BlockHookModeAfter usingBlock:^(BHToken *token) &#123;</span><br><span class="line">           __<span class="keyword">strong</span> <span class="keyword">typeof</span>(weakBlock) strongBlock = weakBlock;</span><br><span class="line">           __<span class="keyword">strong</span> <span class="keyword">typeof</span>(weakTracker) strongTracker = weakTracker;</span><br><span class="line">           <span class="built_in">NSNumber</span> *invokeCount = objc_getAssociatedObject(token, <span class="built_in">NSSelectorFromString</span>(<span class="string">@"invokeCount"</span>));</span><br><span class="line">           <span class="keyword">if</span> (!invokeCount) &#123;</span><br><span class="line">               invokeCount = @(<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               invokeCount = [<span class="built_in">NSNumber</span> numberWithInt:invokeCount.intValue + <span class="number">1</span>];</span><br><span class="line">           &#125;</span><br><span class="line">           objc_setAssociatedObject(token, <span class="built_in">NSSelectorFromString</span>(<span class="string">@"invokeCount"</span>), invokeCount, OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">           <span class="keyword">if</span> (strongTracker.callback) &#123;</span><br><span class="line">               strongTracker.callback(strongBlock, BlockTrackerCallbackTypeInvoke, invokeCount.intValue, token.args, token.retValue, [<span class="built_in">NSThread</span> callStackSymbols]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;];</span><br><span class="line"></span><br><span class="line">       [block block_hookWithMode:BlockHookModeDead usingBlock:^(BHToken *token) &#123;</span><br><span class="line">           __<span class="keyword">strong</span> <span class="keyword">typeof</span>(weakTracker) strongTracker = weakTracker;</span><br><span class="line">           <span class="built_in">NSNumber</span> *invokeCount = objc_getAssociatedObject(tokenAfter, <span class="built_in">NSSelectorFromString</span>(<span class="string">@"invokeCount"</span>));</span><br><span class="line">           <span class="keyword">if</span> (strongTracker.callback) &#123;</span><br><span class="line">               strongTracker.callback(<span class="literal">nil</span>, BlockTrackerCallbackTypeDead, invokeCount.intValue, <span class="literal">nil</span>, <span class="literal">nil</span>, [<span class="built_in">NSThread</span> callStackSymbols]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对-NSInvocation-的一点探索"><a href="#对-NSInvocation-的一点探索" class="headerlink" title="对 NSInvocation 的一点探索"></a>对 NSInvocation 的一点探索</h3><p>在从 <code>NSInvocation</code> 对象获取参数时，需要先调用 <code>retainArguments</code> 方法让 <code>NSInvocation</code> 将 Block 参数 <code>copy</code>。因为有些 Block 参数类型是 <code>__NSStackBlock__</code>，需要拷贝到堆上，否则从 <code>NSInvocation</code> 获取的 Block 不会销毁。</p><p><code>getArgument:atIndex:</code> 方法只是将第 <code>index</code> 个参数指针的值拷贝到 <code>buffer</code> 中，而 <code>retainArguments</code> 才是真的对 C 字符串和 Block 拷贝。</p><p>我还为此做了个小实验。一个类外部声明并调用了 <code>test:</code> 方法，但其实内部实现的是 <code>foo:</code> 方法。通过实现 <code>methodSignatureForSelector:</code> 让消息转发流程走到 <code>forwardInvocation:</code> 方法中。然后向 Block 参数关联 <code>BTDealloc</code> 对象，在 <code>test:</code> 方法执行后，<code>BTDealloc</code> 类的 <code>dealloc</code> 方法并没有执行。也就是说通过 <code>NSInvocation</code> 获取的 Block 参数没销毁；如果先调用了 <code>retainArguments</code> 就会销毁。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">test:</span>(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))block;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">foo:</span> (<span class="keyword">void</span>(^)(<span class="keyword">void</span>)) block &#123;</span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)<span class="string">methodSignatureForSelector:</span>(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [NSMethodSignature <span class="string">signatureWithObjCTypes:</span><span class="string">"v@:@?"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">forwardInvocation:</span>(NSInvocation *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    [anInvocation retainArguments];</span></span><br><span class="line">    <span class="keyword">void</span> **invocationFrame = ((__bridge struct BTInvocaton *)anInvocation)-&gt;frame;</span><br><span class="line">    <span class="keyword">void</span> *blockFromFrame = invocationFrame[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">void</span> *block;</span><br><span class="line">    [anInvocation <span class="string">getArgument:</span>&amp;block <span class="string">atIndex:</span><span class="number">2</span>];</span><br><span class="line">    BTDealloc *btDealloc = [BTDealloc <span class="keyword">new</span>];</span><br><span class="line">    objc_setAssociatedObject((__bridge id)block, <span class="meta">@selector</span>(<span class="string">foo:</span>), btDealloc, OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">    anInvocation.selector = <span class="meta">@selector</span>(<span class="string">foo:</span>);</span><br><span class="line">    [anInvocation invoke];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过对 <code>NSInvocation</code> 对象的解析，我发现 <code>NSInvocation</code> 的参数存储于一个私有成员变量 <code>_frame</code> 中，试着将其强转为二级指针，也就是指针数组。拿到对应 index 的值 <code>blockFromFrame</code> 跟 <code>block</code> 作比较，发现是一样的。这里获取 <code>_frame</code> 需要强转下，<code>NSInvocation</code> 的内存模型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTInvocaton</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="keyword">void</span> *frame;</span><br><span class="line">    <span class="keyword">void</span> *retdata;</span><br><span class="line">    <span class="keyword">void</span> *signature;</span><br><span class="line">    <span class="keyword">void</span> *container;</span><br><span class="line">    <span class="keyword">uint8_t</span> retainedArgs;</span><br><span class="line">    <span class="keyword">uint8_t</span> reserved[<span class="number">15</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于 Hook Method 的逻辑是在消息转发流程搞事情，所以跟 Aspects 一样不能同时 Hook 父类和子类类相同方法。因为如果子类调用父类的实现，就会死循环。如果 Hook 方法这部分使用 <a href="http://yulingtianxia.com/blog/2017/04/17/Objective-C-Method-Swizzling/">Method Swizzling</a> 等交换 IMP 的方式实现，也会有着严重依赖 Hook 顺序导致调用错乱的问题。还是基于桥的 Hook 牛逼，汇编跳板，我这辈子是看不懂了。</p><p>老子终于在这个月最后一天快结束的时候憋出来一篇大水文！搬砖累死了没时间研究技术，你们尽管喷！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多方法最后一个参数是类似于 &lt;code&gt;completionBlock&lt;/code&gt; 这种回调，然而有些 API 实现一些异常逻辑时会忘记调用传入的 Block 参数（当然这肯定是 bug 啦），或者存在多次调用。在调试的时候可能会碰到这种大坑，需要追踪下 Block 参数何时调用了，甚至是否调用过。如果不方便直接在 Block 实现中加代码，或者没有源码的情况下，就需要无侵入式地追踪 Block 参数对象。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/yulingtianxia/BlockTracker&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BlockTracker&lt;/a&gt; 可以追踪方法调用时传入的 Block 类型的参数的执行和销毁。基于 &lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BlockHook&lt;/a&gt; 实现。本文讲述了它的使用方法和实现原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yulingtianxia.com/tags/Objective-C/"/>
    
      <category term="Runtime" scheme="http://yulingtianxia.com/tags/Runtime/"/>
    
      <category term="BlockHook" scheme="http://yulingtianxia.com/tags/BlockHook/"/>
    
  </entry>
  
  <entry>
    <title>Hook Objective-C Block with Libffi</title>
    <link href="http://yulingtianxia.com/blog/2018/02/28/Hook-Objective-C-Block-with-Libffi/"/>
    <id>http://yulingtianxia.com/blog/2018/02/28/Hook-Objective-C-Block-with-Libffi/</id>
    <published>2018-02-28T11:05:24.000Z</published>
    <updated>2019-08-11T14:21:54.329Z</updated>
    
    <content type="html"><![CDATA[<p>本文通过参照 <code>MABlockClosure</code> 的实现和 <code>Aspects</code> 的 API 设计，基于 libffi 实现了对 Objective-C Block 的 hook。GitHub 地址：<a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">https://github.com/yulingtianxia/BlockHook</a></p><p>什么场景下需要 hook block 呢？在有源码的情况下，大部分程序员会选择直接在 block 中插代码。假如方法 A 的入参是个 block 对象，方法 A 将 block 传给方法 B,C…等。如果只有方法 A 的源码，上层传入的 block 和下层方法实现都是黑盒的话，想追踪 block 调用的时机，打印些 log，就得 hook 这个 block 对象了。</p><a id="more"></a><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>虽然 Github 上已经给了例子，用过 Aspects 的人一看就懂，但为了凑篇幅，还是多 BB 几句吧。</p><p>API 虽然清奇，但是需要在 block 对象上用哦，在其他类型的对象上用是无效的！</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(BHToken *)</span>block_hookWithMode:<span class="params">(BlockHookMode)</span>mode</span><br><span class="line">                     usingBlock:<span class="params">(id)</span>block</span><br></pre></td></tr></table></figure><p>四种 hook 模式任你选择，可以对同一个 block 对象 hook 多次，但是要注意自己控制好顺序问题！hook 后会返回一个 <code>BHToken</code> 对象，可以调用它的 <code>remove</code> 方法来让 hook 失效。切记 <code>remove</code> 的时候要按照 hook 时的逆序！（以后可以搞个栈优化下用户体验，暂时懒的弄）</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"><span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class="line"><span class="built_in">NSObject</span> *z = <span class="built_in">NSObject</span>.new;</span><br><span class="line"><span class="keyword">int</span> (^block)(<span class="keyword">int</span>, <span class="keyword">int</span>) = ^(<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">   <span class="keyword">int</span> result = x + y;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"%d + %d = %d, z is a NSObject: %p"</span>, x, y, result, z);</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">BHToken *tokenInstead = [block block_hookWithMode:BlockHookModeInstead usingBlock:^(BHToken *token, <span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123;</span><br><span class="line">   [token invokeOriginalBlock];</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"let me see original result: %d"</span>, *(<span class="keyword">int</span> *)(token.retValue));</span><br><span class="line">   <span class="comment">// change the block imp and result</span></span><br><span class="line">   *(<span class="keyword">int</span> *)(token.retValue) = x * y;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"hook instead: '+' -&gt; '*'"</span>);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">BHToken *tokenAfter = [block block_hookWithMode:BlockHookModeAfter usingBlock:^(BHToken *token, <span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123;</span><br><span class="line">   <span class="comment">// print args and result</span></span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"hook after block! %d * %d = %d"</span>, x, y, *(<span class="keyword">int</span> *)(token.retValue));</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">BHToken *tokenBefore = [block block_hookWithMode:BlockHookModeBefore usingBlock:^(<span class="keyword">id</span> token)&#123;</span><br><span class="line">   <span class="comment">// BHToken has to be the first arg.</span></span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"hook before block! token:%@"</span>, token);</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">BHToken *tokenDead = [block block_hookWithMode:BlockHookModeDead usingBlock:^(<span class="keyword">id</span> token)&#123;</span><br><span class="line">   <span class="comment">// BHToken is the only arg.</span></span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"block dead! token:%@"</span>, token);</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"hooked block"</span>);</span><br><span class="line">   <span class="keyword">int</span> ret = block(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"hooked result:%d"</span>, ret);</span><br><span class="line">   <span class="comment">// remove all tokens when you don't need.</span></span><br><span class="line">   <span class="comment">// reversed order of hook.</span></span><br><span class="line">   [tokenBefore remove];</span><br><span class="line">   [tokenAfter remove];</span><br><span class="line">   [tokenInstead remove];</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"remove tokens, original block"</span>);</span><br><span class="line">   ret = block(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"original result:%d"</span>, ret);</span><br><span class="line"><span class="comment">//        [tokenDead remove];</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以通过设置 <code>BHToken</code> 的 <code>retValue</code> 属性来修改 block 的返回值。<code>usingBlock:</code> 的参数内容是自定义的，跟 Aspects 一样，用户自己填上对应的参数列表。完整参数列表的内容就是 <code>BHToken</code>（第一个参数）+ 原始 block 参数列表。看上面的例子应该很容易看懂。可以在 hook 的 block 中获取参数和修改返回值，打log，做些有(wei)趣(suo)的事情。</p><p>上面代码执行后的 log 结果如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hooked block</span><br><span class="line">hook before block! <span class="string">token:</span>&lt;<span class="string">BHToken:</span> <span class="number">0x1d00f0d80</span>&gt;</span><br><span class="line"><span class="number">3</span> + <span class="number">5</span> = <span class="number">8</span>, z is a <span class="string">NSObject:</span> <span class="number">0x1d00172b0</span></span><br><span class="line">let me see original <span class="string">result:</span> <span class="number">8</span></span><br><span class="line">hook <span class="string">instead:</span> <span class="string">'+'</span> -&gt; <span class="string">'*'</span></span><br><span class="line">hook after block! <span class="number">3</span> * <span class="number">5</span> = <span class="number">15</span></span><br><span class="line">hooked <span class="string">result:</span><span class="number">15</span></span><br><span class="line">remove tokens, original block</span><br><span class="line"><span class="number">3</span> + <span class="number">5</span> = <span class="number">8</span>, z is a <span class="string">NSObject:</span> <span class="number">0x1d00172b0</span></span><br><span class="line">original <span class="string">result:</span><span class="number">8</span></span><br><span class="line">block dead! <span class="string">token:</span>&lt;<span class="string">BHToken:</span> <span class="number">0x1d00f9900</span>&gt;</span><br></pre></td></tr></table></figure><p>老铁稳。</p><p>因为需要动态定义和运行函数，用到了 libffi，所以还需要引入对应架构的静态库，自己去官网下个编译好，在工程中引入 libffi.a 和包含头文件的 include 文件夹就行。示例程序 BlockHookSample 使用的是 arm64 架构。具体做法是在 Build Settings 中的 Other Link Flags 加入 libffi.a 的路径，在 Header Search Paths 加入 include 文件夹路径。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>先说下大致思路：</p><ol><li>根据 block 对象的签名，使用 <code>ffi_prep_cif</code> 构建 block-&gt;invoke 函数的模板 <code>cif</code></li><li>使用 <code>ffi_closure</code>，根据 cif 动态定义函数 <code>replacementInvoke</code>，并指定通用的实现函数为 <code>ClosureFunc</code></li><li>将 block-&gt;invoke 替换为 <code>replacementInvoke</code>，原始的 block-&gt;invoke 存放在 <code>originInvoke</code></li><li>在 <code>ClosureFunc</code> 中动态调用 <code>originInvoke</code> 函数和执行 hook 的逻辑。</li></ol><p>对 libffi 的介绍和用法有很多文章可以参考，这里不再赘述。</p><p>再整理下代码设计思路：</p><ul><li><code>BHToken</code>: 它实现了 hook 的逻辑，存储了相关的上下文。是最主要的类。</li><li><code>NSObject (BlockHook)</code>: 提供 hook 的接口，每次 hook block 对象都会创建一个 <code>BHToken</code>，并将其返回给用户。</li><li><code>BHCenter</code> 管理 <code>BHToken</code> 对象的中心，以后可以拓展更多玩法。</li></ul><p>下面列举下 <code>BHToken</code> 中几个比较重要的逻辑。</p><h3 id="通过-Block-创建函数模板"><a href="#通过-Block-创建函数模板" class="headerlink" title="通过 Block 创建函数模板"></a>通过 Block 创建函数模板</h3><p>有关 Objective-C Block 内存模型这里不再赘述，Block ABI 可以在 <a href="https://clang.llvm.org/docs/Block-ABI-Apple.html" target="_blank" rel="noopener">Clang 文档</a> 查到。根据 block 的 flag 位掩码计算偏移拿到 Type Encoding 签名 signature。<code>BHBlockTypeEncodeString()</code> 函数实现了这些逻辑，代码不贴了。一个 block 的签名格式是：[返回值类型和偏移][@?0][参数0类型和偏移][参数1类型和偏移]…，比如 arm64 下 <code>int (^block)(int, int)</code> 的签名是 <code>i16@?0i8i12</code>。block 指针占 8 字节，参数和返回值 <code>int</code> 都是 4 字节。</p><p>然后需要把 signature 字符串处理分拆成参数类型列表，在 libffi 中使用 <code>ffi_type</code> 表示各种类型。<code>_argsWithEncodeString:getCount:</code> 方法会根据 Type Encoding 规则，将 signature 逐个字符处理，可以获取 <code>ffi_type *</code> 参数（返回值）数组和参数个数。<code>_ffiArgForEncode:</code> 方法负责将 Type Encoding 字符映射到对应的 <code>ffi_type</code> 上，这是个很长的方法。</p><p>有了参数类型列表，返回值类型，参数个数后，就可以调用 <code>ffi_prep_cif()</code> 函数创建 <code>ffi_cif</code> 了，也就是函数模板。<code>_prepCIF:withEncodeString:</code> 方法实现了这个逻辑。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">int</span>)<span class="string">_prepCIF:</span>(ffi_cif *)cif <span class="string">withEncodeString:</span>(const <span class="keyword">char</span> *)str</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> argCount;</span><br><span class="line">    ffi_type **argTypes = [self <span class="string">_argsWithEncodeString:</span>str <span class="string">getCount:</span>&amp;argCount];</span><br><span class="line">    </span><br><span class="line">    ffi_status status = ffi_prep_cif(cif, FFI_DEFAULT_ABI, argCount, [self <span class="string">_ffiArgForEncode:</span> str], argTypes);</span><br><span class="line">    <span class="keyword">if</span>(status != FFI_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@<span class="string">"Got result %ld from ffi_prep_cif"</span>, (<span class="keyword">long</span>)status);</span><br><span class="line">        abort();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> argCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建闭包，替换-Block-的-invoke"><a href="#创建闭包，替换-Block-的-invoke" class="headerlink" title="创建闭包，替换 Block 的 invoke"></a>创建闭包，替换 Block 的 <code>invoke</code></h3><p>可以使用函数模板（<code>ffi_cif</code>）和一个函数指针（<code>replacementInvoke</code>）创建闭包(<code>ffi_closure</code>)。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_closure = ffi_closure_alloc(<span class="name">sizeof</span>(<span class="name">ffi_closure</span>), <span class="symbol">&amp;_replacementInvoke</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>当 <code>replacementInvoke()</code> 函数被调用时，绑定到闭包上的函数 <code>void BHFFIClosureFunc(ffi_cif *cif, void *ret, void **args, void *userdata)</code> 会被调用。传给 <code>replacementInvoke()</code> 的参数及其返回值都会被传给 <code>BHFFIClosureFunc()</code>。<code>ffi_prep_closure_loc</code> 函数的倒数第二个参数是 <code>user_data</code>，也会被传给 <code>BHFFIClosureFunc()</code> 方法。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)<span class="variable">_prepClosure</span></span><br><span class="line">&#123;</span><br><span class="line">    ffi_status status = ffi_prep_closure_loc(<span class="variable">_closure</span>, &amp;<span class="variable">_cif</span>, BHFFIClosureFunc, (<span class="variable">__bridge</span> void *)(self), <span class="variable">_replacementInvoke</span>);</span><br><span class="line">    <span class="keyword">if</span>(status != FFI_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@<span class="string">"ffi_prep_closure returned %d"</span>, (int)status);</span><br><span class="line">        abort();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// exchange invoke func imp</span></span><br><span class="line">    <span class="variable">_originInvoke</span> = ((<span class="variable">__bridge</span> struct <span class="variable">_BHBlock</span> *)self.block)-&gt;invoke;</span><br><span class="line">    ((<span class="variable">__bridge</span> struct <span class="variable">_BHBlock</span> *)self.block)-&gt;invoke = <span class="variable">_replacementInvoke</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将函数指针 <code>_replacementInvoke</code> 和函数模板 <code>_cif</code> 绑定函数闭包之后，需要将 block 的 <code>invoke</code> 替换成 <code>_replacementInvoke</code>，并把原始的实现存到 <code>_originInvoke</code>。<code>invoke</code> 函数的模板跟 block 的签名内容是一致的。</p><p>这样当 block 调用时，实际上会调用 <code>_replacementInvoke</code> 函数，进而调用 <code>BHFFIClosureFunc</code> 通用函数。在这里面会实现 hook 的逻辑。</p><p>还原 Hook 的 <code>remove</code> 逻辑也很简单，将 <code>_originInvoke</code> 恢复到 <code>invoke</code> 即可：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">((__bridge struct _BHBlock *)self.block)</span>-&gt;</span>invoke = _originInvoke;</span><br></pre></td></tr></table></figure><h3 id="实现通用-Hook-函数"><a href="#实现通用-Hook-函数" class="headerlink" title="实现通用 Hook 函数"></a>实现通用 Hook 函数</h3><p>所有被 hook 的 block 调用时都会走到 <code>BHFFIClosureFunc</code> 这里，可以拿到 block-&gt;invoke 的函数模板，返回值指针，参数列表。还有自定义的 <code>userdata</code>，传入的是 <code>BHToken</code> 对象。</p><p>使用 <code>ffi_call()</code> 动态调用 block 的原始实现 <code>_originInvoke</code>，并将参数列表和返回值指针传入。还需要传入函数模板，满足 Calling Convention。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static void BHFFIClosureFunc(ffi_cif *cif, void *<span class="keyword">ret</span>, void **<span class="keyword">args</span>, void *userdata)</span><br><span class="line">&#123;</span><br><span class="line">    BHToken *<span class="keyword">token</span> = (__bridge BHToken *)(userdata);</span><br><span class="line">    <span class="keyword">token</span>.retValue = <span class="keyword">ret</span>;</span><br><span class="line">    <span class="keyword">if</span> (BlockHookModeBefore == <span class="keyword">token</span>.mode) &#123;</span><br><span class="line">        [<span class="keyword">token</span> invokeHookBlockWithArgs:<span class="keyword">args</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(BlockHookModeInstead == <span class="keyword">token</span>.mode &amp;&amp; [<span class="keyword">token</span> invokeHookBlockWithArgs:<span class="keyword">args</span>])) &#123;</span><br><span class="line">        ffi_call(&amp;<span class="keyword">token</span>-&gt;_cif, <span class="keyword">token</span>-&gt;_originInvoke, <span class="keyword">ret</span>, <span class="keyword">args</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (BlockHookModeAfter == <span class="keyword">token</span>.mode) &#123;</span><br><span class="line">        [<span class="keyword">token</span> invokeHookBlockWithArgs:<span class="keyword">args</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 Hook mode，会在不同的时机调用 <code>invokeHookBlockWithArgs:</code> 方法执行 hook 的逻辑。</p><h3 id="组装-NSInvocation-执行-Hook-逻辑"><a href="#组装-NSInvocation-执行-Hook-逻辑" class="headerlink" title="组装 NSInvocation 执行 Hook 逻辑"></a>组装 <code>NSInvocation</code> 执行 Hook 逻辑</h3><p>Hook 逻辑实现在 <code>self.hookBlock</code> 中，被 Hook 的 block 是 <code>self.block</code>，分别获取两者的签名，并拷贝后者的参数传给前者构造的 <code>blockInvocation</code>。这里要注意 <code>self.hookBlock</code> 的参数比 <code>self.block</code> 多一个 <code>token</code>，所以在二者参数比对和传递时需要特殊处理下。最后执行 <code>blockInvocation</code>，即调用了 <code>usingBlock:</code> 的参数。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)invokeHookBlockWithArgs:(<span class="keyword">void</span> **)args</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.block || !<span class="keyword">self</span>.hookBlock) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *hookBlockSignature = [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:BHBlockTypeEncodeString(<span class="keyword">self</span>.hookBlock)];</span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *originalBlockSignature = [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:BHBlockTypeEncodeString(<span class="keyword">self</span>.block)];</span><br><span class="line">    <span class="built_in">NSInvocation</span> *blockInvocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:hookBlockSignature];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// origin block invoke func arguments: block(self), ...</span></span><br><span class="line">    <span class="comment">// hook block signature arguments: block(self), token, ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (hookBlockSignature.numberOfArguments &gt; <span class="keyword">self</span>.numberOfArguments + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Block has too many arguments. Not calling %@"</span>, <span class="keyword">self</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (hookBlockSignature.numberOfArguments &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        [blockInvocation setArgument:(<span class="keyword">void</span> *)&amp;<span class="keyword">self</span> atIndex:<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *argBuf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> idx = <span class="number">2</span>; idx &lt; hookBlockSignature.numberOfArguments; idx++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *type = [originalBlockSignature getArgumentTypeAtIndex:idx - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">NSUInteger</span> argSize;</span><br><span class="line">        <span class="built_in">NSGetSizeAndAlignment</span>(type, &amp;argSize, <span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!(argBuf = reallocf(argBuf, argSize))) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Failed to allocate memory for block invocation."</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        memcpy(argBuf, args[idx - <span class="number">1</span>], argSize);</span><br><span class="line">        [blockInvocation setArgument:argBuf atIndex:idx];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [blockInvocation invokeWithTarget:<span class="keyword">self</span>.hookBlock];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argBuf != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        free(argBuf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为用户传入的 <code>hookBlock</code> 签名是不确定的，所以需要针对参数数量判断临界条件。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>又是大水文一篇，总算是在月末憋出来了。因为只花了一天时间写代码，实在太仓促，肯定还有一堆 bug。目前不建议用到生产环境上，辅助 debug 还是可以的，以后会慢慢优化。也欢迎各位老铁们提 PR：<a href="https://github.com/yulingtianxia/BlockHook/pulls" target="_blank" rel="noopener">https://github.com/yulingtianxia/BlockHook/pulls</a></p><p>代码大量参考了 <a href="https://github.com/mikeash/MABlockClosure" target="_blank" rel="noopener">MABlockClosure</a> 的一些工具函数，API 设计上致敬 <a href="https://github.com/steipete/Aspects" target="_blank" rel="noopener">Aspects</a>。技术上如有疏漏，还请各位大佬们多多指教。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文通过参照 &lt;code&gt;MABlockClosure&lt;/code&gt; 的实现和 &lt;code&gt;Aspects&lt;/code&gt; 的 API 设计，基于 libffi 实现了对 Objective-C Block 的 hook。GitHub 地址：&lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/yulingtianxia/BlockHook&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;什么场景下需要 hook block 呢？在有源码的情况下，大部分程序员会选择直接在 block 中插代码。假如方法 A 的入参是个 block 对象，方法 A 将 block 传给方法 B,C…等。如果只有方法 A 的源码，上层传入的 block 和下层方法实现都是黑盒的话，想追踪 block 调用的时机，打印些 log，就得 hook 这个 block 对象了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yulingtianxia.com/tags/Objective-C/"/>
    
      <category term="BlockHook" scheme="http://yulingtianxia.com/tags/BlockHook/"/>
    
  </entry>
  
</feed>
