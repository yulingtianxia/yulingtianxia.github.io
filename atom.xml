<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yulingtianxia&#39;s blog</title>
  
  <subtitle>玉令天下的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yulingtianxia.com/"/>
  <updated>2020-05-30T09:58:02.173Z</updated>
  <id>http://yulingtianxia.com/</id>
  
  <author>
    <name>杨萧玉</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BlockHook and Memory Safety</title>
    <link href="http://yulingtianxia.com/blog/2020/05/30/BlockHook-and-Memory-Safety/"/>
    <id>http://yulingtianxia.com/blog/2020/05/30/BlockHook-and-Memory-Safety/</id>
    <published>2020-05-30T09:25:58.000Z</published>
    <updated>2020-05-30T09:58:02.173Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 最近修复了一些内存安全方面的问题，记录下这些问题的解决思路：</p><ol><li>微信项目使用 BlockHook 时的 MRC 兼容问题</li><li>GlobalBlock 在某些场景下的 VM Protection 没有写权限</li><li>如何检测带有 Private Data 的 block</li></ol><a id="more"></a><h2 id="修复-BlockHook-在-MRC-上的问题"><a href="#修复-BlockHook-在-MRC-上的问题" class="headerlink" title="修复 BlockHook 在 MRC 上的问题"></a>修复 BlockHook 在 MRC 上的问题</h2><p>ARC 下将 StackBlock 赋值时，会自动 copy 成 MallocBlock。不过这个编译器帮我们做的隐式行为的前提是代码里显示声明为 Block 类型。而 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 为了能够传入各种签名的 <code>aspectBlock</code>，恰恰用的是 <code>id</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> BHToken *)block_hookWithMode:(BlockHookMode)mode</span><br><span class="line">                              usingBlock:(<span class="keyword">id</span>)aspectBlock;</span><br></pre></td></tr></table></figure><p>如果调用方用的是 MRC，即便 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 是用 ARC 实现的，那么拿到的 <code>aspectBlock</code> 依然是 StackBlock。当被 Hook 的 Block 异步执行时，<code>aspectBlock</code> 也需要异步执行，但它早已经在栈上被释放，进而由于野指针而 crash。</p><p>这就是在微信项目里使用 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 时遇到的问题。当劳动节的下午我正出门去吃饭路上，微信的同事在企业微信上找到了我反馈了这个 bug。我由于路上匆忙没仔细看手机，一开始以为是我另一个同事找我。看问题截图上 Xcode 工程名我还以为他逆向调试微信用了 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 干啥坏事嘞，于是回了一句『你是真的牛逼』。再定神一看我擦是微信巨佬，虽然贼尴尬但只好装作没事一样继续看问题。。。扯远了。。。</p><p>微信巨佬果然是巨佬，还给了我解决方案。我照着巨佬给的思路，<code>copy</code> 了传入的 <code>aspectBlock</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If aspectBlock is a NSStackBlock and invoked asynchronously, it will cause a wild pointer. We copy it.</span></span><br><span class="line">_aspectBlock = [aspectBlock <span class="keyword">copy</span>];</span><br></pre></td></tr></table></figure><h2 id="解决-GlobalBlock-没有写权限的问题"><a href="#解决-GlobalBlock-没有写权限的问题" class="headerlink" title="解决 GlobalBlock 没有写权限的问题"></a>解决 GlobalBlock 没有写权限的问题</h2><p>用 Xcode 11 编译时，将 Deployment Info 中的 target 选择 iOS 13 后，GlobalBlock 对象所占的内存是只读的，这就导致 Hook 过程中无法对 <code>invoke</code> 函数指针做写操作，直接 crash。</p><p>首先需要判断下 <code>invoke</code> 指针对应的地址有没有写权限，如果没有写权限则需要提权。这涉及到 VM Region 和 Protection 的一些操作，在获取内存地址的基本信息时也要注意区分下 64 位和 32 位：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> vm_prot_t ProtectInvokeVMIfNeed(<span class="keyword">void</span> *address) &#123;</span><br><span class="line">    vm_address_t addr = (vm_address_t)address;</span><br><span class="line">    vm_size_t vmsize = <span class="number">0</span>;</span><br><span class="line">    mach_port_t object = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#if defined(__LP64__) &amp;&amp; __LP64__</span></span><br><span class="line">    vm_region_basic_info_data_64_t info;</span><br><span class="line">    mach_msg_type_number_t infoCnt = VM_REGION_BASIC_INFO_COUNT_64;</span><br><span class="line">    kern_return_t ret = vm_region_64(mach_task_self(), &amp;addr, &amp;vmsize, VM_REGION_BASIC_INFO, (vm_region_info_t)&amp;info, &amp;infoCnt, &amp;object);</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">    vm_region_basic_info_data_t info;</span><br><span class="line">    mach_msg_type_number_t infoCnt = VM_REGION_BASIC_INFO_COUNT;</span><br><span class="line">    kern_return_t ret = vm_region(mach_task_self(), &amp;addr, &amp;vmsize, VM_REGION_BASIC_INFO, (vm_region_info_t)&amp;info, &amp;infoCnt, &amp;object);</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="keyword">if</span> (ret != KERN_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"vm_region block invoke pointer failed! ret:%d, addr:%p"</span>, ret, address);</span><br><span class="line">        <span class="keyword">return</span> VM_PROT_NONE;</span><br><span class="line">    &#125;</span><br><span class="line">    vm_prot_t protection = info.protection;</span><br><span class="line">    <span class="keyword">if</span> ((protection&amp;VM_PROT_WRITE) == <span class="number">0</span>) &#123;</span><br><span class="line">        ret = vm_protect(mach_task_self(), (vm_address_t)address, <span class="keyword">sizeof</span>(address), <span class="literal">false</span>, protection|VM_PROT_WRITE);</span><br><span class="line">        <span class="keyword">if</span> (ret != KERN_SUCCESS) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"vm_protect block invoke pointer VM_PROT_WRITE failed! ret:%d, addr:%p"</span>, ret, address);</span><br><span class="line">            <span class="keyword">return</span> VM_PROT_NONE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> protection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在修改 <code>invoke</code> 指针后，还需要恢复原来的权限。相当于我只是在需要替换 <code>invoke</code> 指针的时候临时开了写权限：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">BOOL</span> ReplaceBlockInvoke(<span class="keyword">struct</span> _BHBlock *block, <span class="keyword">void</span> *replacement) &#123;</span><br><span class="line">    <span class="keyword">void</span> *address = &amp;(block-&gt;invoke);</span><br><span class="line">    vm_prot_t origProtection = ProtectInvokeVMIfNeed(address);</span><br><span class="line">    <span class="keyword">if</span> (origProtection == VM_PROT_NONE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    block-&gt;invoke = replacement;</span><br><span class="line">    <span class="keyword">if</span> ((origProtection&amp;VM_PROT_WRITE) == <span class="number">0</span>) &#123;</span><br><span class="line">        kern_return_t ret = vm_protect(mach_task_self(), (vm_address_t)address, <span class="keyword">sizeof</span>(address), <span class="literal">false</span>, origProtection);</span><br><span class="line">        <span class="keyword">if</span> (ret != KERN_SUCCESS) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"vm_protect block invoke pointer REVERT failed! ret:%d, addr:%p"</span>, ret, address);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然我还没花时间去追查苹果爸爸为啥要在 Xcode 11 上 iOS 13 target 编译时给 GlobalBlock 只读权限，但理论上我的这个操作并不是对非法内存地址的提权，应该是被允许的，毕竟线上检测是否越狱等功能也会用到这些 API。但我还是不放心，请教了页面仔大佬后，答复是可以上架，终于安心了，也期待下个版本可以试试。</p><p>如果有大佬知道苹果爸爸为何会这样做，或者有更优雅更安全的方案，请给小弟赐教，欢迎指出缺陷，一起开源共建。</p><h2 id="优化-BlockHook-检测-Private-Data-的方式"><a href="#优化-BlockHook-检测-Private-Data-的方式" class="headerlink" title="优化 BlockHook 检测 Private Data 的方式"></a>优化 BlockHook 检测 Private Data 的方式</h2><p>在 <a href="http://yulingtianxia.com/blog/2019/06/19/BlockHook-with-Private-Data/">BlockHook with Private Data</a> 这篇文章里我曾经介绍过一种『骨骼惊奇』的 Block，不能直接替换 <code>invoke</code> 函数指针来 Hook。当时判断这类带有 Private Data 的 Block 的依据是直接用 Private Data 中的 <code>dbpd_magic</code> 字段与 <code>DISPATCH_BLOCK_PRIVATE_DATA_MAGIC</code> 判等：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> dispatch_block_private_data_t</span><br><span class="line">bh_dispatch_block_get_private_data(<span class="keyword">struct</span> _BHBlock *block)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Keep in sync with _dispatch_block_create implementation</span></span><br><span class="line">    uint8_t *x = (uint8_t *)block;</span><br><span class="line">    <span class="comment">// x points to base of struct Block_layout</span></span><br><span class="line">    x += <span class="keyword">sizeof</span>(<span class="keyword">struct</span> _BHBlock);</span><br><span class="line">    <span class="comment">// x points to base of captured dispatch_block_private_data_s object</span></span><br><span class="line">    dispatch_block_private_data_t dbpd = (dispatch_block_private_data_t)x;</span><br><span class="line">    <span class="keyword">if</span> (dbpd-&gt;dbpd_magic != DISPATCH_BLOCK_PRIVATE_DATA_MAGIC) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dbpd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我知道这种暴力 Memory Overflow 的行为有潜在隐患，而且<a href="https://github.com/yulingtianxia/BlockHook/issues/11" target="_blank" rel="noopener">调试时开启了 Address Sanitizer 后会必现 crash</a>。当时这么做的原因我也在<a href="http://yulingtianxia.com/blog/2019/06/19/BlockHook-with-Private-Data/">文章</a>里写了，GCD 源码中会检查 Block 的 <code>invoke</code> 指针是否为 <code>_dispatch_block_special_invoke</code>，以此判断 Block 是否包含 Private Data。而这个标志位指针是私有的，我无法在没有符号表的场景下获取到。现在想想当时的自己真是个 SB，当初这么简单的问题，其实现在换个思路不就解决了：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> dispatch_block_private_data_t</span><br><span class="line">bh_dispatch_block_get_private_data(<span class="keyword">struct</span> _BHBlock *block) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!blockWithPrivateData) &#123;</span><br><span class="line">        blockWithPrivateData = dispatch_block_create(<span class="number">0</span>, ^&#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (block-&gt;invoke != ((__bridge <span class="keyword">struct</span> _BHBlock *)blockWithPrivateData)-&gt;invoke) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Keep in sync with _dispatch_block_create implementation</span></span><br><span class="line">    uint8_t *privateData = (uint8_t *)block;</span><br><span class="line">    <span class="comment">// privateData points to base of struct Block_layout</span></span><br><span class="line">    privateData += <span class="keyword">sizeof</span>(<span class="keyword">struct</span> _BHBlock);</span><br><span class="line">    <span class="comment">// privateData points to base of captured dispatch_block_private_data_s object</span></span><br><span class="line">    dispatch_block_private_data_t dbpd = (dispatch_block_private_data_t)privateData;</span><br><span class="line">    <span class="keyword">if</span> (dbpd-&gt;dbpd_magic != DISPATCH_BLOCK_PRIVATE_DATA_MAGIC) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dbpd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然无法直接拿到 <code>_dispatch_block_special_invoke</code> 指针，那我干脆创建一个带有 Private Data 的 Block 然后取它的 <code>invoke</code> 指针不就搞定了吗！现在看看当初的自己好傻啊。</p><h2 id="最后谈谈-BlockHook"><a href="#最后谈谈-BlockHook" class="headerlink" title="最后谈谈 BlockHook"></a>最后谈谈 BlockHook</h2><p>其实 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 的诞生纯属偶然，起初是我本想做些其他关于 Block 的事情，但技术太菜一直没搞成。一顿瞎折腾失败后，剩余的代码就是 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 的雏形。然后业余时间不断踩坑和填坑，收到用户反馈后不断打磨，最终搞出了个能用的版本。有时候兴趣带来的动力真的远超 KPI 的压力，让人干劲十足，哈哈。</p><p>我曾经吹牛说 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 『（应该是）填补了 Objective-C 业界在 Hook Block 技术领域的空白』，这件事也一直被五子棋嘲讽。后来他跟我说之前肯定有人做过这件事，不过记不清是哪个项目了。我也很想知道在这之前是否有人 Hook 过 Objective-C 的 Block，也跪求打脸并虚心接受。但我对 Hook 的理解并不是局限于替换个函数指针 IMP 就可以了，我个人觉得能配得上是 Hook/AOP 的框架，至少要满足下面几个要求中的大部分吧：</p><ol><li>用同一个 Hook 框架多次 Hook，能够有完整的 Hook 调用链。甚至能兼容其他框架。</li><li>兼容 90% 以上的使用场景，经得住大规模验证（不一定线上，也可以是作为测试工具）。</li><li>不能为了『轻量级』和高性能而去牺牲兼容性、鲁棒性和易用性，否则就是实现度不够。</li><li>支持 Revert Hook，最好能 Revert Hook 链的中间节点，甚至能完美还原现场。</li></ol><p>其实替换个函数指针并用 libffi 调用任意函数之类的事情随便找个人都会很快上手，如果就只做了这点事情我个人是不敢称其为 Hook/AOP 框架的。<a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 的大部分内容都是解决上面所列出的几点要求，并且自认为解决的还算不错。所以 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 是否填补了业界空白，就看大佬们如何看待 Hook 这件事情的定义了。PS: 可能会误伤一些人，千万别对号入座啊。我也曾经搞过『轻量级』的轮子，性能也牛逼，其实问题一堆实现度很低。我其实在吐槽我自己。。。</p><p>我本以为 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 打磨了这么久，应该没啥大问题了，然而还是不断有新的问题和挑战出现。毕竟自己曾经吹下了牛皮，含着泪也要继续打磨下去。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BlockHook&lt;/a&gt; 最近修复了一些内存安全方面的问题，记录下这些问题的解决思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;微信项目使用 BlockHook 时的 MRC 兼容问题&lt;/li&gt;
&lt;li&gt;GlobalBlock 在某些场景下的 VM Protection 没有写权限&lt;/li&gt;
&lt;li&gt;如何检测带有 Private Data 的 block&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yulingtianxia.com/tags/Objective-C/"/>
    
      <category term="Runtime" scheme="http://yulingtianxia.com/tags/Runtime/"/>
    
      <category term="BlockHook" scheme="http://yulingtianxia.com/tags/BlockHook/"/>
    
  </entry>
  
  <entry>
    <title>Passing Out Parameter in DartNative</title>
    <link href="http://yulingtianxia.com/blog/2020/04/25/Passing-Out-Parameter-in-DartNative/"/>
    <id>http://yulingtianxia.com/blog/2020/04/25/Passing-Out-Parameter-in-DartNative/</id>
    <published>2020-04-25T07:55:41.000Z</published>
    <updated>2020-04-25T10:25:10.170Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/dart-native/dart_native" target="_blank" rel="noopener">dart_native</a> 作为一条比 Channel 性能更高开发成本更低的超级通道，通过 C++ 调用 Native 的 API，深入底层且考虑全面。很多 Objective-C 接口含有 <code>NSError **</code> 这种 out parameter，<a href="https://github.com/dart-native/dart_native" target="_blank" rel="noopener">dart_native</a> 也对这种场景做了支持。</p><a id="more"></a><h2 id="封装-Objective-C-里的-Out-Parameter"><a href="#封装-Objective-C-里的-Out-Parameter" class="headerlink" title="封装 Objective-C 里的 Out Parameter"></a>封装 Objective-C 里的 Out Parameter</h2><p>说白了用的最多的就是 “A pointer to a pointer” 啊！<code>NSError **</code> 啊！</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line">[<span class="keyword">self</span> fooWithError:&amp;error];</span><br></pre></td></tr></table></figure><p>那换成 Dart 语言该咋表示呢？？？首先要知道 Dart 是不支持 out parameter 的，只能另辟蹊径，在语法上做一些妥协，最终跑通流程实现目的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSObjectRef&lt;NSObject&gt; ref = NSObjectRef&lt;NSObject&gt;();</span><br><span class="line">fooWithError(ref);</span><br></pre></td></tr></table></figure><p>还记得之前 <a href="https://github.com/dart-native/dart_native" target="_blank" rel="noopener">dart_native</a> 是如何封装 <code>NSObject *</code> 的么？用一个同名的 Dart 类包一个 OC 对象的指针就行了。那想封装 out parameter 的话，在此基础之上再套一层不就行了！只要用泛型，就能一层层套下去。。。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NSObjectRef</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">id</span>&gt; </span>&#123;</span><br><span class="line">  T value;</span><br><span class="line">  Pointer&lt;Pointer&lt;Void&gt;&gt; _ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着要考虑如何初始化 out parameter 了。在 OC 里只需要在栈上的一个地址就够了，也就是声明一个变量。但 Dart 的对象并没有对应指针的概念，但是可以通过 dart ffi 手动创建一个指向指针的指针。不过它指向的内存是在堆上，需要手动释放。此时可以通过<a href="http://yulingtianxia.com/blog/2020/01/31/DartNative-Memory-Management-Cpp-Non-Object/">我之前讲内存管理的文章</a>里讲到的 <code>PointerWrapper</code> 来实现临时指针变量的自动释放，简单来说就是把 dart ffi 创建的内存交给 OC ARC 管理。</p><p>加上构造方法和自动释放后的 <code>NSObjectRef</code> 实现如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NSObjectRef</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">id</span>&gt; </span>&#123;</span><br><span class="line">  T value;</span><br><span class="line">  Pointer&lt;Pointer&lt;Void&gt;&gt; _ptr;</span><br><span class="line">  Pointer&lt;Pointer&lt;Void&gt;&gt; <span class="keyword">get</span> pointer =&gt; _ptr;</span><br><span class="line"></span><br><span class="line">  NSObjectRef() &#123;</span><br><span class="line">    _ptr = allocate&lt;Pointer&lt;Void&gt;&gt;();</span><br><span class="line">    _ptr.value = nullptr;</span><br><span class="line">    PointerWrapper wrapper = PointerWrapper(_dealloc);</span><br><span class="line">    wrapper.value = _ptr.cast&lt;Void&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  NSObjectRef.fromPointer(<span class="keyword">this</span>._ptr);</span><br><span class="line">  </span><br><span class="line">  _dealloc() &#123;</span><br><span class="line">    _ptr = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从-Out-Parameter-取值"><a href="#从-Out-Parameter-取值" class="headerlink" title="从 Out Parameter 取值"></a>从 Out Parameter 取值</h2><p>Dart 侧把一个指针传给 OC 后，OC 会创建另一个指针，并把后者赋值给前者指向的内存。还是拿 <code>NSError</code> 举例子：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)fooWithError:(<span class="keyword">out</span> <span class="built_in">NSError</span> **)error &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@"com.dartnative.test"</span> code:<span class="number">-1</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一步是要将上例中 OC 的 <code>NSError</code> 对象转成 Dart 的对象，并赋值给 <code>NSObjectRef</code> 的 <code>value</code> 属性上。</p><h3 id="建立泛型与初始化的映射"><a href="#建立泛型与初始化的映射" class="headerlink" title="建立泛型与初始化的映射"></a>建立泛型与初始化的映射</h3><p>面对不同泛型的 <code>NSObjectRef</code> 声明，要转成其封装类型的对象。而 Flutter 禁用的 Dart 的反射，即不能通过 <code>NSObjectRef</code> 声明的泛型来初始化对应的类。我维护了个 <code>Map</code> 来建立起 <code>Type</code> 到初始化调用的映射，并提供注册方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">dynamic</span> ConvertorFromPointer(Pointer&lt;Void&gt; ptr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, ConvertorFromPointer&gt; _convertorCache = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> registerTypeConvertor(<span class="built_in">String</span> type, ConvertorFromPointer convertor) &#123;</span><br><span class="line">  <span class="keyword">if</span> (_convertorCache[type] == <span class="keyword">null</span>) &#123;</span><br><span class="line">    _convertorCache[type] = convertor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样调用 <code>registerTypeConvertor</code> 函数就可以很方便地建立起 Native 封装类型到初始化闭包的映射：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">registerTypeConvertor(<span class="string">'NSString'</span>, (ptr) &#123;</span><br><span class="line">    <span class="keyword">return</span> NSString.fromPointer(ptr);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>接着实现 <code>convertFromPointer</code> 函数，用来调用之前注册的闭包，这样就实现用类名和指针来获取到对应的 Dart 对象了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dynamic</span> convertFromPointer(String type, <span class="keyword">dynamic</span> arg) &#123;</span><br><span class="line">  Pointer&lt;<span class="built_in">Void</span>&gt; ptr;</span><br><span class="line">  <span class="keyword">if</span> (arg <span class="keyword">is</span> NSObject) &#123;</span><br><span class="line">    ptr = arg.pointer;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg <span class="keyword">is</span> Pointer) &#123;</span><br><span class="line">    ptr = arg;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ptr == nullptr) &#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ConvertorFromPointer convertor = _convertorCache[type];</span><br><span class="line">  <span class="keyword">if</span> (convertor != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> convertor(ptr);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg <span class="keyword">is</span> Pointer) &#123;</span><br><span class="line">    <span class="keyword">return</span> NSObject.fromPointer(arg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在 <code>NSObjectRef</code> 里添加了个 <code>syncValue</code> 方法，将转换好的 Dart 对象赋值给 <code>value</code> 属性：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">syncValue() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_ptr != <span class="keyword">null</span> &amp;&amp; _ptr.value != nullptr) &#123;</span><br><span class="line">        value = convertFromPointer(T.toString(), _ptr.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自动生成注册代码"><a href="#自动生成注册代码" class="headerlink" title="自动生成注册代码"></a>自动生成注册代码</h3><p>那么多 Native 类型，总不能手写代码一个个去调用 <code>registerTypeConvertor</code> 吧。<a href="https://github.com/dart-native/dart_native" target="_blank" rel="noopener">dart_native</a> 提供了 Annotation 用于自动生成这些注册代码，只需要在封装 Native 类的上面加一个 <code>@native</code> 即可：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@native</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NSString</span> <span class="keyword">extends</span> <span class="title">NSSubclass</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">  NSString.fromPointer(Pointer&lt;Void&gt; ptr) : <span class="keyword">super</span>.fromPointer(ptr) &#123;</span><br><span class="line">    value = perform(SEL(<span class="string">'UTF8String'</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样只需要在项目目录里运行下面的命令，所有加了 <code>@native</code> 的类都会在同一个 dart 文件中生成注册初始化闭包的代码：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter packages pub <span class="built_in">run</span> build_runner build <span class="comment">--delete-conflicting-outputs</span></span><br></pre></td></tr></table></figure><p>建议在运行上面的 <code>build</code> 之前先 <code>clean</code> 下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter packages pub <span class="keyword">run</span><span class="bash"> build_runner clean</span></span><br></pre></td></tr></table></figure><p>这是 <a href="https://github.com/dart-native/dart_native" target="_blank" rel="noopener">dart_native</a> 里带的一份自动生成的文件 ``：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GENERATED CODE - DO NOT MODIFY BY HAND</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// **************************************************************************</span></span><br><span class="line"><span class="comment">// DartNativeGenerator</span></span><br><span class="line"><span class="comment">// **************************************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:dart_native/dart_native.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:dart_native/src/ios/foundation/collection/nsarray.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:dart_native/src/ios/foundation/collection/nsdictionary.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:dart_native/src/ios/foundation/collection/nsset.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:dart_native/src/ios/foundation/nsvalue.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:dart_native/src/ios/foundation/nsnumber.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:dart_native/src/ios/foundation/notification.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:dart_native/src/ios/foundation/nsstring.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runDartNative</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  registerTypeConvertor(<span class="string">'NSArray'</span>, (ptr) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> NSArray.<span class="title">fromPointer</span><span class="params">(ptr)</span></span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  registerTypeConvertor(<span class="string">'NSDictionary'</span>, (ptr) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> NSDictionary.<span class="title">fromPointer</span><span class="params">(ptr)</span></span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  registerTypeConvertor(<span class="string">'NSSet'</span>, (ptr) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> NSSet.<span class="title">fromPointer</span><span class="params">(ptr)</span></span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  registerTypeConvertor(<span class="string">'NSValue'</span>, (ptr) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> NSValue.<span class="title">fromPointer</span><span class="params">(ptr)</span></span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  registerTypeConvertor(<span class="string">'NSNumber'</span>, (ptr) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> NSNumber.<span class="title">fromPointer</span><span class="params">(ptr)</span></span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  registerTypeConvertor(<span class="string">'NSNotification'</span>, (ptr) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> NSNotification.<span class="title">fromPointer</span><span class="params">(ptr)</span></span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  registerTypeConvertor(<span class="string">'NSString'</span>, (ptr) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> NSString.<span class="title">fromPointer</span><span class="params">(ptr)</span></span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到 Flutter 的 plugin 和 App 都可能会用到 <a href="https://github.com/dart-native/dart_native" target="_blank" rel="noopener">dart_native</a>，那么各自的 Native 类就都要生成对应的注册代码。所以这里的入口函数名是根据 package 名生成的，不用担心重名问题。</p><p>利用 Annotation 自动生成代码的实现原理就不细说了，网上文章很多，可以参考闲鱼的 <a href="https://github.com/alibaba-flutter/annotation_route" target="_blank" rel="noopener">annotation_route</a>。我只是做了一点微小的优化工作，可能以后也不会单开一片文章来讲。</p><p>PS: 自动生成代码这块一开始是给 callback 功能用的，这里写下，只是蹭了蹭篇幅。</p><h3 id="自动取值"><a href="#自动取值" class="headerlink" title="自动取值"></a>自动取值</h3><p><code>syncValue()</code> 方法实现后就比较简单了，下一步就只是找个合理的时机调用的问题了。这只需要在 <a href="https://github.com/dart-native/dart_native" target="_blank" rel="noopener">dart_native</a> 的 <code>msgSend</code> 方法中加入对参数类型的判断。如果是 <code>NSObjectRef</code> 类型，则需要在调用完 Native 侧的方法后再次调用它的 <code>syncValue()</code> 方法。</p><p>这里仅截取一段相关的实现代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略部分逻辑</span></span><br><span class="line">List&lt;NSObjectRef&gt; outRefArgs = [];</span><br><span class="line"><span class="comment">// 省略部分逻辑</span></span><br><span class="line"><span class="keyword">if</span> (args != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 省略部分逻辑</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; argCount; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> arg = args[i];</span><br><span class="line">      <span class="keyword">if</span> (arg == <span class="literal">null</span>) &#123;</span><br><span class="line">        arg = nil;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg <span class="keyword">is</span> NSObjectRef) &#123;</span><br><span class="line">        outRefArgs.<span class="keyword">add</span>(arg);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 省略部分逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">outRefArgs.forEach((<span class="keyword">ref</span>) =&gt; <span class="keyword">ref</span>.syncValue());</span><br></pre></td></tr></table></figure><p><a href="https://github.com/dart-native/dart_native" target="_blank" rel="noopener">dart_native</a> 中的<code>msgSend</code> 方法顾名思义，虽然表面上是复刻 OC 的实现，实则接口和原理差很多。这里也不详细展开讲，感兴趣的可以直接去看代码。</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p><code>NSObjectRef</code> 目前只考虑了对 <code>NSObject</code> 及其子类的 out parameter 的封装，理论上对其他基本类型和结构体也是可以支持的，不过使用场景可能没 <code>NSError **</code> 那么多，等遇到的时候再搞吧。</p><p>内行看门道，外行看热闹。我这么简单的内容都能水出一篇文章，跪求大佬们轻喷，不嘲笑就好。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/dart-native/dart_native&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;dart_native&lt;/a&gt; 作为一条比 Channel 性能更高开发成本更低的超级通道，通过 C++ 调用 Native 的 API，深入底层且考虑全面。很多 Objective-C 接口含有 &lt;code&gt;NSError **&lt;/code&gt; 这种 out parameter，&lt;a href=&quot;https://github.com/dart-native/dart_native&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;dart_native&lt;/a&gt; 也对这种场景做了支持。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yulingtianxia.com/tags/Objective-C/"/>
    
      <category term="Dart" scheme="http://yulingtianxia.com/tags/Dart/"/>
    
      <category term="Flutter" scheme="http://yulingtianxia.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>在 Flutter 中玩转 Objective-C Block</title>
    <link href="http://yulingtianxia.com/blog/2020/03/28/Using-Objective-C-Block-in-Flutter/"/>
    <id>http://yulingtianxia.com/blog/2020/03/28/Using-Objective-C-Block-in-Flutter/</id>
    <published>2020-03-28T07:57:55.000Z</published>
    <updated>2020-04-25T08:32:02.934Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/dart-native/dart_native" target="_blank" rel="noopener">dart_native</a> 作为一条比 Channel 性能更高开发成本更低的超级通道，通过 C++ 调用 Native 的 API，深入底层且考虑全面。很多 Objective-C 接口的参数和返回值是 Block，所以这就需要支持用 Dart 语言创建和调用 Objective-C Block。</p><a id="more"></a><h2 id="Dart-调用-Objective-C-带-Block-的-API"><a href="#Dart-调用-Objective-C-带-Block-的-API" class="headerlink" title="Dart 调用 Objective-C 带 Block 的 API"></a>Dart 调用 Objective-C 带 Block 的 API</h2><p>Dart 语言支持协程，这样就无需传递闭包来作为异步调用的回调。而 Objective-C 大量 API 都使用 Block 作为回调，当 Dart 调用这类异步 API 的时候，就需要 Dart 侧创建 Block 并传递给 Objective-C。</p><p>Dart 语言中的 Function 可以当做闭包，可以实现下面这样的效果：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stub.fooBlock((NSObject a) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'hello block! <span class="subst">$&#123;a.toString()&#125;</span>'</span>);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>而对应的 Objective-C 接口如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSObject</span> *(^BarBlock)(<span class="built_in">NSObject</span> *a);</span><br><span class="line">- (<span class="keyword">void</span>)fooBlock:(BarBlock)block;</span><br></pre></td></tr></table></figure><p>下面就讲下 <a href="https://github.com/dart-native/dart_native" target="_blank" rel="noopener">dart_native</a> 是如何做到把 Dart Function 当做 Block 传给 Objective-C 的。</p><h3 id="函数签名"><a href="#函数签名" class="headerlink" title="函数签名"></a>函数签名</h3><p>首先要确保的是 Dart Function 的签名跟 Objective-C Block 是一致的，这样二者才能转换。在 Dart 里一切皆为对象，Function 也不例外。那么拿到 Function 的 <code>runtimeType</code> 即可，然后解析其内容。不过 <code>runtimeType</code> 的内容都是 Dart 类名，如何能与 Objective-C 类型对应上呢？<a href="https://github.com/dart-native/dart_native" target="_blank" rel="noopener">dart_native</a> 的策略是提供与 Native 同名的类，这样使用这些同名类定义 Dart Function，就可以把函数签名映射到 Native 上了。</p><p>列举一些 Dart 声明的基础类型：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unsigned_char</span> = <span class="title">char</span> <span class="title">with</span> <span class="title">_ToAlias</span>;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">short</span> = <span class="title">NativeBox</span>&lt;<span class="title">int</span>&gt; <span class="title">with</span> <span class="title">_ToAlias</span>;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">unsigned_short</span> = <span class="title">NativeBox</span>&lt;<span class="title">int</span>&gt; <span class="title">with</span> <span class="title">_ToAlias</span>;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">unsigned_int</span> = <span class="title">NativeBox</span>&lt;<span class="title">int</span>&gt; <span class="title">with</span> <span class="title">_ToAlias</span>;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">long</span> = <span class="title">NativeBox</span>&lt;<span class="title">int</span>&gt; <span class="title">with</span> <span class="title">_ToAlias</span>;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">unsigned_long</span> = <span class="title">NativeBox</span>&lt;<span class="title">int</span>&gt; <span class="title">with</span> <span class="title">_ToAlias</span>;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">long_long</span> = <span class="title">NativeBox</span>&lt;<span class="title">int</span>&gt; <span class="title">with</span> <span class="title">_ToAlias</span>;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">unsigned_long_long</span> = <span class="title">NativeBox</span>&lt;<span class="title">int</span>&gt; <span class="title">with</span> <span class="title">_ToAlias</span>;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">size_t</span> = <span class="title">NativeBox</span>&lt;<span class="title">int</span>&gt; <span class="title">with</span> <span class="title">_ToAlias</span>;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">NSInteger</span> = <span class="title">NativeBox</span>&lt;<span class="title">int</span>&gt; <span class="title">with</span> <span class="title">_ToAlias</span>;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">NSUInteger</span> = <span class="title">NativeBox</span>&lt;<span class="title">int</span>&gt; <span class="title">with</span> <span class="title">_ToAlias</span>;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">float</span> = <span class="title">NativeBox</span>&lt;<span class="title">double</span>&gt; <span class="title">with</span> <span class="title">_ToAlias</span>;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">CGFloat</span> = <span class="title">NativeBox</span>&lt;<span class="title">double</span>&gt; <span class="title">with</span> <span class="title">_ToAlias</span>;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">CString</span> = <span class="title">NativeBox</span>&lt;<span class="title">String</span>&gt; <span class="title">with</span> <span class="title">_ToAlias</span>;</span></span><br></pre></td></tr></table></figure><h3 id="动态创建-Block"><a href="#动态创建-Block" class="headerlink" title="动态创建 Block"></a>动态创建 Block</h3><p>有了函数签名，如何构造对应的 Block 对象呢？首先要知道 Block 是什么，而这是就又个老生常谈的话题了。我十分建议你先了解下 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 及其相关文章，这样会对理解这部分内容有很大帮助。</p><p>废话不多说，上硬核：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)initBlock &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *typeString = <span class="keyword">self</span>.typeString.UTF8String;</span><br><span class="line">    int32_t flags = (BLOCK_HAS_COPY_DISPOSE | BLOCK_HAS_SIGNATURE);</span><br><span class="line">    <span class="comment">// Struct return value on x86(32&amp;64) MUST be put into pointer.(On heap)</span></span><br><span class="line">    <span class="keyword">if</span> (typeString[<span class="number">0</span>] == <span class="string">'&#123;'</span> &amp;&amp; (TARGET_CPU_X86 || TARGET_CPU_X86_64)) &#123;</span><br><span class="line">        flags |= BLOCK_HAS_STRET;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Check block encoding types valid.</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> numberOfArguments = [<span class="keyword">self</span> _prepCIF:&amp;_cif withEncodeString:typeString flags:flags];</span><br><span class="line">    <span class="keyword">if</span> (numberOfArguments == <span class="number">-1</span>) &#123; <span class="comment">// Unknown encode.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.numberOfArguments = numberOfArguments;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.hasStret) &#123;</span><br><span class="line">        <span class="keyword">self</span>.numberOfArguments--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _closure = ffi_closure_alloc(<span class="keyword">sizeof</span>(ffi_closure), (<span class="keyword">void</span> **)&amp;_blockIMP);</span><br><span class="line">    </span><br><span class="line">    ffi_status status = ffi_prep_closure_loc(_closure, &amp;_cif, DNFFIBlockClosureFunc, (__bridge <span class="keyword">void</span> *)(<span class="keyword">self</span>), _blockIMP);</span><br><span class="line">    <span class="keyword">if</span> (status != FFI_OK) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"ffi_prep_closure returned %d"</span>, (<span class="keyword">int</span>)status);</span><br><span class="line">        abort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> _DNBlockDescriptor descriptor = &#123;</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="keyword">sizeof</span>(<span class="keyword">struct</span> _DNBlock),</span><br><span class="line">        (<span class="keyword">void</span> (*)(<span class="keyword">void</span> *dst, <span class="keyword">const</span> <span class="keyword">void</span> *src))copy_helper,</span><br><span class="line">        (<span class="keyword">void</span> (*)(<span class="keyword">const</span> <span class="keyword">void</span> *src))dispose_helper,</span><br><span class="line">        typeString</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    _descriptor = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> _DNBlockDescriptor));</span><br><span class="line">    memcpy(_descriptor, &amp;descriptor, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> _DNBlockDescriptor));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> _DNBlock simulateBlock = &#123;</span><br><span class="line">        &amp;_NSConcreteStackBlock,</span><br><span class="line">        flags,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        _blockIMP,</span><br><span class="line">        _descriptor,</span><br><span class="line">        (__bridge <span class="keyword">void</span>*)<span class="keyword">self</span></span><br><span class="line">    &#125;;</span><br><span class="line">    _signature = [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:typeString];</span><br><span class="line">    _block = (__bridge <span class="keyword">id</span>)Block_copy(&amp;simulateBlock);</span><br><span class="line">    SEL selector = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"autorelease"</span>);</span><br><span class="line">    <span class="meta">#pragma clang diagnostic push</span></span><br><span class="line">    <span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Warc-performSelector-leaks"</span></span></span><br><span class="line">    _block = [_block performSelector:selector];</span><br><span class="line">    <span class="meta">#pragma clang diagnostic pop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来说，动态创建 Block 的流程封装在了一个 Wrapper 类中，步骤如下：</p><ol><li>用 libffi 动态创建相同签名的函数，</li><li>准备好创建 Block 需要的 <code>flag</code>、<code>description</code>、<code>signature</code> 和 <code>wrapper</code> 对象等</li><li>根据 Block 的内存模型创建对应的结构体（栈上）</li><li>把 Block 对象 <code>copy</code> 到堆上，并发送 <code>autorelease</code> 消息</li></ol><p>这上面每一步其实都不简单，单独拆出来都能写一段。但因为 <a href="http://blog.cnbang.net/tech/3332/" target="_blank" rel="noopener">bang 大佬已经写过文章</a>介绍过了，我这里就不再赘述了。我只是站在巨人的肩膀上，增加了一些改进和对 Dart 的适配（如支持结构体、<code>x86</code> 兼容等）。很惭愧，就做了一点微小的工作。</p><h3 id="映射-Block-和-Dart-Function"><a href="#映射-Block-和-Dart-Function" class="headerlink" title="映射 Block 和 Dart Function"></a>映射 Block 和 Dart Function</h3><p>Block 对象创建好了，需要跟 Dart Function 映射起来，然后当 Block 被执行的时候才会调用到对应的 Dart 逻辑。</p><p>关于回调这块，我在 Dart 侧维护一个 <code>Map</code> 来管理 Native 到 Dart 的回调映射。基本思路是，Key 为 Native 对象的地址，Value 为 Dart 侧的 Block 类。</p><p>Dart 版的 <code>Block</code> 类构造方法里会将映射建立起来：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">factory</span> Block(<span class="built_in">Function</span> function) &#123;</span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; dartTypes = _dartTypeStringForFunction(function);</span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; nativeTypes = _nativeTypeStringForDart(dartTypes);</span><br><span class="line">    Pointer&lt;Utf8&gt; typeStringPtr = Utf8.toUtf8(nativeTypes.join(<span class="string">', '</span>));</span><br><span class="line">    NSObject blockWrapper =</span><br><span class="line">        NSObject.fromPointer(blockCreate(typeStringPtr, _callbackPtr));</span><br><span class="line">    <span class="built_in">int</span> blockAddr = blockWrapper.perform(SEL(<span class="string">'blockAddress'</span>));</span><br><span class="line">    Block result = Block._internal(Pointer.fromAddress(blockAddr));</span><br><span class="line">    free(typeStringPtr);</span><br><span class="line">    result.types = dartTypes;</span><br><span class="line">    result._wrapper = blockWrapper;</span><br><span class="line">    result.function = function;</span><br><span class="line">    _blockForAddress[result.pointer.address] = result;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Block</code> 类的 <code>dealloc</code> 方法里会移除映射，防止造成 Dart 版的『野指针』。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dealloc() &#123;</span><br><span class="line">    _wrapper = <span class="keyword">null</span>;</span><br><span class="line">    _blockForAddress.remove(pointer.address);</span><br><span class="line">    <span class="keyword">super</span>.dealloc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dart-调用-Objective-C-返回的-Block"><a href="#Dart-调用-Objective-C-返回的-Block" class="headerlink" title="Dart 调用 Objective-C 返回的 Block"></a>Dart 调用 Objective-C 返回的 Block</h2><p>结合对 Block 的理解以及实践过 Dart 调用 OC 方法的经验，很容易在 Dart 版的 <code>Block</code> 中实现个 <code>invoke</code> 方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dynamic</span> invoke([<span class="built_in">List</span> args]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pointer == nullptr) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Pointer&lt;Utf8&gt; typesEncodingsPtr = _blockTypeEncodeString(pointer);</span><br><span class="line">    Pointer&lt;Int32&gt; countPtr = allocate&lt;Int32&gt;();</span><br><span class="line">    Pointer&lt;Pointer&lt;Utf8&gt;&gt; typesPtrPtr =</span><br><span class="line">        nativeTypesEncoding(typesEncodingsPtr, countPtr, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">int</span> count = countPtr.value;</span><br><span class="line">    free(countPtr);</span><br><span class="line">    <span class="comment">// typesPtrPtr contains return type and block itself.</span></span><br><span class="line">    <span class="keyword">if</span> (count != (args?.length ?? <span class="number">0</span>) + <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">'Args Count NOT match'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Pointer&lt;Pointer&lt;Void&gt;&gt; argsPtrPtr = nullptr.cast();</span><br><span class="line">    <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">      argsPtrPtr = allocate&lt;Pointer&lt;Void&gt;&gt;(count: args.length);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> arg = args[i];</span><br><span class="line">        <span class="keyword">if</span> (arg == <span class="keyword">null</span>) &#123;</span><br><span class="line">          arg = nil;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">String</span> encoding = Utf8.fromUtf8(typesPtrPtr.elementAt(i + <span class="number">2</span>).value);</span><br><span class="line">        storeValueToPointer(arg, argsPtrPtr.elementAt(i), encoding);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Pointer&lt;Void&gt; resultPtr = blockInvoke(pointer, argsPtrPtr);</span><br><span class="line">    <span class="keyword">if</span> (argsPtrPtr != nullptr.cast()) &#123;</span><br><span class="line">      free(argsPtrPtr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">String</span> encoding = Utf8.fromUtf8(typesPtrPtr.elementAt(<span class="number">0</span>).value);</span><br><span class="line">    <span class="keyword">dynamic</span> result = loadValueFromPointer(resultPtr, encoding);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来说上面的实现做了如下几步：</p><ol><li>获取 Block 的函数签名</li><li>校验 Dart 测传入的参数列表是否符合函数签名</li><li>将 Dart 参数转为 Native 对应的类型，写入堆中</li><li>调用 C 函数 <code>blockInvoke</code>，将 Block 指针和参数列表二级指针传过去</li><li>释放二级指针（其指向的对象类型和堆上的结构体会自动释放）</li><li>将 <code>blockInvoke</code> 返回的指针内容转为 Dart 对象</li></ol><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>关于 Block 这块其实还有很多技术细节没有叙述完整，包括 <code>copy</code> 方法的实现，回调映射的细节，类型自动转换的细节等。因为篇幅原因，感兴趣的可以直接看源码：<a href="https://github.com/dart-native/dart_native" target="_blank" rel="noopener">https://github.com/dart-native/dart_native</a></p><p>其实我期望的是使用 Dart 的协程来完成处理异步回调，这样更现代更优雅。日后会基于此方案再次封装上层接口，支持协程。</p><p><a href="https://github.com/dart-native/dart_native" target="_blank" rel="noopener">dart_native</a> 作为一条深入底层且考虑全面的 Dart 到 Native 超级通道，未来还要做的事情还有很多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/dart-native/dart_native&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;dart_native&lt;/a&gt; 作为一条比 Channel 性能更高开发成本更低的超级通道，通过 C++ 调用 Native 的 API，深入底层且考虑全面。很多 Objective-C 接口的参数和返回值是 Block，所以这就需要支持用 Dart 语言创建和调用 Objective-C Block。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yulingtianxia.com/tags/Objective-C/"/>
    
      <category term="Dart" scheme="http://yulingtianxia.com/tags/Dart/"/>
    
      <category term="Flutter" scheme="http://yulingtianxia.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>DartNative Struct</title>
    <link href="http://yulingtianxia.com/blog/2020/02/24/DartNative-Struct/"/>
    <id>http://yulingtianxia.com/blog/2020/02/24/DartNative-Struct/</id>
    <published>2020-02-23T16:15:12.000Z</published>
    <updated>2020-02-23T16:19:49.864Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/dart-native/dart_native" target="_blank" rel="noopener">dart_native</a> 基于 Dart FFI，通过 C++ 调用 Native 的 API。很多 Objective-C 接口的参数和返回值都有 Struct，比如最常见的 <code>CGSize</code> 等。这就需要能够用 Dart 语言表示 Struct 类型，尤其是 Cocoa 内建的这些常用结构体。</p><a id="more"></a><p>结构体的存储需要一段连续的内存，可以是栈也可以是堆上。而 Dart 与 Objective-C 跨语言调用时只能传递一个指针大小的数据，这就使得 <a href="https://github.com/dart-native/dart_native" target="_blank" rel="noopener">DartNative</a> 的结构体需要在堆上创建，并通过指针传递。</p><p>Dart FFI 虽然提供了构建结构体的 API，但是目前还不支持<a href="https://github.com/dart-lang/sdk/issues/37271" target="_blank" rel="noopener">结构体的嵌套</a>，所以像 <code>CGRect</code> 包含 <code>CGPoint</code> 和 <code>CGSize</code> 这种结构，还不能通过嵌套的方式复用实现代码。此外，<code>CGFloat</code> 和 <code>NSUInteger</code> 也可能有 32bit 和 64bit 两种情况，Dart 只能在运行时去区分该用哪种。这些原因导致目前使用 Dart FFI 构建 Struct 时不得不采用排列组合式的笨方法。</p><p>下面就以实现一个 <code>CGSize</code> 为例，看看这种方式有多笨。</p><p>首先 <code>CGSize</code> 是由两个 <code>CGFloat</code> 组成，而 <code>CGFloat</code> 又有可能是 32bit 或 64bit。所以现需要分别实现这两种情况，也就是 <code>CGFloat32x2</code> 和 <code>CGFloat64x2</code>，分别表示两个 <code>float</code> 和两个 <code>double</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CGFloat32x2</span> <span class="keyword">extends</span> <span class="title">Struct</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Float</span>()</span><br><span class="line">  <span class="built_in">double</span> a;</span><br><span class="line">  <span class="meta">@Float</span>()</span><br><span class="line">  <span class="built_in">double</span> b;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> CGFloat32x2(<span class="built_in">double</span> a, <span class="built_in">double</span> b) =&gt; allocate&lt;CGFloat32x2&gt;().ref</span><br><span class="line">    ..a = a</span><br><span class="line">    ..b = b;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> CGFloat32x2.fromPointer(Pointer&lt;CGFloat32x2&gt; ptr) &#123;</span><br><span class="line">    <span class="keyword">return</span> ptr.ref;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CGFloat64x2</span> <span class="keyword">extends</span> <span class="title">Struct</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Double</span>()</span><br><span class="line">  <span class="built_in">double</span> a;</span><br><span class="line">  <span class="meta">@Double</span>()</span><br><span class="line">  <span class="built_in">double</span> b;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> CGFloat64x2(<span class="built_in">double</span> a, <span class="built_in">double</span> b) =&gt; allocate&lt;CGFloat64x2&gt;().ref</span><br><span class="line">    ..a = a</span><br><span class="line">    ..b = b;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> CGFloat64x2.fromPointer(Pointer&lt;CGFloat64x2&gt; ptr) &#123;</span><br><span class="line">    <span class="keyword">return</span> ptr.ref;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CGFloat64x2</code> 初始化时会在堆上开辟内存，并填充数据。而使用 <code>fromPointer</code> 类方法初始化时则是传入一个指针，并将指针指向的内存按照内存模型映射到 Dart 这边的属性。而从 Native 那边传过来的指针肯定也是指向由 <a href="https://github.com/dart-native/dart_native" target="_blank" rel="noopener">DartNative</a> 开辟的内存，所以使用这两种初始化方法后，<a href="https://github.com/dart-native/dart_native" target="_blank" rel="noopener">DartNative</a> 都需要负责释放内存。</p><p>我也很想把这一长串代码合并下，可惜目前 Dart FFI 的语法还很弱，Dart 的类型安全编译检查也使得一些事情做不了。考虑到 Flutter 禁用了反射，所以只能按部就班写一坨一坨长得很像但又不完全一样的代码了。</p><p>基于两种情况之上再封装一层 <code>CGFloatx2Wrapper</code>，内部判断该用哪种。由于 Dart 不支持宏，无法在编译器静态判断是否是 64bit，所以封装了个 <code>LP64</code> 在运行时判断。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CGFloatx2Wrapper</span> <span class="keyword">extends</span> <span class="title">NativeStruct</span> </span>&#123;</span><br><span class="line">  CGFloat32x2 _value32;</span><br><span class="line">  CGFloat64x2 _value64;</span><br><span class="line"></span><br><span class="line">  CGFloatx2Wrapper(<span class="built_in">double</span> a, <span class="built_in">double</span> b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (LP64) &#123;</span><br><span class="line">      _value64 = CGFloat64x2(a, b);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      _value32 = CGFloat32x2(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    wrapper;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Pointer <span class="keyword">get</span> addressOf =&gt; LP64 ? _value64.addressOf : _value32.addressOf;</span><br><span class="line"></span><br><span class="line">  CGFloatx2Wrapper.fromPointer(Pointer&lt;Void&gt; ptr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (LP64) &#123;</span><br><span class="line">      _value64 = CGFloat64x2.fromPointer(ptr.cast());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      _value32 = CGFloat32x2.fromPointer(ptr.cast());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CGFloatx2Wrapper</code> 继承了 <code>NativeStruct</code>，后者内部维护了一个 <code>PointerWrapper</code> 来实现 Struct 堆内存的自动释放。<code>PointerWrapper</code> 本质上只是包装了下指针，并在自己释放的时候 <code>free</code> 指针指向的内存。<code>NativeStruct</code> 提供 <code>retain</code> 和 <code>release</code> 方法，并在释放时回调 <code>dealloc</code> 接口，使得 Struct 在 Dart 上可以像对象类型一样使用。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NativeStruct</span> </span>&#123;</span><br><span class="line">  Pointer <span class="keyword">get</span> addressOf;</span><br><span class="line"></span><br><span class="line">  PointerWrapper _wrapper;</span><br><span class="line">  PointerWrapper <span class="keyword">get</span> wrapper &#123;</span><br><span class="line">    <span class="keyword">if</span> (_wrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">      _wrapper = PointerWrapper(dealloc);</span><br><span class="line">    &#125;</span><br><span class="line">    Pointer&lt;Void&gt; result = addressOf.cast&lt;Void&gt;();</span><br><span class="line">    _wrapper.value = result;</span><br><span class="line">    <span class="keyword">return</span> _wrapper;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  NativeStruct retain() &#123;</span><br><span class="line">    wrapper.retain();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  release() =&gt; wrapper.release();</span><br><span class="line"></span><br><span class="line">  dealloc() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续回到 <code>CGFloatx2Wrapper</code>，这层封装内部维护两个属性 <code>a</code> 和 <code>b</code> 及其存取方法，只是简单的透传而已:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span> <span class="keyword">get</span> a =&gt; LP64 ? _value64.a : _value32.a;</span><br><span class="line"><span class="keyword">set</span> a(<span class="built_in">double</span> a) &#123;</span><br><span class="line">  <span class="keyword">if</span> (LP64) &#123;</span><br><span class="line">    _value64.a = a;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    _value32.a = a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">double</span> <span class="keyword">get</span> b =&gt; LP64 ? _value64.b : _value32.b;</span><br><span class="line"><span class="keyword">set</span> b(<span class="built_in">double</span> b) &#123;</span><br><span class="line">  <span class="keyword">if</span> (LP64) &#123;</span><br><span class="line">    _value64.b = b;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    _value32.b = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CGFloatx2Wrapper</code> 也通过重写操作符实现了 Struct 判等的功能，这样就不需要使用 Objective-C 里繁琐的 <code>CGSizeEqualToSize</code> 等函数了：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> <span class="keyword">operator</span> ==(other) &#123;</span><br><span class="line">  <span class="keyword">if</span> (other == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">return</span> a == other.a &amp;&amp; b == other.b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="built_in">int</span> <span class="keyword">get</span> hashCode =&gt; a.hashCode ^ b.hashCode;</span><br></pre></td></tr></table></figure><p>真不敢相信如此难堪的代码出自我之手，只能说各位大佬们有懂 Dart 的可以指点下小弟有没有更优雅的方式。最后基于这个 <code>CGFloatx2Wrapper</code> 就可以封装出 <code>CGSize</code>,<code>CGPoint</code>,<code>CGVector</code> 和 <code>UIOffset</code> 等 Struct 了，它们均由两个 <code>CGFloat</code> 组成。也就只有这一步复用代码了。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CGSize</span> <span class="keyword">extends</span> <span class="title">CGFloatx2Wrapper</span> </span>&#123;</span><br><span class="line">  <span class="built_in">double</span> <span class="keyword">get</span> width =&gt; a;</span><br><span class="line">  <span class="keyword">set</span> width(<span class="built_in">double</span> width) &#123;</span><br><span class="line">    a = width;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">double</span> <span class="keyword">get</span> height =&gt; b;</span><br><span class="line">  <span class="keyword">set</span> height(<span class="built_in">double</span> height) &#123;</span><br><span class="line">    b = height;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  CGSize(<span class="built_in">double</span> width, <span class="built_in">double</span> height) : <span class="keyword">super</span>(width, height);</span><br><span class="line">  CGSize.fromPointer(Pointer&lt;Void&gt; ptr) : <span class="keyword">super</span>.fromPointer(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有其他类型需要封装，比如 <code>CGRect</code> 由 4 个 <code>CGFloat</code> 组成，且由于 Dart FFI 不支持 Struct 嵌套，所以无法复用 <code>CGPoint</code> 和 <code>CGSize</code> 这两个类的代码，只能重复上面的过程重起炉灶。就这样最终将 Objective-C Cocoa API 内建的 Struct 基本都包装成了 Dart 里的类。目前支持的类型有：<code>CGSize</code>,<code>CGPoint</code>,<code>CGVector</code>,<code>CGRect</code>,<code>NSRange</code>,<code>UIOffset</code>,<code>UIEdgeInsets</code>,<code>NSDirectionalEdgeInsets</code> 和 <code>CGAffineTransform</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/dart-native/dart_native&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;dart_native&lt;/a&gt; 基于 Dart FFI，通过 C++ 调用 Native 的 API。很多 Objective-C 接口的参数和返回值都有 Struct，比如最常见的 &lt;code&gt;CGSize&lt;/code&gt; 等。这就需要能够用 Dart 语言表示 Struct 类型，尤其是 Cocoa 内建的这些常用结构体。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Dart" scheme="http://yulingtianxia.com/tags/Dart/"/>
    
      <category term="Flutter" scheme="http://yulingtianxia.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>DartNative Memory Management: C++ Non-Object</title>
    <link href="http://yulingtianxia.com/blog/2020/01/31/DartNative-Memory-Management-Cpp-Non-Object/"/>
    <id>http://yulingtianxia.com/blog/2020/01/31/DartNative-Memory-Management-Cpp-Non-Object/</id>
    <published>2020-01-31T15:12:26.000Z</published>
    <updated>2020-01-31T15:13:44.191Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/dart-native/dart_native" target="_blank" rel="noopener">dart_native</a> 基于 Dart FFI，通过 C++ 调用 Native 的 API。这种跨多语言的 bridge 就需要考虑到内存管理的问题。<a href="http://yulingtianxia.com/blog/2019/12/26/DartObjC-Memory-Management-Object/">上一篇文章</a> 介绍了 Objective-C 对象类型的管理，本篇算是它的续篇，讲下对 <code>struct</code> 和 <code>char *</code> 内存的管理。</p><a id="more"></a><p>如果你还不了解 <a href="https://github.com/dart-native/dart_native" target="_blank" rel="noopener">dart_native</a> 是什么，建议先看下我之前的两篇文章：</p><ul><li><a href="http://yulingtianxia.com/blog/2019/10/27/Write-Objective-C-Code-using-Dart/">用 Dart 来写 Objective-C 代码</a></li><li><a href="http://yulingtianxia.com/blog/2019/11/28/DartObjC-Design/">谈谈 dart_native 混合编程引擎的设计</a></li><li><a href="http://yulingtianxia.com/blog/2019/12/26/DartObjC-Memory-Management-Object/">DartNative Memory Management: NSObject</a></li></ul><p>PS：dart_objc 已经更名为 dart_native。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>Cocoa(Touch) 中的好多 API 都用到了系统内建的 <code>struct</code> 或 <code>UTF8String</code>(<code>char *</code>) 类型，它们不像 Objective-C 对象那样只存在于堆上（Block 除外），既可以存在堆上也可以在栈上。<strong>如果能将 <code>struct</code> 和 <code>char *</code> 用对象的形式包一层</strong>，那么就可以<strong>将堆上非对象类型的生命周期转换为对象类型，交由 ARC 来管理</strong>。由此继续借助<a href="http://yulingtianxia.com/blog/2019/12/26/DartObjC-Memory-Management-Object/">上一篇文章</a>的经验和流程，自动释放存储在堆上的 <code>struct</code> 和 <code>char *</code> 类型。</p><h2 id="何时销毁非对象类型"><a href="#何时销毁非对象类型" class="headerlink" title="何时销毁非对象类型"></a>何时销毁非对象类型</h2><p>首先要确定非对象类型传递的方式。这里的解决方案是全都存储于堆上，并用一个 Wrapper 对象包一层来传递。下面说说为何这么做。</p><p>非对象类型如果存储在栈上，那么当调用结束返回后就会被销毁。在跨语言异步调用时，栈上的内存也会被回收，Dart 侧无法长期持有并访问这些数据。Objective-C 大多使用 Block 的方式来实现异步调用逻辑，由于 Block 会去捕获外部变量，所以可以正常运行。</p><p>这个 <code>PointerWrapper</code> 类也很简单，它包了个 <code>void *pointer</code> 属性，在析构的时候会释放 <code>pointer</code> 指向的内存：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">free</span>(_pointer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以把一个非对象类型先 copy 到堆上，然后封装成对象类型来传递了。确保其不会过早被释放，且在同步或异步调用完成后由 ARC 自动释放。</p><h2 id="Dart-从-C-获取非对象类型"><a href="#Dart-从-C-获取非对象类型" class="headerlink" title="Dart 从 C++ 获取非对象类型"></a>Dart 从 C++ 获取非对象类型</h2><p>这里分两种情况：</p><ol><li>Dart 创建新的 <code>struct</code> 或 <code>char *</code>（<code>Pointer&lt;Utf8&gt;</code>）。会通过 Dart FFI 的 <code>allocate</code> 在堆上开辟新的内存，<strong>需要释放</strong>。</li><li>Dart 调用 C++ 函数或 Objective-C Block 时获取的返回值。<code>struct</code> 会被拷贝到新创建的堆内存上，<strong>需要释放</strong>；<code>char *</code> 会自动转换成 <code>String</code>，<strong>不需要释放</strong>。</li><li>C++ 调用 Dart callback 时传入的参数。<code>struct</code> 会被拷贝到新创建的堆内存上，<strong>需要释放</strong>；<code>char *</code> 会自动转换成 <code>String</code>，<strong>不需要释放</strong>。</li></ol><p>至于如何在 Dart 侧创建诸如 <code>CGRect</code> 之类的 <code>struct</code>，可能又能单开一篇文章来讲了，这里不细说了。Dart 侧并不会直接从 Objective-C/C++ 侧拿到 <code>struct</code> 类型，而是拿到一份 <code>malloc</code> 并拷贝后的指针。</p><p>上面这些需要释放的 <code>struct</code> 均可以通过 <code>PointerWrapper</code> 来自动释放，也就是默认创建的是临时变量，用完会自动销毁。Dart 的 <code>struct</code> 都以 <code>NativeStruct</code> 作为基类。其中 <code>addressOf</code> 为指向 <code>struct</code> 的指针，<code>wrapper</code> 接管了 <code>struct</code> 的生命周期。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NativeStruct</span> </span>&#123;</span><br><span class="line">  Pointer <span class="keyword">get</span> addressOf;</span><br><span class="line"></span><br><span class="line">  PointerWrapper _wrapper;</span><br><span class="line">  PointerWrapper <span class="keyword">get</span> wrapper &#123;</span><br><span class="line">    <span class="keyword">if</span> (_wrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">      _wrapper = PointerWrapper();</span><br><span class="line">    &#125;</span><br><span class="line">    Pointer&lt;<span class="built_in">Void</span>&gt; result = addressOf.cast&lt;<span class="built_in">Void</span>&gt;();</span><br><span class="line">    _wrapper.value = result;</span><br><span class="line">    <span class="keyword">return</span> _wrapper;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  NativeStruct retain() &#123;</span><br><span class="line">    wrapper.retain();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  release() =&gt; wrapper.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是 Dart 获取到的 <code>struct</code> 是个临时变量，不用就会自动销毁。如果需要长期持有，则需要手动 <code>retain</code> 和 <code>release</code>。而 Dart 获取到的 <code>char *</code> 则会被自动转为 <code>String</code> 类型，无需关心内存管理。</p><h2 id="C-从-Dart-获取非对象类型"><a href="#C-从-Dart-获取非对象类型" class="headerlink" title="C++ 从 Dart 获取非对象类型"></a>C++ 从 Dart 获取非对象类型</h2><p>这里分两种情况：</p><ol><li>Dart 调用 C++ 函数或 Objective-C Block 时传入的参数。</li><li>Objective-C 调用 Dart callback 时获取的返回值。</li></ol><p>Dart 侧的 <code>struct</code> 早已由 <code>PointerWrapper</code> 交给 ARC 来接管生命周期，<strong>在调用完成后自动释放</strong>。不过需要注意的一点是，Dart 的 <code>String</code> 自动转换为 C++ 的 <code>char *</code>（<code>Pointer&lt;Utf8&gt;</code>）时属于新创建 <code>char *</code>，<strong>需要交给 <code>PointerWrapper</code> 自动释放</strong>:</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">dynamic</span> <span class="title">storeCStringToPointer</span>(<span class="params"><span class="keyword">dynamic</span> <span class="keyword">object</span>, Pointer&lt;Pointer&lt;Void&gt;&gt; ptr</span>)</span> &#123;</span><br><span class="line">  Pointer&lt;Utf8&gt; charPtr = Utf8.toUtf8(<span class="keyword">object</span>);</span><br><span class="line">  PointerWrapper wrapper = PointerWrapper();</span><br><span class="line">  wrapper.<span class="keyword">value</span> = charPtr.cast&lt;Void&gt;();</span><br><span class="line">  ptr.cast&lt;Pointer&lt;Utf8&gt;&gt;().<span class="keyword">value</span> = charPtr;</span><br><span class="line">  <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dart-向-C-传参"><a href="#Dart-向-C-传参" class="headerlink" title="Dart 向 C++ 传参"></a>Dart 向 C++ 传参</h3><ol><li>由于字符串比较特殊，即便在函数调用结束后，字符串很多以常量的形式被继续使用。所以传递 <code>char *</code> 的时候，即便已经通过传递 <code>PointerWrapper</code> 来保证调用过程中不被释放，但还需要利用 <code>NSTaggedPointerString</code> 将其生命周期交给 Foundation 管理。</li><li>原本传递结构体现在改成了传递结构体的指针。因为跨语言调用时，使用 Dart FFI 传递单个数据最大为 64bit，可以为整型、浮点型或指针等。所以可能无法容纳下比较大的结构体，需要传递指向结构体的指针。</li><li>其余类型照常传递。</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_fillArgsToInvocation(<span class="built_in">NSMethodSignature</span> *signature, <span class="keyword">void</span> **args, <span class="built_in">NSInvocation</span> *invocation, <span class="built_in">NSUInteger</span> offset) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = offset; i &lt; signature.numberOfArguments; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *argType = [signature getArgumentTypeAtIndex:i];</span><br><span class="line">        <span class="built_in">NSUInteger</span> argsIndex = i - offset;</span><br><span class="line">        <span class="keyword">if</span> (argType[<span class="number">0</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">            <span class="comment">// Copy CString to NSTaggedPointerString and transfer it's lifecycle to ARC. Orginal pointer will be freed after function returning.</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *temp = [<span class="built_in">NSString</span> stringWithUTF8String:(<span class="keyword">const</span> <span class="keyword">char</span> *)args[argsIndex]].UTF8String;</span><br><span class="line">            <span class="keyword">if</span> (temp) &#123;</span><br><span class="line">                args[argsIndex] = (<span class="keyword">void</span> *)temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (argType[<span class="number">0</span>] == <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">            <span class="comment">// Already put struct in pointer on Dart side.</span></span><br><span class="line">            [invocation setArgument:args[argsIndex] atIndex:i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            [invocation setArgument:&amp;args[argsIndex] atIndex:i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Objective-C-调用-Dart-callback-时获取的返回值"><a href="#Objective-C-调用-Dart-callback-时获取的返回值" class="headerlink" title="Objective-C 调用 Dart callback 时获取的返回值"></a>Objective-C 调用 Dart callback 时获取的返回值</h3><p>由于 Dart callback 所对应的 C++ Function 由 libffi 动态创建，而基于动态创建的 C++ Function 又动态创建了 Objective-C Block 和方法。所以这一切都是我们创建的，尽在掌控之中。而这个动态创建的过程又有点复杂，可以再单独开一篇文章来讲了。</p><p>Objective-C 中方法和 Block 的返回值如果是比较大的 <code>struct</code>，运行在 x86 架构上时，实际上调用更底层函数时的参数列表会有变化。此时第一个参数是指向返回结构体的指针，其余参数依次后移一位。这在 Objective-C 中缩写为 stret，也就是 struct return 的意思。</p><p>如果没有触发 <code>stret</code> 条件，此时的策略是 Dart callback 返回非对象类型锁对应的 <code>PointerWrapper</code>，然后 Objective-C 侧再从 <code>wrapper</code> 中取出对非对象类型，并塞入到 libffi 提供的 <code>ret</code> 指针里：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (wrapper.hasStret) &#123;</span><br><span class="line">    <span class="comment">// synchronize stret value from first argument.</span></span><br><span class="line">    [invocation setReturnValue:*(<span class="keyword">void</span> **)args[<span class="number">0</span>]];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ([wrapper.typeString hasPrefix:<span class="string">@"&#123;"</span>]) &#123;</span><br><span class="line">    DOPointerWrapper *pointerWrapper = *(DOPointerWrapper *__<span class="keyword">strong</span> *)ret;</span><br><span class="line">    memcpy(ret, pointerWrapper.pointer, invocation.methodSignature.methodReturnLength);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ([wrapper.typeString hasPrefix:<span class="string">@"*"</span>]) &#123;</span><br><span class="line">    DOPointerWrapper *pointerWrapper = *(DOPointerWrapper *__<span class="keyword">strong</span> *)ret;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *origCString = (<span class="keyword">const</span> <span class="keyword">char</span> *)pointerWrapper.pointer;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *temp = [<span class="built_in">NSString</span> stringWithUTF8String:origCString].UTF8String;</span><br><span class="line">    *(<span class="keyword">const</span> <span class="keyword">char</span> **)ret = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>非对象类型的内存管理要比对象类型复杂得多，光是把 <code>struct</code> 在 Dart 中转换出来就已经有些麻烦了。好在大部分问题都已经克服过去了，最终实现了一套半自动化的内存管理系统，也实现了跨语言的类型自动转换。后续可能还会对 stret 的情况进行优化，甚至对方案进行大改。</p><p>哎真是太难了，我还是继续骑着小摩托去找人马吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/dart-native/dart_native&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;dart_native&lt;/a&gt; 基于 Dart FFI，通过 C++ 调用 Native 的 API。这种跨多语言的 bridge 就需要考虑到内存管理的问题。&lt;a href=&quot;http://yulingtianxia.com/blog/2019/12/26/DartObjC-Memory-Management-Object/&quot;&gt;上一篇文章&lt;/a&gt; 介绍了 Objective-C 对象类型的管理，本篇算是它的续篇，讲下对 &lt;code&gt;struct&lt;/code&gt; 和 &lt;code&gt;char *&lt;/code&gt; 内存的管理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Dart" scheme="http://yulingtianxia.com/tags/Dart/"/>
    
      <category term="Flutter" scheme="http://yulingtianxia.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>DartNative Memory Management: NSObject</title>
    <link href="http://yulingtianxia.com/blog/2019/12/26/DartObjC-Memory-Management-Object/"/>
    <id>http://yulingtianxia.com/blog/2019/12/26/DartObjC-Memory-Management-Object/</id>
    <published>2019-12-26T04:49:13.000Z</published>
    <updated>2020-01-30T09:08:00.840Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/dart-native/dart_native" target="_blank" rel="noopener">dart_native</a> 基于 Dart FFI，通过 C++ 调用 Native 的 API。这种跨多语言的 bridge 就需要考虑到内存管理的问题。由于篇幅有限，会分开来讲，本篇文章只涉及 Objective-C 对象类型的管理。</p><a id="more"></a><p>如果你还不了解 <a href="https://github.com/dart-native/dart_native" target="_blank" rel="noopener">dart_native</a> 是什么，建议先看下我之前的两篇文章：</p><ul><li><a href="http://yulingtianxia.com/blog/2019/10/27/Write-Objective-C-Code-using-Dart/">用 Dart 来写 Objective-C 代码</a></li><li><a href="http://yulingtianxia.com/blog/2019/11/28/DartObjC-Design/">谈谈 dart_native 混合编程引擎的设计</a></li></ul><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>先看看不同语言是如何管理内存与对象的生命周期的。</p><ul><li>Dart VM 使用 GC 来管理内存，且 Dart 语言一切皆为对象。</li><li>C++ 在堆上手动开辟的内存需要手动释放。</li><li>Objective-C 上的对象普遍使用 ARC 来管理，但也可以使用 MRC。其余跟 C++ 一样。</li></ul><p>GC 和引用计数都是常见的内存管理方式，这里就不科普具体算法的细节了。两者差别固然很大，<a href="https://github.com/dart-native/dart_native" target="_blank" rel="noopener">dart_native</a> 在这里做了一些事情，尽量让开发者写 Dart 时少关心内存问题。</p><p>由于 Dart 对象的生命周期实际完全由 VM 的 GC 决定，所以这里没有可操作性的空间，只能调整 Objective-C 对象的生命周期。Objective-C 对象都是存储在堆上的，跨语言之间传递的都是指针。而使用栈上的一个 64 位空间也足够存储大部分基本类型数据，足够覆盖到各种长度精度的整型和浮点数类型。</p><p>跨语言之间的方法调用，更多关注的是方法返回值给到另一种语言时的生命周期，以及对象被销毁后的处理。</p><h2 id="Objective-C-对象销毁后的处理"><a href="#Objective-C-对象销毁后的处理" class="headerlink" title="Objective-C 对象销毁后的处理"></a>Objective-C 对象销毁后的处理</h2><p>读过我之前文章的人可能会对 <a href="https://github.com/dart-native/dart_native" target="_blank" rel="noopener">dart_native</a> 的使用方式稍有了解，其实就是自定义 Dart 类来把 Objective-C 类封装了一层。比如我写了个 Dart 类叫 <code>NSObject</code>，封装了大部分基本的 API。打通了方法的调用时类型的自动转换，支持所有基本类型。</p><p>Dart 的 <code>NSObject</code> 类有个指向 Objective-C 对象的指针 <code>_ptr</code>，当这个 Objective-C 对象被销毁时，那么对应的 Dart 对象各种状态也需要置空。虽然 Dart 对象没被及时销毁，但是对其的任何操作都是无效的了。当然，这很容易导致难以发现的 bug。所以需要有效地措施来让开发者知道这个 Dart 对象已经失效了。</p><p>首先是提供 <code>dealloc</code> 方法，让开发者自己清理子类中的内容，这跟写 MRC 代码很像。<br>这是基类中 <code>dealloc</code> 方法的实现（简略版），它清空了 <code>_ptr</code> 指针。当 Objective-C 对象被销毁后，<a href="https://github.com/dart-native/dart_native" target="_blank" rel="noopener">dart_native</a> 框架会负责调用 <code>dealloc</code> 方法，开发者不能手动调用。篇幅原因，这部分的实现原理就不展开讲了。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/// Clean NSObject instance.</span></span><br><span class="line"><span class="regexp">///</span> Subclass can override <span class="keyword">this</span> method <span class="keyword">and</span> call release <span class="literal">on</span> its dart properties.</span><br><span class="line">dealloc() &#123;</span><br><span class="line">    _ptr = nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>dealloc</code> 方法被调用后，需要有能够对 Dart 对象判空的能力。于是我创造了个 Dart 版本的 <code>nil</code>，其实就是一个指向 <code>nullptr</code> 的 Dart 对象。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final id <span class="literal">nil</span> = id(<span class="name">nullptr</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>然后重写了 Dart <code>NSObject</code> 的 <code>==</code> 判等方法，使得 <code>NSObject</code> 的判等变成了指针之间的判等。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool <span class="keyword">operator</span> ==(other) &#123;</span><br><span class="line">    <span class="keyword">if</span> (other == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> pointer == other.pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此一来，一旦 Dart 对象内部指向的 Objective-C 对象被销毁，它就等于 <code>nil</code> 了。</p><h2 id="Dart-从-Objective-C-获取对象"><a href="#Dart-从-Objective-C-获取对象" class="headerlink" title="Dart 从 Objective-C 获取对象"></a>Dart 从 Objective-C 获取对象</h2><p>从 Objective-C 获取对象的方式可能是新创建的，也可能是某个普通方法的返回值。从形式上二者都是调用方法返回对象，但是内存引用计数却不一样。以 <code>new</code>, <code>alloc</code>, <code>copy</code> 和 <code>mutableCopy</code> 开头的方法会被认为引用计数加一，这样就相当于把 Objective-C 对象的管理权交给了 Dart。而普通方法返回的 Objective-C 对象的管理权并不归属 Dart。</p><p>为了简化操作，让这两种获取方式的结果统一，我会在 Dart 侧 <code>NSObject</code> 基类的这四个相关方法中调用一次 <code>autorelease</code>。这样就又把带 <code>new</code>, <code>alloc</code>, <code>copy</code> 和 <code>mutableCopy</code> 前缀的方法返回的 Objective-C 对象的管理权交由 ARC，而又不会过早释放导致 crash。</p><p>这里从使用方式可分两种情况：</p><ol><li>临时使用 Objective-C 对象，当为局部变量：Dart 侧编写代码时无需关心内存管理</li><li>长期使用 Objective-C 对象，作为属性持有：Dart 侧需手动 <code>retain</code> 和 <code>release</code></li></ol><p>针对第二种情况，写过 MRC 代码的会很熟悉。这是对应的 Dart 代码，是不是很像。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyAppState</span> <span class="keyword">extends</span> <span class="title">State&lt;MyApp&gt;</span> </span>&#123;</span><br><span class="line">  <span class="type">NSObject</span> <span class="class"><span class="keyword">object</span> </span>= <span class="type">NSObject</span>().retain();</span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  void dispose() &#123;</span><br><span class="line">    <span class="class"><span class="keyword">object</span>.<span class="title">release</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 Dart VM 支持了 <code>finalize</code>，那么现在的『半自动』内存管理就成了『全自动』了，不过那样的话，内存管理方案也会改变。这里就不谈 Plan B 了。</p><h2 id="Objective-C-从-Dart-获取对象"><a href="#Objective-C-从-Dart-获取对象" class="headerlink" title="Objective-C 从 Dart 获取对象"></a>Objective-C 从 Dart 获取对象</h2><p><a href="https://github.com/dart-native/dart_native" target="_blank" rel="noopener">dart_native</a> 是支持传入回调方法的，也就是 Objective-C 是可以直接调用 Dart 方法的。当 Objective-C 从 Dart 方法的返回值是对象，需要处理好它的生命周期。</p><p>当 Dart 返回给 Objective-C 一个对象时，其内部指向的 Objective-C 对象是交给 ARC 管理的。当 Dart 与 Objective-C 在同一线程时倒还好，切了不同线程后 Objective-C 对象很可能被销毁了，那么就会 crash。此时就需要在 Dart 侧记录下要返回的 Objective-C 对象，这里用到了线程局部存储（TLS）。利用 Dart FFI 调用下面这个 C++ 函数，它在当前线程下持有了 Dart 要返回的 Objective-C 对象，防止被提前销毁。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">native_mark_autoreleasereturn_object(id object) &#123;</span><br><span class="line">    int64_t<span class="built_in"> address </span>= (int64_t)object;</span><br><span class="line">    [NSThread.currentThread do_performWaitingUntilDone:YES block:^&#123;</span><br><span class="line">        NSThread.currentThread.threadDictionary[@(address)] = object;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然还需要在 Objective-C 侧调用完 Dart 方法后，将 TLS 置空，确保不会造成内存泄露。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这篇文章依然没有讲 Dart 如何调用 Objective-C API，没有贴很多代码晒技术细节，满篇都是讲思路和方法。可能是我觉得这些都是 Runtime 的基础，没太多自己思考的东西。写出来也只是简单的科普知识罢了。</p><p>张小龙说『思辨大于执行』，当大家都有很强的执行力的时候，先理清思路就显得很重要。</p><p>主要还是技术细节太多，几篇文章的篇幅都讲不完，我也懒得一次写完。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/dart-native/dart_native&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;dart_native&lt;/a&gt; 基于 Dart FFI，通过 C++ 调用 Native 的 API。这种跨多语言的 bridge 就需要考虑到内存管理的问题。由于篇幅有限，会分开来讲，本篇文章只涉及 Objective-C 对象类型的管理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Dart" scheme="http://yulingtianxia.com/tags/Dart/"/>
    
      <category term="Flutter" scheme="http://yulingtianxia.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>谈谈 dart_native 混合编程引擎的设计</title>
    <link href="http://yulingtianxia.com/blog/2019/11/28/DartObjC-Design/"/>
    <id>http://yulingtianxia.com/blog/2019/11/28/DartObjC-Design/</id>
    <published>2019-11-28T09:07:22.000Z</published>
    <updated>2020-01-30T09:08:31.882Z</updated>
    
    <content type="html"><![CDATA[<p>我之前在 『<a href="http://yulingtianxia.com/blog/2019/10/27/Write-Objective-C-Code-using-Dart/">用 Dart 来写 Objective-C 代码</a>』 这篇文章讲了下我在解决 Flutter 三端开发问题的一个思路和方案，并给出了 Demo 和简单的对比。这次讲下 <a href="https://github.com/dart-native/dart_native" target="_blank" rel="noopener">dart_native</a> 的设计，这包含了上层使用方式和底层技术方案的设计。由于涉及到的技术点很多，这次不会深入太多技术实现细节，不过后续可能会分篇讲下。</p><a id="more"></a><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><h3 id="宇宙真理①：Native-平台接口随版本变化，差异随时间增长。"><a href="#宇宙真理①：Native-平台接口随版本变化，差异随时间增长。" class="headerlink" title="宇宙真理①：Native 平台接口随版本变化，差异随时间增长。"></a>宇宙真理①：Native 平台接口随版本变化，差异随时间增长。</h3><ul><li>iOS 有太多的平台独有框架的 CloudKit、PhotoKit、StoreKit …</li><li>同理安卓也是，且这些差异都跟 UI 无关，无法通过图形引擎统一。</li><li>随着版本发布，不断有新增和废弃的 API，平台差异只会越来越大。</li></ul><h3 id="宇宙真理②：任何跨平台开发框架，Native-API-该用还得用，可能只是换一种语言封装调用，逃不掉的。"><a href="#宇宙真理②：任何跨平台开发框架，Native-API-该用还得用，可能只是换一种语言封装调用，逃不掉的。" class="headerlink" title="宇宙真理②：任何跨平台开发框架，Native API 该用还得用，可能只是换一种语言封装调用，逃不掉的。"></a>宇宙真理②：任何跨平台开发框架，Native API 该用还得用，可能只是换一种语言封装调用，逃不掉的。</h3><p>无论是现今炙手可热的 Flutter，还是之前的 RN 和 Weex，都逃不掉这条真理。</p><p>还有些跨平台框架不通过 Bridge 或 Channel 调用 Native，而是直接将某种语言代码编译成对应平台的二进制。比如最近出的 Kotlin/Native，或是古老的 Xamarin，也都逃不掉这条真理。</p><p><img src="https://github.com/yulingtianxia/Blog-Hexo-Source/blob/master/source/resources/DartObjC/flutter_rn.png?raw=true" alt="Flutter vs RN/Weex"></p><p>Flutter 通过图形引擎的跨平台帮我们抹平了 UI 层面的平台差异，这在跨平台开发框架中已经是个突破了。但其余的部分仍然需要开发者编写很多 Channel 代码来抹平不同平台的差异。不妨将二者结合下，取其精华去其糟粕，于是有了一种新的开发方式：</p><p><img src="https://github.com/yulingtianxia/Blog-Hexo-Source/blob/master/source/resources/DartObjC/dart_native.png?raw=true" alt="DartNative"></p><h3 id="为何这样设计"><a href="#为何这样设计" class="headerlink" title="为何这样设计"></a>为何这样设计</h3><ol><li>Native API 很多，逐个用 Channel 封装的话要多写很多代码。而这里可以借鉴其他跨平台框架『用同一种语言调用不同平台 API』的成熟经验，以 Dart 语言的形式将 Native API 暴露给 Flutter 来调用。将『三端开发』切换语言和开发环境的场景消灭到最低。</li><li>通过 Native Runtime 来应对不同版本 API 变化问题，以不变应万变。搭配 Dart API 自动化生成工具提升效率，解放手写 Channel 带来的一系列开发成本。</li></ol><h2 id="技术指标"><a href="#技术指标" class="headerlink" title="技术指标"></a>技术指标</h2><p><strong>一句话：运行性能和研发效率都要吊打 Flutter Channel。</strong></p><h3 id="研发效率"><a href="#研发效率" class="headerlink" title="研发效率"></a>研发效率</h3><p>以『判断是否安装某 App』为例，针对代码行数进行对比：</p><table><thead><tr><th></th><th>代码行数</th><th>调试成本</th></tr></thead><tbody><tr><td>DartObjC</td><td>Native 1 行/Dart 1 行</td><td><a href="https://github.com/dart-native/dart_native" target="_blank" rel="noopener">dart_native</a> 一行代码直接返回 bool 类型，无需调试 Native 和 Dart 逻辑。</td></tr><tr><td>Channel</td><td>Native 30 行/Dart 15 行</td><td>Channel 需定义返回数据格式，手动转换 BOOL 与 int，判断 channel 和 methodName，需要调试 Native 和 Dart 逻辑</td></tr></tbody></table><p>由于 <a href="https://github.com/dart-native/dart_native" target="_blank" rel="noopener">dart_native</a> 帮开发者完成了类型自动转换，省去了多余的 Channel 逻辑，也就无需调试这部分代码。只需调试 Dart 代码，统一开发环境和语言。</p><p>其实使用 <a href="https://github.com/dart-native/dart_native" target="_blank" rel="noopener">dart_native</a> 后，理论上是不需要写 Native 代码的。</p><h3 id="性能数据"><a href="#性能数据" class="headerlink" title="性能数据"></a>性能数据</h3><p>分别测试了两个 Native 接口在相同环境下执行 1 万次的耗时情况(ms)：</p><table><thead><tr><th>接口案例</th><th>总耗时对比（Channel/dart_native）</th><th>仅通道耗时对比（Channel/dart_native）</th></tr></thead><tbody><tr><td>判断是否安装某 App</td><td>5202/<strong>4166</strong></td><td>919/<strong>99</strong></td></tr><tr><td>打日志</td><td>2480/<strong>2024</strong></td><td>1075/<strong>432</strong></td></tr></tbody></table><p>严格来讲，对比性能时需要刨除 Native 方法自身的执行耗时，剩下的就是通道的耗时了。在这方面 Flutter Channel 的耗时是 <a href="https://github.com/dart-native/dart_native" target="_blank" rel="noopener">dart_native</a> 的好几倍。在测试打日志这个案例时，<a href="https://github.com/dart-native/dart_native" target="_blank" rel="noopener">dart_native</a> 耗时瓶颈在于将 Dart <code>String</code> 转为 Objective-C <code>NSString</code>，所以耗时仅仅比 Flutter Channel 少了 60% 左右。</p><p>而在真实场景下，总耗时就更加有意义。由于 Native 方法本身执行的耗时占比较大，所以最终二者的耗时对比并不是几倍的关系，但 <a href="https://github.com/dart-native/dart_native" target="_blank" rel="noopener">dart_native</a> 依然有着性能上的优势。</p><h3 id="支持的特性"><a href="#支持的特性" class="headerlink" title="支持的特性"></a>支持的特性</h3><p>为了在 Flutter 中使用，<a href="https://github.com/dart-native/dart_native" target="_blank" rel="noopener">dart_native</a> 无法用到 Dart 反射特性，但依然最大限度地实现了对 Objective-C 语法特性的支持。</p><h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><p>Dart 和 Objective-C 的内存管理方式差异很大。前者使用 GC，后者使用 ARC。目前的解决方案是『半自动引用计数』的内存管理方式，大多数场景下无需关注内存问题。待 Dart 支持 <code>finalizer</code> 可优化为『全自动』。这其中用到了一些算不上黑科技的土方子，暂且奏效。</p><p>Dart 中临时使用和创建的 Objective-C 对象、C-String 或结构体无需关注内存问题，但如果想长期持有，需要调用 <code>retain()</code> 方法，并在不用的时候（比如页面销毁时）调用 <code>release()</code> 方法。</p><h4 id="Native-Callback"><a href="#Native-Callback" class="headerlink" title="Native Callback"></a>Native Callback</h4><p>有很多 Native API 的参数一个 Callback。这类方法大多是一些异步返回的方法，传入参数的方式大多是 Block 或 Delegate。为了让 Dart 能够调用这些 API，<a href="https://github.com/dart-native/dart_native" target="_blank" rel="noopener">dart_native</a> 实现了『用 Dart 语法写 Block 和 Delegate』。这需要实现动态创建任意函数签名的 Block 对象和 Objective-C 方法，甚至当 Dart 类并没有对应的 Objective-C 类时，需要动态创建这个类。这其中又涉及到大量内建类型的自动转换和边界问题处理。</p><h4 id="多线程-GCD"><a href="#多线程-GCD" class="headerlink" title="多线程 / GCD"></a>多线程 / GCD</h4><p>Flutter 中运行时，VM 会开辟一些内建的线程来维持 Flutter 的运行。我们编写的 Dart 代码大多跑在 flutter.ui 线程，但这不是 Native 系统的主线程。而有些 API 要求必须在主线程调用，所以 <a href="https://github.com/dart-native/dart_native" target="_blank" rel="noopener">dart_native</a> 也支持指定线程和队列调用。</p><p>对于 GCD 的 API 仅有部分支持，且计划为 Swift 风格语法。等 dart:ffi 1.1 支持 async callback 后，这部分的功能会得到加强。</p><h4 id="方法调用时的类型自动转换"><a href="#方法调用时的类型自动转换" class="headerlink" title="方法调用时的类型自动转换"></a>方法调用时的类型自动转换</h4><p><a href="https://github.com/dart-native/dart_native" target="_blank" rel="noopener">dart_native</a> 会自动转换 Dart 与 Objective-C 类型。大部分 Objective-C 类型在 Dart 中都有对应的封装类，或者是可以映射到 Dart 基本类型。目前有的转换是单项的，比如 Dart Function 可以转为 Objective-C Block，反之则不行。</p><p>已支持以下类型的自动转换：</p><table><thead><tr><th>Dart</th><th>Objective-C</th></tr></thead><tbody><tr><td>int</td><td>int8_t</td></tr><tr><td>int</td><td>int16_t</td></tr><tr><td>int</td><td>int32_t</td></tr><tr><td>int</td><td>int64_t</td></tr><tr><td>int</td><td>uint8_t</td></tr><tr><td>int</td><td>uint16_t</td></tr><tr><td>int</td><td>uint32_t</td></tr><tr><td>int</td><td>uint64_t</td></tr><tr><td>char/int/String</td><td>char</td></tr><tr><td>unsigned_char/int/String</td><td>unsigned char</td></tr><tr><td>short/int</td><td>short</td></tr><tr><td>unsigned_short/int</td><td>unsigned short</td></tr><tr><td>long/int</td><td>long</td></tr><tr><td>unsigned_long/int</td><td>unsigned long</td></tr><tr><td>long_long/int</td><td>long long</td></tr><tr><td>unsigned_long_long/int</td><td>unsigned long long</td></tr><tr><td>NSInteger/int</td><td>NSInteger</td></tr><tr><td>NSUInteger/int</td><td>NSUInteger</td></tr><tr><td>size_t/int</td><td>size_t</td></tr><tr><td>float/double</td><td>float</td></tr><tr><td>double</td><td>double</td></tr><tr><td>double</td><td>CGFloat</td></tr><tr><td>bool</td><td>BOOL/bool/_Bool</td></tr><tr><td>CGSize</td><td>CGSize</td></tr><tr><td>CGPoint</td><td>CGPoint</td></tr><tr><td>CGVector</td><td>CGVector</td></tr><tr><td>CGRect</td><td>CGRect</td></tr><tr><td>NSRange</td><td>NSRange/_NSRange</td></tr><tr><td>UIOffset</td><td>UIOffset</td></tr><tr><td>UIEdgeInsets</td><td>UIEdgeInsets</td></tr><tr><td>NSDirectionalEdgeInsets</td><td>NSDirectionalEdgeInsets</td></tr><tr><td>CGAffineTransform</td><td>CGAffineTransform</td></tr><tr><td>NSObject</td><td>NSObject</td></tr><tr><td>NSObjectProtocol</td><td>NSObjectProtocol</td></tr><tr><td>Block/Function</td><td>NSBlock</td></tr><tr><td>Class</td><td>Class</td></tr><tr><td>Selector/SEL</td><td>Selector/SEL</td></tr><tr><td>Protocol</td><td>Protocol</td></tr><tr><td>NSString/String</td><td>NSString</td></tr><tr><td>String</td><td>char *</td></tr><tr><td>Pointer<void></void></td><td>void *</td></tr><tr><td>void</td><td>void</td></tr><tr><td>NSValue</td><td>NSValue</td></tr><tr><td>NSNumber</td><td>NSNumber</td></tr><tr><td>NSArray/List</td><td>NSArray</td></tr><tr><td>NSDictionary/Map</td><td>NSDictionary</td></tr><tr><td>NSSet/Set</td><td>NSSet</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我之前在 『&lt;a href=&quot;http://yulingtianxia.com/blog/2019/10/27/Write-Objective-C-Code-using-Dart/&quot;&gt;用 Dart 来写 Objective-C 代码&lt;/a&gt;』 这篇文章讲了下我在解决 Flutter 三端开发问题的一个思路和方案，并给出了 Demo 和简单的对比。这次讲下 &lt;a href=&quot;https://github.com/dart-native/dart_native&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;dart_native&lt;/a&gt; 的设计，这包含了上层使用方式和底层技术方案的设计。由于涉及到的技术点很多，这次不会深入太多技术实现细节，不过后续可能会分篇讲下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Dart" scheme="http://yulingtianxia.com/tags/Dart/"/>
    
      <category term="Flutter" scheme="http://yulingtianxia.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>用 Dart 来写 Objective-C 代码</title>
    <link href="http://yulingtianxia.com/blog/2019/10/27/Write-Objective-C-Code-using-Dart/"/>
    <id>http://yulingtianxia.com/blog/2019/10/27/Write-Objective-C-Code-using-Dart/</id>
    <published>2019-10-27T09:59:40.000Z</published>
    <updated>2020-01-30T09:07:43.470Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章不是讲 Flutter Channel 入门的，可能让你失望了。不过继续往下读可能也会有点收获。</p><p>Flutter 提升了客户端开发的效率，但在跟 Native 代码配合开发时也带来了不好的体验。于是我写了个 Flutter 插件 <a href="https://pub.dev/packages/dart_native" target="_blank" rel="noopener">dart_native</a>，使开发者可以用 Dart 的语法来写 Objective-C 代码。借助于 Flutter 的热重载，也可以更高效的动态调试 Native 代码，从此告别在两个工程和 IDE 中切来切去。方法调用性能相比 Channel 也提升很多。</p><p>尚在开发中，开源地址：<a href="https://github.com/yulingtianxia/dart_objc" target="_blank" rel="noopener">https://github.com/yulingtianxia/dart_objc</a></p><a id="more"></a><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>先说说为什么会有开发效率的问题。Flutter 的跨平台多适用于 UI 等上层需求，本来是可以提升开发效率的。但是诸如 LBS、系统和设备信息、获取相册等常用功能都需要两端去写很多 Native 代码。<strong>最终原本的『两端开发』最后成了『三端开发』</strong>。很少会有完全用 Flutter 开发的 App，原因如下：</p><ol><li>一些跟系统和设备强相关的功能只能靠调用 API 来实现</li><li>旧项目引入 Flutter 后需调用已有的 Native 模块代码</li></ol><p>既然『三端开发』无法避免，那么增加了哪些成本呢？</p><ol><li>开发过程中需要在至少两个 IDE 打开的工程中来回切换，需单独运行，无论是写代码还是 Debug 都体验不连贯，降低效率</li><li>如果 Flutter 和 Native 代码由不同的人来开发和维护，增加了沟通成本</li><li>Flutter 需要通过编写 channel 代码来与 Native 层交互，需要两端开发时统一数据传输协议。不仅 channel 调用性能较差，Model 数据在 Native 与 Flutter 之间传递过程的序列化和反序列化也降低性能。</li><li>通过 channel 在 Flutter 和 Native 之间调用时只支持异步回调</li></ol><h2 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h2><p>既然无法避免调用 Native 的 API，那么就要面对这个事实。下一步是如何能让调用 Native API 的这个过程效率更高。具体体现如下：</p><ol><li>开发效率提高：直接用 Dart 语言在 Flutter 工程里编写和调试代码，无需切换到 Xcode 等其他 IDE 打开的 Native 工程</li><li>运行效率提高：channel 的调用性能差一直被诟病</li></ol><p>所以思路就是：</p><ol><li>将 Native API 封装成对应的 Dart 语言，解决一系列语言之间的类型转换和语法兼容问题</li><li>通过一个更高效的方式来调用 Native API，这里使用 dart:ffi 调用 C 函数，再通过 Runtime 机制调用 Native</li></ol><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>提供一个 Flutter 库来提供 Dart 语言的 API，通过 dart:ffi 作为 Flutter 与 Native 之间的桥。对比 Dart 与 Native 的语法特性，对一些类型进行内存级别的底层转换。</p><p><a href="https://pub.dev/packages/dart_native" target="_blank" rel="noopener">dart_native</a> 由于采用指针地址直接传递的方式，方法调用性能相比 channel 提升了<strong>几倍甚至一个数量级</strong>。（测试接口为获取系统版本，如涉及复杂参数的序列化可能差异更大）</p><p>由于 <a href="https://pub.dev/packages/dart_native" target="_blank" rel="noopener">dart_native</a> 组件还在基于 dev 版本的 Dart 开发，可能后续还会有比较大的变动，甚至是 API 的变化。所以没有过多展开讲实现细节，感兴趣可以去自己看代码：<a href="https://github.com/yulingtianxia/dart_objc" target="_blank" rel="noopener">https://github.com/yulingtianxia/dart_objc</a></p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>假如你写了个 Objective-C 的类叫 <code>RuntimeStub</code>，并实现了个 <code>fooBlock:</code> 方法，参数和返回值都是个 block 对象。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RuntimeStub</span> ()</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RuntimeStub</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>(^BarBlock)(<span class="built_in">NSObject</span> *a);</span><br><span class="line">- (BarBlock)fooBlock:(BarBlock)block &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>利用 <a href="https://pub.dev/packages/dart_native" target="_blank" rel="noopener">dart_native</a> 写 Dart 代码调用过程如下：</p><p>初始化一个 <code>NSObject</code> 对象，传入类名就可以 <code>new</code> 任意类型的对象。<code>perform()</code> 方法可以调用任意对象的任何方法，跟 Objective-C 的用法基本一致。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSObject stub = NSObject(<span class="string">'RuntimeStub'</span>);</span><br><span class="line">Block block = stub.perform(Selector(<span class="string">'fooBlock:'</span>), args: [barFunc]);</span><br></pre></td></tr></table></figure><p>Objective-C 中 Block 这种匿名函数或闭包的概念在 Dart 中其实就是 Function，所以当参数是 Block 对象的时候，可以直接传入一个与之函数签名一样的 Dart Function 对象。<a href="https://pub.dev/packages/dart_native" target="_blank" rel="noopener">dart_native</a> 会自动完成参数类型转换和调用等一系列底层细节。所以用 Dart 实现的 <code>barFunc</code> 与 Objective-C 接口 <code>BarBlock</code> 的签名需要一致：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span> barFunc = (NSObject a) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'hello block! <span class="subst">$&#123;a.toString()&#125;</span>'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">101</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Dart 调用 Block 也很简单，调用 <code>invoke</code> 方法就行：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> result = block.invoke([stub]);</span><br></pre></td></tr></table></figure><p>最后也可以用 Dart 封装下 <code>RuntimeStub</code> 类，这样调用代码更简洁。这种模板代码后续会做成自动生成的，而不用手写。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RuntimeStub</span> <span class="keyword">extends</span> <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">  RuntimeStub() : <span class="keyword">super</span>(<span class="string">'RuntimeStub'</span>);</span><br><span class="line"></span><br><span class="line">  Block fooBlock(<span class="built_in">Function</span> func) &#123;</span><br><span class="line">    <span class="keyword">return</span> perform(Selector(<span class="string">'fooBlock:'</span>), args: [func]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>目前的 Cocoa API 封装打算参考 Swift 版本的文档，毕竟 Dart 有些语法跟 Swift 还有点像。</p><p>Android 平台的实现也在规划中，最终将会结束 Flutter 三端开发现状，实现真正的前端大一统。</p><p>不吹了，还要做的事情真的太多了。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章不是讲 Flutter Channel 入门的，可能让你失望了。不过继续往下读可能也会有点收获。&lt;/p&gt;
&lt;p&gt;Flutter 提升了客户端开发的效率，但在跟 Native 代码配合开发时也带来了不好的体验。于是我写了个 Flutter 插件 &lt;a href=&quot;https://pub.dev/packages/dart_native&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;dart_native&lt;/a&gt;，使开发者可以用 Dart 的语法来写 Objective-C 代码。借助于 Flutter 的热重载，也可以更高效的动态调试 Native 代码，从此告别在两个工程和 IDE 中切来切去。方法调用性能相比 Channel 也提升很多。&lt;/p&gt;
&lt;p&gt;尚在开发中，开源地址：&lt;a href=&quot;https://github.com/yulingtianxia/dart_objc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/yulingtianxia/dart_objc&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yulingtianxia.com/tags/Objective-C/"/>
    
      <category term="Runtime" scheme="http://yulingtianxia.com/tags/Runtime/"/>
    
      <category term="Dart" scheme="http://yulingtianxia.com/tags/Dart/"/>
    
  </entry>
  
  <entry>
    <title>App 二进制文件重排已经被玩坏了</title>
    <link href="http://yulingtianxia.com/blog/2019/09/01/App-Order-Files/"/>
    <id>http://yulingtianxia.com/blog/2019/09/01/App-Order-Files/</id>
    <published>2019-08-31T16:47:39.000Z</published>
    <updated>2019-09-01T04:07:37.894Z</updated>
    
    <content type="html"><![CDATA[<p>『二进制文件重排优化启动速度』本是一项上古 PC 时代就玩过的东东，前一阵子借助某宇宙大厂重新火了一把。不过令我惊讶的是：这么简单个事情竟然搞得如此复杂，而且还声称『开拓性的探索、在没有业界经验可供参考』。。。</p><p><del>说真话可能会得罪人，但是我怕过吗？</del> 我怂了，这段掐了。</p><p>其实二进制文件重排很简单啊，重点在于生成 order 文件。我基于 Clang SanitizerCoverage 和业界已有的经验，整了个 <a href="https://github.com/yulingtianxia/AppOrderFiles" target="_blank" rel="noopener">AppOrderFiles</a>，一个调用搞定！Enjoy it！</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AppOrderFiles(^(<span class="built_in">NSString</span> *orderFilePath) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"OrderFilePath:%@"</span>, orderFilePath);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="苹果官方文档的古老方案"><a href="#苹果官方文档的古老方案" class="headerlink" title="苹果官方文档的古老方案"></a>苹果官方文档的古老方案</h2><p>苹果的官方文档很早就给了二进制文件重排的方案：<a href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/CodeFootprint/Articles/ImprovingLocality.html#//apple_ref/doc/uid/20001862-117091-BCIBJEBH" target="_blank" rel="noopener">Improving Locality of Reference</a>，『早』到甚至被苹果提示这份文档已经年久失修，部分工具和链接失效了。文档的过时不仅体现在还是 GCC 时代，连工具链比如像 <code>gprof</code> 也不能用了，不过 Google 也给出了 macOS 上的替代品，有兴趣的可以去研究下。</p><h2 id="Facebook-的-hfsort"><a href="#Facebook-的-hfsort" class="headerlink" title="Facebook 的 hfsort"></a>Facebook 的 hfsort</h2><p>需要先用 hf-prod-collect.sh 收集数据，然后塞给 <a href="https://github.com/facebook/hhvm/tree/master/hphp/tools/hfsort" target="_blank" rel="noopener">hfsort</a> 生成 hotfuncs.txt 文件。很好很强大，不过对于编程小白来说有一定的使用成本。</p><p>PS：此方案来自于我写了这篇文章后，jmpews 大神丢给我了个链接，受益匪浅。（其实我啥都看不懂）</p><h2 id="基于-Clang-SanitizerCoverage-的方案"><a href="#基于-Clang-SanitizerCoverage-的方案" class="headerlink" title="基于 Clang SanitizerCoverage 的方案"></a>基于 Clang SanitizerCoverage 的方案</h2><p>在 <a href="https://clang.llvm.org/docs/SanitizerCoverage.html#tracing-pcs" target="_blank" rel="noopener">Clang 10 documentation</a> 中可以看到 LLVM 官方对 SanitizerCoverage 的详细介绍，包含了示例代码。</p><p>简单来说 SanitizerCoverage 是 Clang 内置的一个代码覆盖工具。它把一系列以 <code>__sanitizer_cov_trace_pc_</code> 为前缀的函数调用插入到用户定义的函数里，借此实现了全局 AOP 的大杀器。其覆盖之广，包含 Swift/Objective-C/C/C++ 等语言，Method/Function/Block 全支持。</p><p>开启 SanitizerCoverage 的方法是：在 build settings 里的 “Other C Flags” 中添加 <code>-fsanitize-coverage=func,trace-pc-guard</code>。如果含有 Swift 代码的话，还需要在 “Other Swift Flags” 中加入 <code>-sanitize-coverage=func</code> 和 <code>-sanitize=undefined</code>。所有链接到 App 中的二进制都需要开启 SanitizerCoverage，这样才能完全覆盖到所有调用。</p><p>基于 Clang SanitizerCoverage 我写了个工具 AppOrderFiles。CocoaPods 接入，一行调用生成 Order File。啥也不说了，全在 GayHub 里了：<a href="https://github.com/yulingtianxia/AppOrderFiles" target="_blank" rel="noopener">https://github.com/yulingtianxia/AppOrderFiles</a></p><p>当然这也不完全是我的原创，对照着 Clang 文档的同时，还参考了 <a href="https://medium.com/@michael.eisel/improving-app-performance-with-order-files-c7fff549907f" target="_blank" rel="noopener">Improving App Performance with Order Files</a> 这篇文章的代码。人家这篇文章虽然早就给出了，不过还是有一些 bug 和优化空间的。</p><p>原理就是在 SanitizerCoverage 的回调函数里将地址先收集到队列里，调用 <code>AppOrderFiles()</code> 后会停止收集，并将队列中的 PC 地址依次翻译符号，最后去重。反正代码也不多，直接贴核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> OSQueueHead <span class="built_in">queue</span> = OS_ATOMIC_QUEUE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> BOOL collectFinished = NO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *pc;</span><br><span class="line">    <span class="keyword">void</span> *next;</span><br><span class="line">&#125; PCNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The guards are [start, stop).</span></span><br><span class="line"><span class="comment">// This function will be called at least once per DSO and may be called</span></span><br><span class="line"><span class="comment">// more than once with the same values of start/stop.</span></span><br><span class="line"><span class="keyword">void</span> __sanitizer_cov_trace_pc_guard_init(<span class="keyword">uint32_t</span> *start,</span><br><span class="line">                                         <span class="keyword">uint32_t</span> *stop) &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">uint32_t</span> N;  <span class="comment">// Counter for the guards.</span></span><br><span class="line">    <span class="keyword">if</span> (start == stop || *start) <span class="keyword">return</span>;  <span class="comment">// Initialize only once.</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"INIT: %p %p\n"</span>, start, stop);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> *x = start; x &lt; stop; x++)</span><br><span class="line">        *x = ++N;  <span class="comment">// Guards should start from 1.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This callback is inserted by the compiler on every edge in the</span></span><br><span class="line"><span class="comment">// control flow (some optimizations apply).</span></span><br><span class="line"><span class="comment">// Typically, the compiler will emit the code like this:</span></span><br><span class="line"><span class="comment">//    if(*guard)</span></span><br><span class="line"><span class="comment">//      __sanitizer_cov_trace_pc_guard(guard);</span></span><br><span class="line"><span class="comment">// But for large functions it will emit a simple call:</span></span><br><span class="line"><span class="comment">//    __sanitizer_cov_trace_pc_guard(guard);</span></span><br><span class="line"><span class="keyword">void</span> __sanitizer_cov_trace_pc_guard(<span class="keyword">uint32_t</span> *guard) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!*guard) <span class="keyword">return</span>;  <span class="comment">// Duplicate the guard check.</span></span><br><span class="line">    <span class="keyword">if</span> (collectFinished) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If you set *guard to 0 this code will not be called again for this edge.</span></span><br><span class="line">    <span class="comment">// Now you can get the PC and do whatever you want:</span></span><br><span class="line">    <span class="comment">//   store it somewhere or symbolize it and print right away.</span></span><br><span class="line">    <span class="comment">// The values of `*guard` are as you set them in</span></span><br><span class="line">    <span class="comment">// __sanitizer_cov_trace_pc_guard_init and so you can make them consecutive</span></span><br><span class="line">    <span class="comment">// and use them to dereference an array or a bit vector.</span></span><br><span class="line">    *guard = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">void</span> *PC = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">    PCNode *node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(PCNode));</span><br><span class="line">    *node = (PCNode)&#123;PC, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    OSAtomicEnqueue(&amp;<span class="built_in">queue</span>, node, offsetof(PCNode, next));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>苹果官方也提供了 PGO 的详细文档，而且操作很简单。不过它跟二进制文件重排还是有区别的，这里不展开讲了。毕竟相对于对业务代码加载优先级的优化来说，PGO 对启动优化性价比没那么高，应该就是高频调用函数内联之类的（这句纯属瞎扯）。</p><p>我为啥过了这么久才发此文呢？猜猜原因是啥：</p><p>A. 不爱蹭热度<br>B. 喜欢炒冷饭<br>C. 忙准备答辩<br>D. 8 月已经发过文章了，这篇得等到 9 月发，这样才不浪费</p><p>碰到不会的题，我一般三短一长选最长。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;『二进制文件重排优化启动速度』本是一项上古 PC 时代就玩过的东东，前一阵子借助某宇宙大厂重新火了一把。不过令我惊讶的是：这么简单个事情竟然搞得如此复杂，而且还声称『开拓性的探索、在没有业界经验可供参考』。。。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;说真话可能会得罪人，但是我怕过吗？&lt;/del&gt; 我怂了，这段掐了。&lt;/p&gt;
&lt;p&gt;其实二进制文件重排很简单啊，重点在于生成 order 文件。我基于 Clang SanitizerCoverage 和业界已有的经验，整了个 &lt;a href=&quot;https://github.com/yulingtianxia/AppOrderFiles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AppOrderFiles&lt;/a&gt;，一个调用搞定！Enjoy it！&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;AppOrderFiles(^(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *orderFilePath) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;OrderFilePath:%@&quot;&lt;/span&gt;, orderFilePath);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="瞎折腾" scheme="http://yulingtianxia.com/tags/%E7%9E%8E%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>BlockHook with Invocation(2)</title>
    <link href="http://yulingtianxia.com/blog/2019/08/11/BlockHook-with-Invocation-2/"/>
    <id>http://yulingtianxia.com/blog/2019/08/11/BlockHook-with-Invocation-2/</id>
    <published>2019-08-11T14:18:51.000Z</published>
    <updated>2019-08-14T03:04:30.649Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://yulingtianxia.com/blog/2019/07/27/BlockHook-with-Invocation/">上一篇文章</a> 简单介绍了下 <code>retainArguments</code> 和 <code>block_interceptor</code> 实现的思路，本文会详细讲解下 <code>BHInvocation</code> 的接口设计与实现，并与系统的 <code>NSInvocation</code> 作对比。</p><a id="more"></a><h2 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h2><p><code>BHInvocation</code> 相当于是参照 <code>NSInvocation</code> 的接口并改造了下，以承载 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 的一些元数据。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BHInvocation</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">weak</span>) BHToken *token;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) BlockHookMode mode;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">getter</span>=isArgumentsRetained, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> argumentsRetained;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSMethodSignature</span> *methodSignature;</span><br><span class="line">- (<span class="keyword">void</span>)invokeOriginalBlock; <span class="comment">// 替代 invoke 和 invokeWithTarget:</span></span><br><span class="line">- (<span class="keyword">void</span>)retainArguments;</span><br><span class="line">- (<span class="keyword">void</span>)getReturnValue:(<span class="keyword">void</span> *)retLoc;</span><br><span class="line">- (<span class="keyword">void</span>)setReturnValue:(<span class="keyword">void</span> *)retLoc;</span><br><span class="line">- (<span class="keyword">void</span>)getArgument:(<span class="keyword">void</span> *)argumentLocation atIndex:(<span class="built_in">NSInteger</span>)idx;</span><br><span class="line">- (<span class="keyword">void</span>)setArgument:(<span class="keyword">void</span> *)argumentLocation atIndex:(<span class="built_in">NSInteger</span>)idx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="BlockHook-相关的接口"><a href="#BlockHook-相关的接口" class="headerlink" title="BlockHook 相关的接口"></a>BlockHook 相关的接口</h3><p>为了存储 Hook 相关的信息，需要在 <code>NSInvocation</code> 的接口基础上新增 <code>token</code> 属性和 <code>mode</code> 属性。不过 <code>BHToken</code> 其实已经存储了 <code>BlockHookMode</code>，为何还要再在 <code>BHInvocation</code> 中加一个 <code>mode</code> 呢？</p><p><code>BHToken</code> 存储的是一次 Hook 行为的元数据；<code>BHInvocation</code> 存储的是 Hook 后 Block 执行时的元数据。<code>BHToken</code> 存储的 <code>mode</code> 是 Hook 的模式，可能包含了多种模式；而 <code>BHInvocation</code> 存储的 <code>mode</code> 则是当前这次 Hook 执行回调所处的时机。</p><p>例如同时 Hook Block 执行的前后，此时传入的 <code>mode</code> 值为 <code>BlockHookModeBefore|BlockHookModeAfter</code>，生成的 <code>BHToken</code> 的值也是一样。而 Block 执行前后会有两次回调，传入的 <code>BHInvocation</code> 参数内容却不太一样：其 <code>mode</code> 分别为 <code>BlockHookModeBefore</code> 和 <code>BlockHookModeAfter</code>。但这两次传入的 <code>BHInvocation</code> 中的 <code>token</code> 确是完全一样。</p><p><code>BHToken</code> 也是初始化 <code>BHInvocation</code> 所用到的唯一参数。</p><p>由于是 Hook，所以执行 Block 时需要注意是调用原始实现还是新的实现。 加入了 <code>invokeOriginalBlock</code> 接口来调用原始实现，这也是所有 AOP 工具的必要设计。</p><h3 id="NSInvocation-相关的接口"><a href="#NSInvocation-相关的接口" class="headerlink" title="NSInvocation 相关的接口"></a><code>NSInvocation</code> 相关的接口</h3><p>为了降低使用者的学习成本，<a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 的接口设计上会尽量参照一些已有的 AOP 工具。在 Invocation 这块，能参照的最好的例子就是系统提供的 <code>NSInvocation</code>。其提供了<strong>读、写和 <code>retian</code> 参数列表/返回值</strong>的接口，以及方法签名等。</p><p>而 <code>NSInvocation</code> 有些接口在 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 中是用不到的，比如 <code>selector</code> 属性没什么意义，再比如 <code>invoke</code> 和 <code>invokeWithTarget:</code> 这两个接口在 AOP 场景下也不必存在。</p><h2 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h2><p>在<a href="http://yulingtianxia.com/blog/2019/07/27/BlockHook-with-Invocation/">上一篇文章</a>中介绍了过了 <code>retainArguments</code> 的实现思路，针对每个指向参数或返回值的指针都需要经历 “Copy” 和 “Retain” 两步：</p><p><img src="https://github.com/yulingtianxia/Blog-Hexo-Source/blob/master/source/resources/BlockHook/retainArguments.png?raw=true" alt></p><h3 id="Copy-Pointer"><a href="#Copy-Pointer" class="headerlink" title="Copy Pointer"></a>Copy Pointer</h3><p>无论 <code>pointer</code> 指向的内容是一个 <code>struct</code> 还是 <code>NSObject *</code>，都需要将 <code>pointer</code> 的内容拷贝，防止原始内存被修改或者释放。在拷贝前需要开辟新的内存，其生命周期与 <code>BHInvocation</code> 绑定在一起。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span> *)_copyPointer:(<span class="keyword">void</span> **)pointer encode:(<span class="keyword">const</span> <span class="keyword">char</span> *)encode key:(<span class="built_in">NSNumber</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> pointerSize;</span><br><span class="line">    <span class="built_in">NSGetSizeAndAlignment</span>(encode, &amp;pointerSize, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">NSMutableData</span> *pointerData = [<span class="built_in">NSMutableData</span> dataWithLength:pointerSize];</span><br><span class="line">    <span class="keyword">self</span>.mallocMap[key] = pointerData;</span><br><span class="line">    <span class="keyword">void</span> *pointerBuf = pointerData.mutableBytes;</span><br><span class="line">    memcpy(pointerBuf, pointer, pointerSize);</span><br><span class="line">    <span class="keyword">return</span> pointerBuf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Retain-Pointer"><a href="#Retain-Pointer" class="headerlink" title="Retain Pointer"></a>Retain Pointer</h3><p>如果 <code>pointer</code> 指向的内容依然是个指针，比如 <code>NSObject *</code> 或 <code>char *</code>，还需要防止其内容提前被释放，产生野指针。这里相当于是对 Objective-C 对象和 C-String 的特殊处理，以参数和返回值的 index 作为 key，利用字典 <code>retainMap</code> 强引用 Objective-C 对象；对于 Block 对象还需调用 <code>copy</code> 方法，将栈上的 Block 拷贝到堆上防止被提早释放；对于 C-String 则是开辟新内存并拷贝字符串内容，然后放入 <code>retainMap</code> 中；</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)_retainPointer:(<span class="keyword">void</span> **)pointer encode:(<span class="keyword">const</span> <span class="keyword">char</span> *)encode key:(<span class="built_in">NSNumber</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *p = *pointer;</span><br><span class="line">    <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (encode[<span class="number">0</span>] == <span class="string">'@'</span>) &#123;</span><br><span class="line">        <span class="keyword">id</span> arg = (__bridge <span class="keyword">id</span>)p;</span><br><span class="line">        <span class="keyword">if</span> (strcmp(encode, <span class="string">"@?"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.retainMap[key] = [arg <span class="keyword">copy</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.retainMap[key] = arg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (encode[<span class="number">0</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> *arg = p;</span><br><span class="line">        <span class="built_in">NSMutableData</span> *data = [<span class="built_in">NSMutableData</span> dataWithLength:<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * strlen(arg)];</span><br><span class="line">        <span class="keyword">self</span>.retainMap[key] = data;</span><br><span class="line">        <span class="keyword">char</span> *str = data.mutableBytes;</span><br><span class="line">        strcpy(str, arg);</span><br><span class="line">        *pointer = str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读写参数和返回值"><a href="#读写参数和返回值" class="headerlink" title="读写参数和返回值"></a>读写参数和返回值</h3><p><a href="http://yulingtianxia.com/blog/2019/07/27/BlockHook-with-Invocation/">上一篇文章</a>讲述了 <code>BHInvocation</code> 存储参数列表和返回值上的一些处理策略，这里来讲讲如何读写。</p><p>在实现读写参数列表和返回值接口时，不仅仅是对 <code>args</code> 和 <code>retValue</code> 指针的读写操作，还要考虑到 Copy Pointer 和 Retain Pointer。</p><p>Copy Pointer 这步无需自行开辟内存了，原因是写入时 <code>retainArguments</code> 的时候已经开辟好了，读取时直接使用传入的指针。</p><p>Retain Pointer 接口使用 <code>idx</code> 作为 key，写入新的值时会替换字典 <code>retainMap</code> 中的旧值。这样既可以释放旧值，也能重新 retain 新值。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)getArgument:(<span class="keyword">void</span> *)argumentLocation atIndex:(<span class="built_in">NSInteger</span>)idx</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!argumentLocation || !<span class="keyword">self</span>.args || !<span class="keyword">self</span>.args[idx]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> *arg = <span class="keyword">self</span>.args[idx];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *type = [<span class="keyword">self</span>.methodSignature getArgumentTypeAtIndex:idx];</span><br><span class="line">    <span class="built_in">NSUInteger</span> argSize;</span><br><span class="line">    <span class="built_in">NSGetSizeAndAlignment</span>(type, &amp;argSize, <span class="literal">NULL</span>);</span><br><span class="line">    memcpy(argumentLocation, arg, argSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setArgument:(<span class="keyword">void</span> *)argumentLocation atIndex:(<span class="built_in">NSInteger</span>)idx</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!argumentLocation || !<span class="keyword">self</span>.args || !<span class="keyword">self</span>.args[idx]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> *arg = <span class="keyword">self</span>.args[idx];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *type = [<span class="keyword">self</span>.methodSignature getArgumentTypeAtIndex:idx];</span><br><span class="line">    <span class="built_in">NSUInteger</span> argSize;</span><br><span class="line">    <span class="built_in">NSGetSizeAndAlignment</span>(type, &amp;argSize, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isArgumentsRetained) &#123;</span><br><span class="line">        [<span class="keyword">self</span> _retainPointer:argumentLocation encode:type key:@(idx)];</span><br><span class="line">    &#125;</span><br><span class="line">    memcpy(arg, argumentLocation, argSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ARC 下从 <code>NSInvocation</code> 读取参数或返回值时，如果类型为 Objective-C 对象，则需要避免默认的强引用。<a href="https://stackoverflow.com/questions/16928299/get-block-argument-from-nsinvocation-with-arc" target="_blank" rel="noopener">Stack Overflow</a> 上有具体解决方案，其中的一种方案如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSObject * __unsafe_unretained <span class="keyword">arg</span>;</span><br><span class="line">[invocation getArgument:&amp;<span class="keyword">arg</span> atIndex:<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p><code>BHInvocation</code> 由于高仿了 <code>NSInvocation</code> 的接口和实现，所以也需要注意此问题。究其原因在于 <code>memcpy</code> 只是内存拷贝，不是直接向 <code>strong</code> 类型变量赋值，并不会参与到 ARC 的引用计数中。而出了作用域后 ARC 会自动对 <code>strong</code> 类型 <code>release</code> 一次，导致读取到的对象过度释放，导致 crash。（PS：ARC 真实的实现机制会更复杂些，为了描述方便这里对原理进行了简化）</p><p>其实还有一种更好的方式读参数，那就是直接在 <code>aspectBlock</code> 中取参数。<code>aspectBlock</code> 中的参数是可以随意写的，但需要跟 Block 的参数列表对应上。写法可以参照下面这个测试用例，直接获取参数，然后修改参数：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testObjectArg &#123;</span><br><span class="line">    <span class="built_in">NSObject</span> *argOrig = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    <span class="built_in">NSObject</span> *argFixed = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    <span class="keyword">void</span> (^ObjectArgBlock)(<span class="built_in">NSObject</span> *) = ^(<span class="built_in">NSObject</span> *test)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSAssert</span>(test == argFixed, <span class="string">@"Modify struct member failed!"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    [ObjectArgBlock block_hookWithMode:BlockHookModeBefore usingBlock:^(BHInvocation *invocation, <span class="built_in">NSObject</span> *test)&#123;</span><br><span class="line">        <span class="built_in">NSAssert</span>(test == argOrig, <span class="string">@"Wrong arg!"</span>);</span><br><span class="line">        <span class="comment">// Hook 改参数</span></span><br><span class="line">        [invocation setArgument:(<span class="keyword">void</span> *)&amp;argFixed atIndex:<span class="number">1</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    ObjectArgBlock(argOrig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最初 <code>BHInvocation</code> 还不够完善时，读写 Block 的参数/返回值只能用二级指针之类的晦涩语法直接操作 <code>args</code> 和 <code>retValue</code>，门槛较高而且还不够安全。<code>BHInvocation</code> 接口设计和实现上尽量参考已有的成熟案例，降低开发者学习成本，快速上手。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2019/07/27/BlockHook-with-Invocation/&quot;&gt;上一篇文章&lt;/a&gt; 简单介绍了下 &lt;code&gt;retainArguments&lt;/code&gt; 和 &lt;code&gt;block_interceptor&lt;/code&gt; 实现的思路，本文会详细讲解下 &lt;code&gt;BHInvocation&lt;/code&gt; 的接口设计与实现，并与系统的 &lt;code&gt;NSInvocation&lt;/code&gt; 作对比。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yulingtianxia.com/tags/Objective-C/"/>
    
      <category term="Runtime" scheme="http://yulingtianxia.com/tags/Runtime/"/>
    
      <category term="BlockHook" scheme="http://yulingtianxia.com/tags/BlockHook/"/>
    
  </entry>
  
  <entry>
    <title>BlockHook with Invocation(1)</title>
    <link href="http://yulingtianxia.com/blog/2019/07/27/BlockHook-with-Invocation/"/>
    <id>http://yulingtianxia.com/blog/2019/07/27/BlockHook-with-Invocation/</id>
    <published>2019-07-27T09:14:27.000Z</published>
    <updated>2019-08-11T14:20:22.195Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 在业界已经率先解决了在<strong>同步</strong>调用场景下对 Objective-C Block 的 AOP 问题。但也有很多场景是需要先调用一段自己的逻辑，然后再<strong>异步延时</strong>执行 Block。</p><p>比如从外部跳转到 App 某个页面前需要检查下登录态，如果未登录则需要走完登录流程后才能继续跳转页面，而几乎所有基于 Block callback 的路由组件都没提供路由拦截器的功能。不同的路由组件内部实现不同，想要实现拦截器就需要针对不同的内部实现来修改路由组件源码。</p><p>因此我实现了 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 的异步拦截功能，所有基于 Block 的路由组件就都有了通用的路由拦截器！</p><p>当然，Block 拦截器的应用场景不仅于此。只要是需要『同步改异步执行』 Block 的场景都可以用到。</p><p>让子弹再飞一会儿！</p><a id="more"></a><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p><a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 拦截器用法很简单，在已有 <code>BHInvocation</code> 参数的基础上，增加了一个 <code>completion</code> 回调。当拦截器的逻辑异步执行完后，调用 <code>completion</code> 即可继续执行原来的 Block。如果拦截器的逻辑是同步的，也依然可以用这个接口，只是没必要罢了，推荐直接用原来的 <code>block_hookWithMode:usingBlock:</code> 接口。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^IntercepterCompletion)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Interceptor for blocks. When your interceptor completed, call `completion` callback.</span></span><br><span class="line"><span class="comment"> You can call `completion` asynchronously!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param interceptor You **MUST** call `completion` callback in interceptor, unless you want to cancel invocation.</span></span><br><span class="line"><span class="comment"> @return BHToken instance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (BHToken *)block_interceptor:(<span class="keyword">void</span> (^)(BHInvocation *invocation, IntercepterCompletion completion))interceptor;</span><br></pre></td></tr></table></figure><p>举个例子，拦截时修改传入的参数，并延迟 0.5 秒再执行 Block：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *testArg = [<span class="built_in">NSObject</span> new];</span><br><span class="line"><span class="built_in">NSObject</span> *testArg1 = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSObject</span> *(^testblock)(<span class="built_in">NSObject</span> *) = ^(<span class="built_in">NSObject</span> *a) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSObject</span> new];</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">[testblock block_interceptor:^(BHInvocation *invocation, IntercepterCompletion  _Nonnull completion) &#123;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">0.5</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        *(<span class="keyword">void</span> **)(invocation.args[<span class="number">1</span>]) = (__bridge <span class="keyword">void</span> *)(testArg1);</span><br><span class="line">        completion();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">testblock(testArg);</span><br></pre></td></tr></table></figure><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>首先想想如果要延迟一个 Objective-C 方法的执行，需要怎么做？</p><p>答案是利用消息转发机制，<code>NSInvocation</code> 调用 <code>retainArguments</code> 将方法执行所需的上下文持有，这样才能保证方法执行时所需的参数、<code>target</code> 等不会被释放。</p><p>对于 Block 来说，虽然也能通过 <code>NSInvocation</code> 来进行调用，但是经过 Hook 过后已经不再适用。因为 <code>NSInvocation</code> 的实现机制以及生命周期管理是个黑盒，且无法承载 Hook 相关的信息，需要自己来实现个 <code>BHInvocation</code>。</p><p><img src="https://github.com/yulingtianxia/Blog-Hexo-Source/blob/master/source/resources/BlockHook/BlockInterceptor.png?raw=true" alt></p><h3 id="BHInvocation-结构"><a href="#BHInvocation-结构" class="headerlink" title="BHInvocation 结构"></a>BHInvocation 结构</h3><p>我之前的 <a href="http://yulingtianxia.com/blog/2019/04/27/BlockHook-with-Struct/">BlockHook with Struct</a> 这篇文章提到了个技术点：在 x86 架构下，当 Block 返回值是大于 16 Byte 的 <code>struct</code> 时，参数列表有些变化：</p><p><img src="https://github.com/yulingtianxia/Blog-Hexo-Source/blob/master/source/resources/BlockHook/realArgs.png?raw=true" alt></p><p>为了兼容这种情况，需要两套 <code>args</code> 和 <code>retValue</code>。一套『真的』用于传给 libffi 调用原始函数指针，另一套『假的』提供给使用方读写参数和返回值。这样使用方无需关心底层特殊逻辑，直接用就行了。</p><p><code>BHInvocation</code> 主要结构如下：</p><p><img src="https://github.com/yulingtianxia/Blog-Hexo-Source/blob/master/source/resources/BlockHook/BHInvocation.png?raw=true" alt></p><p>PS：<code>BHInvocation</code> 与 <code>NSInvocation</code> 的场景和用法有些不同，所以实现上也会有差异。<code>NSInvocation</code> 没有公开源码，想了解原理的可以看看 mikeash 的实现： <a href="https://github.com/mikeash/MAInvocation" target="_blank" rel="noopener">MAInvocation</a>。但我并没有参考过 mikeash 的源码，因为等我写完了才发现它。。。</p><h3 id="retainArguments-实现"><a href="#retainArguments-实现" class="headerlink" title="retainArguments 实现"></a><code>retainArguments</code> 实现</h3><p><code>retainArguments</code> 实现策略：</p><ol><li>拷贝 <code>void **args</code> 指针数组和返回值指针</li><li><code>retain</code> 指针内容类型为 Objective-C 对象的参数</li><li>如果参数中也有其他 Block 对象，则 <code>copy</code> 过来</li><li>如果参数中有 C-string，则 <code>strcpy</code> 过来</li></ol><p><img src="https://github.com/yulingtianxia/Blog-Hexo-Source/blob/master/source/resources/BlockHook/retainArguments.png?raw=true" alt></p><p>需要注意的是这里依然要考虑两套 <code>args</code> 和 <code>retValue</code> 的问题。代码就不贴了，有兴趣的可以自己去看。</p><h3 id="block-interceptor-实现"><a href="#block-interceptor-实现" class="headerlink" title="block_interceptor 实现"></a><code>block_interceptor</code> 实现</h3><p>解决了 <code>retainArguments</code> 的实现，一切都好说了。只要基于原有的 <code>block_hookWithMode:usingBlock:</code> 接口稍加改装即可：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">BHToken </span>*)<span class="keyword">block_interceptor:(void </span>(^)(<span class="keyword">BHInvocation </span>*invocation, IntercepterCompletion completion))interceptor &#123;</span><br><span class="line">    return [self <span class="keyword">block_hookWithMode:BlockHookModeInstead </span>usingBlock:^(<span class="keyword">BHInvocation </span>*invocation) &#123;</span><br><span class="line">        if (interceptor) &#123;</span><br><span class="line">            IntercepterCompletion completion = ^() &#123;</span><br><span class="line">                [invocation invokeOriginalBlock]<span class="comment">;</span></span><br><span class="line">            &#125;<span class="comment">;</span></span><br><span class="line">            interceptor(invocation, completion)<span class="comment">;</span></span><br><span class="line">            [invocation retainArguments]<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>写了这么多关于 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 的文章，我越来越发现自己在苹果爸爸面前所表现出的无知。几乎每一步都要去踩很多坑，看很多源码。而这次是看着苹果爸爸的文档脑补如何实现，业界也没有能参考的先例。</p><p>这种感觉犹如自己在黑暗中不断探索，并享受着这种孤独。</p><p>标题暗示着，这篇文章可能会有后续的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BlockHook&lt;/a&gt; 在业界已经率先解决了在&lt;strong&gt;同步&lt;/strong&gt;调用场景下对 Objective-C Block 的 AOP 问题。但也有很多场景是需要先调用一段自己的逻辑，然后再&lt;strong&gt;异步延时&lt;/strong&gt;执行 Block。&lt;/p&gt;
&lt;p&gt;比如从外部跳转到 App 某个页面前需要检查下登录态，如果未登录则需要走完登录流程后才能继续跳转页面，而几乎所有基于 Block callback 的路由组件都没提供路由拦截器的功能。不同的路由组件内部实现不同，想要实现拦截器就需要针对不同的内部实现来修改路由组件源码。&lt;/p&gt;
&lt;p&gt;因此我实现了 &lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BlockHook&lt;/a&gt; 的异步拦截功能，所有基于 Block 的路由组件就都有了通用的路由拦截器！&lt;/p&gt;
&lt;p&gt;当然，Block 拦截器的应用场景不仅于此。只要是需要『同步改异步执行』 Block 的场景都可以用到。&lt;/p&gt;
&lt;p&gt;让子弹再飞一会儿！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yulingtianxia.com/tags/Objective-C/"/>
    
      <category term="Runtime" scheme="http://yulingtianxia.com/tags/Runtime/"/>
    
      <category term="BlockHook" scheme="http://yulingtianxia.com/tags/BlockHook/"/>
    
  </entry>
  
  <entry>
    <title>BlockHook with Private Data</title>
    <link href="http://yulingtianxia.com/blog/2019/06/19/BlockHook-with-Private-Data/"/>
    <id>http://yulingtianxia.com/blog/2019/06/19/BlockHook-with-Private-Data/</id>
    <published>2019-06-19T14:50:39.000Z</published>
    <updated>2019-08-11T14:20:45.384Z</updated>
    
    <content type="html"><![CDATA[<p>在使用 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> Hook 所有 Block 对象时，发现有些 Block 被 Hook 后会 Crash。究其原因发现是它们骨骼惊奇，夹带了很多『私货』，不能直接 Hook！本文讲述 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 在处理这种 Block 时的技术原理，解开含有 Private Data 的 Block 的神秘面纱。</p><a id="more"></a><p>由于关于 Block Private Data 的资料几乎没有，所以我完全可以当回标题党，把这篇文章的标题叫做『你真的了解 Block 么？』或者『这才是 Hook Block 的正确姿势』之类的。但想想还是算了吧，怕被大佬们嘲笑称又『改变业界』了啊。</p><h2 id="Block-为何会有-Private-Data"><a href="#Block-为何会有-Private-Data" class="headerlink" title="Block 为何会有 Private Data"></a>Block 为何会有 Private Data</h2><p>首先来看一段代码：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_block_t </span><span class="keyword">block </span>= <span class="keyword">dispatch_block_create(0, </span>^&#123;</span><br><span class="line">    NSLog(@<span class="string">"I'm dispatch_block_t"</span>)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>用 <code>dispatch_block_create</code> 创建的 Block 都很特殊，返回的 Block 包含了参数里传入的 Block。此时 <code>dispatch_block_t</code> 虽然表面上是一种普通的 Block，但它的构造暗藏玄机，含有 Private Data，下面会详细解读。</p><h3 id="特殊的-invoke-函数"><a href="#特殊的-invoke-函数" class="headerlink" title="特殊的 invoke 函数"></a>特殊的 invoke 函数</h3><p>这种 Block 的 <code>invoke</code> 函数指针是固定的，函数名为 <code>___dispatch_block_create_block_invoke</code>。在 linux 系统下，函数名为 <code>__dispatch_block_create_block_invoke</code>，嗯少了个下划线。这个函数的定义来自 libdispatch.dylib，也就是我们常用的 GCD。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="comment">// The compiler hides the name of the function it generates, and changes it if</span></span><br><span class="line"><span class="comment">// we try to reference it directly, but the linker still sees it.</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">DISPATCH_BLOCK_SPECIAL_INVOKE</span><span class="params">(<span class="keyword">void</span> *)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></span></span><br><span class="line"><span class="function"><span class="title">asm</span><span class="params">(<span class="string">"___dispatch_block_create_block_invoke"</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">asm</span>(<span class="string">"____dispatch_block_create_block_invoke"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">void</span> (*<span class="keyword">const</span> _dispatch_block_special_invoke)(<span class="keyword">void</span>*) = DISPATCH_BLOCK_SPECIAL_INVOKE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>libdispatch 会通过判断 Block 的 <code>invoke</code> 指针是否为 <code>_dispatch_block_special_invoke</code>，来知道这个 Block 是否含有 Private Data。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span></span><br><span class="line">_dispatch_block_has_private_data(<span class="keyword">const</span> <span class="keyword">dispatch_block_t</span> block)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (_dispatch_Block_invoke(block) == _dispatch_block_special_invoke);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不幸的是，<code>_dispatch_block_special_invoke</code> 是私有的。在非调试场景下是无法通过 <code>dladdr</code> 等方式来获取它的函数名的。也就无法用类似上面的代码来判断 Block 是否含有 Private Data 了。</p><h3 id="获取-Private-Data"><a href="#获取-Private-Data" class="headerlink" title="获取 Private Data"></a>获取 Private Data</h3><p>使用 <code>dispatch_block_create</code> 创建的 <code>dispatch_block_t</code> 只是个『壳』，真正执行的是其内部包含的 Block。再加上 GCD 所需的一些数据（queue，group，thread，priority 等），这些数据都需要作为 Private Data 追加在 Block 上。对实现 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 来说最需要关注的就是 <code>dbpd_magic</code> 和 <code>dbpd_block</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">OS_OBJECT_DECL_CLASS(voucher);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_block_private_data_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> dbpd_magic;</span><br><span class="line">    <span class="keyword">dispatch_block_flags_t</span> dbpd_flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">volatile</span> dbpd_atomic_flags;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">volatile</span> dbpd_performed;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> dbpd_priority;</span><br><span class="line">    <span class="keyword">voucher_t</span> dbpd_voucher;</span><br><span class="line">    <span class="keyword">dispatch_block_t</span> dbpd_block;</span><br><span class="line">    <span class="keyword">dispatch_group_t</span> dbpd_group;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> dbpd_queue;</span><br><span class="line">    <span class="keyword">mach_port_t</span> dbpd_thread;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_block_private_data_s</span> *<span class="title">dispatch_block_private_data_t</span>;</span></span><br></pre></td></tr></table></figure><p>既然无法用 <code>_dispatch_block_special_invoke</code> 来判断 Block 是否含有 Private Data，可以使用 <code>dbpd_magic</code> 魔数来判断。当其值为 <code>0xD159B10C</code> 时（DisBloc 的意思），则表明含有 Private Data。<strong>当然这种溢出的方式同样是有风险的，但触及到 PAGEZERO 概率很低</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_BLOCK_PRIVATE_DATA_MAGIC 0xD159B10C <span class="comment">// 0xDISPatch_BLOCk</span></span></span><br><span class="line"></span><br><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">dispatch_block_private_data_t</span></span><br><span class="line">bh_dispatch_block_get_private_data(struct _BHBlock *block)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Keep in sync with _dispatch_block_create implementation</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *x = (<span class="keyword">uint8_t</span> *)block;</span><br><span class="line">    <span class="comment">// x points to base of struct Block_layout</span></span><br><span class="line">    x += <span class="keyword">sizeof</span>(struct _BHBlock);</span><br><span class="line">    <span class="comment">// x points to base of captured dispatch_block_private_data_s object</span></span><br><span class="line">    <span class="keyword">dispatch_block_private_data_t</span> dbpd = (<span class="keyword">dispatch_block_private_data_t</span>)x;</span><br><span class="line">    <span class="keyword">if</span> (dbpd-&gt;dbpd_magic != DISPATCH_BLOCK_PRIVATE_DATA_MAGIC) &#123;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dbpd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后真正执行的其实是 <code>dbpd_block</code> 这个 Block，<code>dispatch_block_t</code> 只是个保存各种元数据的壳。</p><h2 id="适配-BlockHook"><a href="#适配-BlockHook" class="headerlink" title="适配 BlockHook"></a>适配 BlockHook</h2><p>虽然说 Private Data 本身并不是 Block 实现中必要的一环，它只是 GCD 对 Block 数据结构的一种『魔改』扩充。但由于 GCD 内部的一些保护机制，会在修改了 Block 的 <code>invoke</code> 指针后触发 crash（<code>__builtin_trap</code>），所以不能直接对含有 Private Data 的 Block 进行 Hook。这就需要 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 组件做一些适配工作。</p><h3 id="Hook-真正要执行的-Block"><a href="#Hook-真正要执行的-Block" class="headerlink" title="Hook 真正要执行的 Block"></a>Hook 真正要执行的 Block</h3><p>既然 <code>dbpd_block</code> 才是真正要执行的 Block，那么 Hook 的时候需要先获取 Private Data，然后对其 <code>dbpd_block</code> 进行 Hook:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (BHToken *)block_hookWithMode:(BlockHookMode)mode</span><br><span class="line">                     usingBlock:(<span class="keyword">id</span>)aspectBlock</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!aspectBlock || ![<span class="keyword">self</span> block_checkValid]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> _BHBlock *bh_block = (__bridge <span class="keyword">void</span> *)<span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">if</span> (!_bh_Block_descriptor_3(bh_block)) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Block has no signature! Required ABI.2010.3.16. %@"</span>, <span class="keyword">self</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Handle blocks have private data.</span></span><br><span class="line">    dispatch_block_private_data_t dbpd = bh_dispatch_block_get_private_data(bh_block);</span><br><span class="line">    <span class="keyword">if</span> (dbpd &amp;&amp; dbpd-&gt;dbpd_block) &#123;</span><br><span class="line">        <span class="keyword">return</span> [dbpd-&gt;dbpd_block block_hookWithMode:mode usingBlock:aspectBlock];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [[BHToken alloc] initWithBlock:<span class="keyword">self</span> mode:mode aspectBlockBlock:aspectBlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取-Block-当前-Hook-Token"><a href="#获取-Block-当前-Hook-Token" class="headerlink" title="获取 Block 当前 Hook Token"></a>获取 Block 当前 Hook Token</h3><p>因为 Hook 的是 <code>dbpd_block</code>，所以获取 Token 的时候也需要额外处理下。要在 <code>dbpd_block</code> 上通过 AssociatedObject 来获取 Token，而不是 <code>dispatch_block_t</code> 上。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">BHToken </span>*)<span class="keyword">block_currentHookToken</span></span><br><span class="line"><span class="keyword">&#123;</span></span><br><span class="line"><span class="keyword"> </span>   <span class="meta">if</span> (![<span class="keyword">self </span><span class="keyword">block_checkValid]) </span>&#123;</span><br><span class="line">        return nil<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_block_private_data_t dbpd = <span class="keyword">bh_dispatch_block_get_private_data((__bridge </span><span class="keyword">struct </span>_BHBlock *)(<span class="keyword">self));</span></span><br><span class="line"><span class="keyword"> </span>   <span class="meta">if</span> (dbpd &amp;&amp; dbpd-&gt;dbpd_block) &#123;</span><br><span class="line">        return [dbpd-&gt;dbpd_block <span class="keyword">block_currentHookToken];</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line">    void *invoke = [<span class="keyword">self </span><span class="keyword">block_currentInvokeFunction];</span></span><br><span class="line"><span class="keyword"> </span>   return objc_getAssociatedObject(<span class="keyword">self, </span>invoke)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代码地址: <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">https://github.com/yulingtianxia/BlockHook</a></p><p>一图以蔽之。</p><p><img src="https://github.com/yulingtianxia/Blog-Hexo-Source/blob/master/source/resources/BlockHook/BlockHook%20PrivateData.png?raw=true" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用 &lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BlockHook&lt;/a&gt; Hook 所有 Block 对象时，发现有些 Block 被 Hook 后会 Crash。究其原因发现是它们骨骼惊奇，夹带了很多『私货』，不能直接 Hook！本文讲述 &lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BlockHook&lt;/a&gt; 在处理这种 Block 时的技术原理，解开含有 Private Data 的 Block 的神秘面纱。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yulingtianxia.com/tags/Objective-C/"/>
    
      <category term="Runtime" scheme="http://yulingtianxia.com/tags/Runtime/"/>
    
      <category term="BlockHook" scheme="http://yulingtianxia.com/tags/BlockHook/"/>
    
  </entry>
  
  <entry>
    <title>BlockHook with Revocation</title>
    <link href="http://yulingtianxia.com/blog/2019/05/26/BlockHook-with-Revocation/"/>
    <id>http://yulingtianxia.com/blog/2019/05/26/BlockHook-with-Revocation/</id>
    <published>2019-05-26T09:20:10.000Z</published>
    <updated>2019-08-11T14:21:07.747Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 开创性地解决了 Objective-C 语言界 Hook Block 的问题，但也迎来了新的问题：</p><ol><li>如何知道某个 Block 对象被谁 Hook 过？</li><li>多次 Hook 的先后顺序？</li><li>如何处理好多次 Hook 同一个 Block 后对任意一次 Hook 的撤销？</li></ol><p>这些问题也是开发者在使用时向我反馈过的问题，在这篇文章里，这些问题都将会解决。</p><p>关于 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 的原理，可以先阅读之前的文章：</p><ul><li><a href="http://yulingtianxia.com/blog/2018/02/28/Hook-Objective-C-Block-with-Libffi/">Hook Objective-C Block with Libffi</a></li><li><a href="http://yulingtianxia.com/blog/2019/04/27/BlockHook-with-Struct/">BlockHook with Struct</a></li></ul><a id="more"></a><h2 id="按顺序构造『虚拟的』-Hook-链表"><a href="#按顺序构造『虚拟的』-Hook-链表" class="headerlink" title="按顺序构造『虚拟的』 Hook 链表"></a>按顺序构造『虚拟的』 Hook 链表</h2><p>首先要有一个链表来按先后顺序记录一个 Block 对象上所有的 Hook。这个链表的格式以及持有关系也需要考虑在内。</p><p>为此我构造了一个虚拟的链表来记录 Hook 的先后关系，而不是单独创建一个链表显式的记录。首先介绍下 Block 与 token 之间的引用关系：</p><p><img src="https://raw.githubusercontent.com/yulingtianxia/Blog-Hexo-Source/master/source/resources/BlockHook/BlockHook_Token_List.png" alt></p><p>可以看出每个 <code>BHToken</code> 记录了原始和替换后的 <code>invoke</code> 函数指针，那么先后两次 Hook 就靠 <code>invoke</code> 函数指针来关联了：<strong>每个 tokne 的 <code>originalInvoke</code> 就是上一次 Hook 的 token 的 <code>replacementInvoke</code></strong>。而拿到 token 又是靠 Block 对象上的 <code>AssociatedObject</code>，且 key 为 <code>replacementInvoke</code>。这样就构造了一条虚拟的链表：想要获得上次 Hook 的 token，只需在 Hook 的 Block 对象上使用 <code>originalInvoke</code> 作为 key 即可。</p><p>下面的代码展示了获取下个 token 的 <code>next</code> 实现。因为链表可能会有新的插入和删除节点操作，所以需确保线程安全。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">BHToken </span>*)next</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">BHLock </span>*lock = [self.<span class="keyword">block </span><span class="keyword">bh_lockForKey:@selector(next)];</span></span><br><span class="line"><span class="keyword"> </span>   [lock lock]<span class="comment">;</span></span><br><span class="line">    if (!_next) &#123;</span><br><span class="line">        _next = objc_getAssociatedObject(self.<span class="keyword">block, </span>self.<span class="keyword">originInvoke);</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line">    <span class="keyword">BHToken </span>*result = _next<span class="comment">;</span></span><br><span class="line">    [lock unlock]<span class="comment">;</span></span><br><span class="line">    return result<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用 <code>replacementInvoke</code> 来作为 <code>AssociatedObject</code> 的 key 真是<strong>一举多得</strong>：</p><ol><li>将 token 的生命周期绑定到 Block 对象上，实现 self-managed</li><li>因为函数指针地址是唯一的，确保 Block 上关联每个 token 的 key 不会冲突</li><li>Block 的 <code>invoke</code> 指针作为 key，可以找到最后一次 Hook 的 token。进而按 Hook 先后顺序遍历出所有的 token。</li></ol><p>下面的代码展示了如何获取最后一次 Hook 的 token。在读取 <code>invoke</code> 函数指针的时候，注意保证线程安全。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">BHToken </span>*)<span class="keyword">block_currentHookToken</span></span><br><span class="line"><span class="keyword">&#123;</span></span><br><span class="line"><span class="keyword"> </span>   <span class="meta">if</span> (![<span class="keyword">self </span><span class="keyword">block_checkValid]) </span>&#123;</span><br><span class="line">        return nil<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    void *invoke = [<span class="keyword">self </span><span class="keyword">block_currentInvokeFunction];</span></span><br><span class="line"><span class="keyword"> </span>   return objc_getAssociatedObject(<span class="keyword">self, </span>invoke)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void *)<span class="keyword">block_currentInvokeFunction</span></span><br><span class="line"><span class="keyword">&#123;</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">struct </span>_BHBlock *<span class="keyword">bh_block </span>= (__bridge void *)<span class="keyword">self;</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">BHLock </span>*lock = [<span class="keyword">self </span><span class="keyword">bh_lockForKey:_cmd];</span></span><br><span class="line"><span class="keyword"> </span>   [lock lock]<span class="comment">;</span></span><br><span class="line">    void *invoke = <span class="keyword">bh_block-&gt;invoke;</span></span><br><span class="line"><span class="keyword"> </span>   [lock unlock]<span class="comment">;</span></span><br><span class="line">    return invoke<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="撤销-Hook"><a href="#撤销-Hook" class="headerlink" title="撤销 Hook"></a>撤销 Hook</h2><p>俗话说『请神容易送神难』。好多 Hook 框架只解决的如何 Hook，但是却无法撤销恢复原样，留下一堆烂摊子。</p><p>在搭建了 Hook 链表的基础上，多次 Hook 的链表可以简化成 <code>invoke</code> 函数指针之间的关系：</p><p><img src="https://raw.githubusercontent.com/yulingtianxia/Blog-Hexo-Source/master/source/resources/BlockHook/BlockHook_invoke_call.png" alt></p><p>那么撤销 Hook 就可以从链表头部开始遍历，找到当前要 <code>remove</code> 的 token。接着链表上删除这个 token，而这又可以分为两个子问题：</p><ol><li>移除最后一次 Hook：需要将 Block 的 <code>invoke</code> 指针指向 token 的 <code>originalInvoke</code>。</li><li>移除<em>非</em>最后一次 Hook：需要将上一次 Hook token 的 <code>originalInvoke</code> 指向当前 token 的 <code>originalInvoke</code>。</li></ol><p>最后肯定还要解除 Block 对象对 token 的持有。</p><p>这部分逻辑的实现代码如下，在操作 Block 的 <code>invoke</code> 指针时依然需要注意线程安全问题：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)remove</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isStackBlock) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Can't remove token for StackBlock!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.deadBlock = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.originInvoke) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.block) &#123;</span><br><span class="line">            BHToken *current = [<span class="keyword">self</span>.block block_currentHookToken];</span><br><span class="line">            BHToken *last = <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">while</span> (current) &#123;</span><br><span class="line">                <span class="keyword">if</span> (current == <span class="keyword">self</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (last) &#123; <span class="comment">// remove middle token</span></span><br><span class="line">                        last.originInvoke = <span class="keyword">self</span>.originInvoke;</span><br><span class="line">                        last.next = <span class="literal">nil</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// remove head(current) token</span></span><br><span class="line">                        BHLock *lock = [<span class="keyword">self</span>.block bh_lockForKey:<span class="keyword">@selector</span>(block_currentInvokeFunction)];</span><br><span class="line">                        [lock lock];</span><br><span class="line">                        ((__bridge <span class="keyword">struct</span> _BHBlock *)<span class="keyword">self</span>.block)-&gt;invoke = <span class="keyword">self</span>.originInvoke;</span><br><span class="line">                        [lock unlock];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                last = current;</span><br><span class="line">                current = [current next];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.originInvoke = <span class="literal">NULL</span>;</span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>.block, _replacementInvoke, <span class="literal">nil</span>, OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 还在不断完善每一个细节，尽可能做到有始有终，至善尽美。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BlockHook&lt;/a&gt; 开创性地解决了 Objective-C 语言界 Hook Block 的问题，但也迎来了新的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何知道某个 Block 对象被谁 Hook 过？&lt;/li&gt;
&lt;li&gt;多次 Hook 的先后顺序？&lt;/li&gt;
&lt;li&gt;如何处理好多次 Hook 同一个 Block 后对任意一次 Hook 的撤销？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些问题也是开发者在使用时向我反馈过的问题，在这篇文章里，这些问题都将会解决。&lt;/p&gt;
&lt;p&gt;关于 &lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BlockHook&lt;/a&gt; 的原理，可以先阅读之前的文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2018/02/28/Hook-Objective-C-Block-with-Libffi/&quot;&gt;Hook Objective-C Block with Libffi&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2019/04/27/BlockHook-with-Struct/&quot;&gt;BlockHook with Struct&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yulingtianxia.com/tags/Objective-C/"/>
    
      <category term="BlockHook" scheme="http://yulingtianxia.com/tags/BlockHook/"/>
    
  </entry>
  
  <entry>
    <title>BlockHook with Struct</title>
    <link href="http://yulingtianxia.com/blog/2019/04/27/BlockHook-with-Struct/"/>
    <id>http://yulingtianxia.com/blog/2019/04/27/BlockHook-with-Struct/</id>
    <published>2019-04-27T13:26:55.000Z</published>
    <updated>2019-08-11T14:21:21.285Z</updated>
    
    <content type="html"><![CDATA[<p>一年前，我开发了 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a>，（应该是）填补了 Objective-C 业界在 Hook Block 技术领域的空白。但是对于 Block 的参数和返回值有限制，仅定制了 <code>CGRect</code>, <code>CGSize</code>, <code>CGPoint</code> 等结构体，不支持自定义 struct。这次就把这个坑给填上。</p><p>至此，<a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 已支持 macOS 和 iOS 平台全架构、tvOS 和 watchOS 模拟器，<code>BlockHook.m</code> 测试覆盖率达到 92% 以上。</p><a id="more"></a><p>关于 <a href="https://github.com/yulingtianxia/BlockHook" target="_blank" rel="noopener">BlockHook</a> 的实现原理，可以先阅读 <a href="http://yulingtianxia.com/blog/2018/02/28/Hook-Objective-C-Block-with-Libffi/">Hook Objective-C Block with Libffi</a>。</p><h2 id="Struct-Encode"><a href="#Struct-Encode" class="headerlink" title="Struct Encode"></a>Struct Encode</h2><p>要想解析自定义结构体的类型，并转换为 <code>ffi_type</code>，首先要从 Block 的 signature 入手。从中提取出 struct 的 encode，并继续解析其内容。</p><p>比如下面这个结构体，encode 是 “{TestStruct=idfc^i^{CGRect}}”。编码规则可以查看 <a href="https://nshipster.cn/type-encodings/" target="_blank" rel="noopener">Type Encodings</a>。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct TestStruct &#123;</span><br><span class="line">    int32_t a<span class="comment">;</span></span><br><span class="line">    double b<span class="comment">;</span></span><br><span class="line">    float c<span class="comment">;</span></span><br><span class="line">    char d<span class="comment">;</span></span><br><span class="line">    int *e<span class="comment">;</span></span><br><span class="line">    CGRect *f<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>基本可以把结构体当做基本类型的组合嵌套了，那么在原有解析方法的基础上，针对 “{name=type}” 这种范式来个递归遍历就行了。<code>_ffiTypeForStructEncode</code> 方法将截取 signature 字符串前面的 struct，并得到结构体的 <code>size</code>、 <code>alignment</code> 和 encode 长度 <code>length</code>。构建 <code>ffi_type</code>，并截取 <code>=</code> 后面的内容调用 <code>_typesWithEncodeString</code> 递归处理，得到结构体元素数组。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (ffi_type *)_ffiTypeForStructEncode:(const char *)<span class="keyword">str</span></span><br><span class="line"><span class="keyword">&#123;</span></span><br><span class="line"><span class="keyword"> </span>   NSUInteger size, <span class="meta">align</span><span class="comment">;</span></span><br><span class="line">    long length<span class="comment">;</span></span><br><span class="line">    <span class="keyword">BHSizeAndAlignment(str, </span>&amp;size, &amp;<span class="meta">align</span>, &amp;length)<span class="comment">;</span></span><br><span class="line">    ffi_type *<span class="keyword">structType </span>= [<span class="keyword">self </span>_allocate:size]<span class="comment">;</span></span><br><span class="line">    <span class="keyword">structType-&gt;type </span>= FFI_TYPE_STRUCT<span class="comment">;</span></span><br><span class="line">    <span class="keyword">structType-&gt;size </span>= size<span class="comment">;</span></span><br><span class="line">    <span class="keyword">structType-&gt;alignment </span>= <span class="meta">align</span><span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    const char *temp = [[[NSString <span class="keyword">stringWithUTF8String:str] </span><span class="keyword">substringWithRange:NSMakeRange(0, </span>length)] UTF8String]<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    // cut <span class="string">"struct="</span></span><br><span class="line">    <span class="meta">while</span> (temp &amp;&amp; *temp &amp;&amp; *temp != <span class="string">'='</span>) &#123;</span><br><span class="line">        temp++<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ffi_type **elements = [<span class="keyword">self </span>_typesWithEncodeString:temp + <span class="number">1</span>]<span class="comment">;</span></span><br><span class="line">    <span class="keyword">structType-&gt;elements </span>= elements<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    return <span class="keyword">structType;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><p><code>BHSizeAndAlignment</code> 处理了字符串中的 encode，跳过了无用的 “}” 和数字。这里面的数字其实是内存地址偏移量。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *BHSizeAndAlignment(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="built_in">NSUInteger</span> *sizep, <span class="built_in">NSUInteger</span> *alignp, <span class="keyword">long</span> *lenp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">out</span> = <span class="built_in">NSGetSizeAndAlignment</span>(str, sizep, alignp);</span><br><span class="line">    <span class="keyword">if</span> (lenp) &#123;</span><br><span class="line">        *lenp = <span class="keyword">out</span> - str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*<span class="keyword">out</span> == <span class="string">'&#125;'</span>) &#123;</span><br><span class="line">        <span class="keyword">out</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(isdigit(*<span class="keyword">out</span>)) &#123;</span><br><span class="line">        <span class="keyword">out</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">out</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_ffiTypeForEncode</code> 方法中对 struct 的处理也得到了简化，只需调用 <code>_ffiTypeForStructEncode</code> 即可。经测试，struct 之间的嵌套都 OK。</p><h2 id="Return-Struct-on-x86"><a href="#Return-Struct-on-x86" class="headerlink" title="Return Struct on x86"></a>Return Struct on x86</h2><p>在 x86 架构下，当 Block 返回值是大于 16 Byte 的 struct 时，其实现函数 <code>invoke</code> 的参数列表会发生变化：第一个参数不再是 Block 对象自己，而是指向 struct 返回值的指针。其余参数依次往后挪一位。Block 结构中 <code>flags</code> 里有一个 bit 标记了这个『潜规则』：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">BLOCK_HAS_STRET</span> =         (<span class="number">1</span> &lt;&lt; <span class="number">29</span>)</span><br></pre></td></tr></table></figure><p>那么在使用 libffi 定义 Hook 函数的返回值和参数列表的时候就需要注意了，虽然 signature 还是正常的，但是参数列表顺序调整了啊！当 <code>BLOCK_HAS_STRET</code> 生效时，得特殊处理下。<code>_typesWithEncodeString</code> 方法负责解析 signature 字符串中的 Type Encoding 列表，支持加偏移量。而 <code>_argsWithEncodeString</code> 是调用了前者，<code>startIndex</code> 传入 <code>1</code>，略过了第一个返回值。</p><p><img src="https://github.com/yulingtianxia/Blog-Hexo-Source/blob/master/source/resources/BlockHook/realArgs.png?raw=true" alt></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int argCount<span class="comment">;</span></span><br><span class="line">ffi_type **argTypes<span class="comment">;</span></span><br><span class="line">ffi_type *returnType<span class="comment">;</span></span><br><span class="line">struct _BHBlock *<span class="keyword">bh_block </span>= (__bridge void *)self.<span class="keyword">block;</span></span><br><span class="line"><span class="keyword">if </span>((<span class="keyword">bh_block-&gt;flags </span>&amp; <span class="keyword">BLOCK_HAS_STRET)) </span>&#123;</span><br><span class="line">    argTypes = [self _typesWithEncodeString:str getCount:&amp;argCount startIndex:<span class="number">0</span>]<span class="comment">;</span></span><br><span class="line">    argTypes[<span class="number">0</span>] = &amp;ffi_type_pointer<span class="comment">;</span></span><br><span class="line">    returnType = &amp;ffi_type_void<span class="comment">;</span></span><br><span class="line">    self.stret = YES<span class="comment">;</span></span><br><span class="line">    NSLog(@<span class="string">"Block has stret!"</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    argTypes = [self _argsWithEncodeString:str getCount:&amp;argCount]<span class="comment">;</span></span><br><span class="line">    returnType = [self _ffiTypeForEncode:str]<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Hook 的处理函数 <code>BHFFIClosureFunc</code> 中，可以获取到 Block 调用时传入的参数。为了让使用方对 <code>BLOCK_HAS_STRET</code> 无感知，需要将参数和返回值『纠正』回正常的顺序，并通过 <code>BHToken</code> 提供给使用者。这样就实现了动态修改 Block 任意参数和返回值的功能。</p><p><code>args</code> 是个指针数组，其中第一个指针又是个指向结构体返回值指针的指针，而 <code>token.retValue</code> 本应该是指向结构体返回值的指针。虽然有点绕，但是不难懂。</p><p>然而真的调用 Block 原实现的时候，还是需要用真正的参数列表和范沪指，所以加了 <code>realRetValue</code> 和 <code>realArgs</code> 分开存储原始传入的 <code>args</code> 和 <code>ret</code>。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static void BHFFIClosureFunc(ffi_cif *cif, void *<span class="keyword">ret</span>, void **<span class="keyword">args</span>, void *userdata)</span><br><span class="line">&#123;</span><br><span class="line">    BHToken *<span class="keyword">token</span> = (__bridge BHToken *)(userdata);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">token</span>.hasStret) &#123;</span><br><span class="line">        <span class="comment">// The first arg contains address of a pointer of returned struct.</span></span><br><span class="line">        <span class="keyword">token</span>.retValue = *((void **)<span class="keyword">args</span>[0]);</span><br><span class="line">        <span class="comment">// Other args move backwards.</span></span><br><span class="line">        <span class="keyword">token</span>.<span class="keyword">args</span> = <span class="keyword">args</span> + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">token</span>.retValue = <span class="keyword">ret</span>;</span><br><span class="line">        <span class="keyword">token</span>.<span class="keyword">args</span> = <span class="keyword">args</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">token</span>.realRetValue = <span class="keyword">ret</span>;</span><br><span class="line">    <span class="keyword">token</span>.realArgs = <span class="keyword">args</span>;</span><br><span class="line">    <span class="keyword">if</span> (BlockHookModeBefore == <span class="keyword">token</span>.mode) &#123;</span><br><span class="line">        [<span class="keyword">token</span> invokeHookBlock];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(BlockHookModeInstead == <span class="keyword">token</span>.mode &amp;&amp; [<span class="keyword">token</span> invokeHookBlock])) &#123;</span><br><span class="line">        [<span class="keyword">token</span> invokeOriginalBlock];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (BlockHookModeAfter == <span class="keyword">token</span>.mode) &#123;</span><br><span class="line">        [<span class="keyword">token</span> invokeHookBlock];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">token</span>.retValue = NULL;</span><br><span class="line">    <span class="keyword">token</span>.<span class="keyword">args</span> = NULL;</span><br><span class="line">    <span class="keyword">token</span>.realRetValue = NULL;</span><br><span class="line">    <span class="keyword">token</span>.realArgs = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>在测试用例 <a href="https://github.com/yulingtianxia/BlockHook/blob/master/BlockHookSample%20iOSTests/BlockHookSample_iOSTests.m" target="_blank" rel="noopener">BlockHookSample_iOSTests.m</a> 文件中包含了一些常用的使用示例，还有一些诸如改 Block 参数和返回值的骚操作。大家如果在使用中发现任何问题，或者有新的诉求，欢迎来提 issue：<a href="https://github.com/yulingtianxia/BlockHook/issues" target="_blank" rel="noopener">https://github.com/yulingtianxia/BlockHook/issues</a></p><p>哎这个月实在没啥写的了，又水了一篇文章。<br>有的大佬都不怎么更新博客了，导致 iOS 业界水平停滞不前，进而导致我还是一如既往的菜。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一年前，我开发了 &lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BlockHook&lt;/a&gt;，（应该是）填补了 Objective-C 业界在 Hook Block 技术领域的空白。但是对于 Block 的参数和返回值有限制，仅定制了 &lt;code&gt;CGRect&lt;/code&gt;, &lt;code&gt;CGSize&lt;/code&gt;, &lt;code&gt;CGPoint&lt;/code&gt; 等结构体，不支持自定义 struct。这次就把这个坑给填上。&lt;/p&gt;
&lt;p&gt;至此，&lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BlockHook&lt;/a&gt; 已支持 macOS 和 iOS 平台全架构、tvOS 和 watchOS 模拟器，&lt;code&gt;BlockHook.m&lt;/code&gt; 测试覆盖率达到 92% 以上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yulingtianxia.com/tags/Objective-C/"/>
    
      <category term="BlockHook" scheme="http://yulingtianxia.com/tags/BlockHook/"/>
    
  </entry>
  
  <entry>
    <title>音频情绪识别</title>
    <link href="http://yulingtianxia.com/blog/2019/03/30/Audio-Emotion-Recognition/"/>
    <id>http://yulingtianxia.com/blog/2019/03/30/Audio-Emotion-Recognition/</id>
    <published>2019-03-30T13:30:46.000Z</published>
    <updated>2019-05-26T10:08:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>如何识别声音所蕴含的情绪呢？在大部分场景下，人声的情绪更有意义。可以先将人声转文字，再通过 NLP 分析语义情绪。不过人类语言博大精深，一句『卧槽』的不同语调和语境下会有很多种意义，真的是卧槽啊！</p><p>于是我从音频特征提取入手，将人声分类识别为八种情绪，实现了两个方案并都得到了测试集 70% 以上的准确率：</p><ol><li>使用 VGGish 网络做特征提取，输入自定义网络进行训练。</li><li>使用音频库导出一系列特征作为输入向量，自定义网络进行训练。</li></ol><p>Python 工程和 iOS Sample 开源在 GitHub 上了：<a href="https://github.com/yulingtianxia/AudioEmotion" target="_blank" rel="noopener">https://github.com/yulingtianxia/AudioEmotion</a></p><a id="more"></a><h2 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h2><p>在音频领域数据集上，Google 提供的 AudioSet 很有名，数据量大标签也多。但是跟人声和情感的关联并不大。这里使用了 RAVDESS 数据，音频数据包含了说话和唱歌两大类数据，找了 24 位演员录制出 “neutral calm happy sad angry fearful disgust surprised” 八种情感。</p><h2 id="Turicreate-Sound-Classifier"><a href="#Turicreate-Sound-Classifier" class="headerlink" title="Turicreate Sound Classifier"></a>Turicreate Sound Classifier</h2><p>苹果推出的机器学习框架 Turicreate 降低了门槛，即便没有相关经验也可以轻松上手。训练后的模型参数可以导出为 Core ML 所使用的 mlmodel 文件，更方便集成到苹果的平台上。刚发布的 5.4 版本新增了 Sound Classifier，这可用于声音情绪识别任务上。</p><p>Turicreate 的 Sound Classifier 实现分三个阶段：</p><ol><li>音频预处理：使用 Hamming 窗口对语音进行分帧，对每一帧做短时傅里叶变换，然后利用信号幅值计算声谱图。将声谱映射到 64 阶 mel 滤波器组中计算 mel 声谱。最后通过控制时长，输出一个 (96, 64) 的矩阵。</li><li>VGGish 特征提取：Google 训练好的 CNN，它是基于 VGG 的变种，可用于将声音提取成 128 维特征。Google 的 AudioSet 号称是声音届的 ImageNet，它所提供的数据类型就包含从 VGGish 提取的特征。而 VGGish 模型是使用 YouTube-8M 训练出来的。</li><li>使用自定义神经网络训练，最后一层的节点数与标签数一致。</li></ol><p>这里还需要了解一个音频处理领域的一个概念：梅尔倒谱系数（Mel-scale Frequency Cepstral Coefficients，简称 MFCC）是在 Mel 标度频率域提取出来的倒谱参数，Mel标度描述了人耳频率的非线性特性。网上关于 MFCC 的资料很多，还有很多基于它的优化算法。第一步音频预处理也用到了。</p><p>其实数据预处理和特征提取的结果是可以复用的，在第一个版本发布后已经进行了优化： <a href="https://github.com/apple/turicreate/commit/e9b7ac6cad5a28894815aa4c5c9282163b97775b" target="_blank" rel="noopener">Sound Classifier: Allow Reusing Deep Features</a></p><p>Turicreate 固然爽，但是还存在一些问题。接下来详细讲一下：</p><h3 id="加载音频文件"><a href="#加载音频文件" class="headerlink" title="加载音频文件"></a>加载音频文件</h3><p>Turicreate 的 <code>load_audio</code> 方法加载音频文件时，很多 wav 会报错: “ Incomplete wav chunk”。导致训练样本大大减少。</p><p>看了下源码，是使用 <code>scipy</code> 的 <code>wavfile</code> 库读 wav 文件的，将其替换成 <code>librosa</code> 就 OK 了。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span>, sample_rate = librosa.load(<span class="title">cur_file_path</span>, <span class="title">sr</span>=<span class="type">None</span>, <span class="title">res_type</span>='<span class="title">scipy'</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> = <span class="keyword">data</span> * 32768</span></span><br><span class="line"><span class="meta"># sample_rate, data = _wavfile.read(cur_file_path)</span></span><br></pre></td></tr></table></figure><p>之所以还需要把 <code>data</code> 乘 32768 是为了将 (-1, 1) 的浮点数转为 16bit 整数表示。这样保证替换加载音频文件的接口后，结果数据不会有影响。</p><p>这段代码来自于 <code>audio_analysis.py</code>，我已经将修改后的版本提交了。</p><h3 id="自定义神经网络"><a href="#自定义神经网络" class="headerlink" title="自定义神经网络"></a>自定义神经网络</h3><p>Turicreate 自定义的神经网络结构为两层 100 个节点使用 RELU 激活函数的全连接层，最后接一层 label 个数节点的 softmax。这样简单的结构在官方 Demo 的 “ESC-10” 数据分类任务上表现还 OK，但是在声音情感预测上效果并不是很好。</p><p>既然是基于 VGGish 做 fine-tune，那就直接改 Turicreate 源码吧，在 <code>sound_classifier.py</code> 文件里。主要是改神经网络定义和导出模型到 Core ML 的方法。</p><p>在原有的网络结构上，增加了全连接层数和 BN 层，并使用 Dropout 层减轻过拟合的情况。当然，网络结构可以不断调整来得到更加的效果。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def _build_custom_neural_network(num_inputs, num_labels):</span><br><span class="line">    <span class="keyword">from</span> mxnet.gluon import nn</span><br><span class="line">    net = nn.Sequential(<span class="attribute">prefix</span>=<span class="string">'custom_'</span>)</span><br><span class="line">    with net.name_scope():</span><br><span class="line">        net.<span class="builtin-name">add</span>(nn.Dense(512, <span class="attribute">in_units</span>=num_inputs, <span class="attribute">activation</span>=<span class="string">'relu'</span>, <span class="attribute">prefix</span>=<span class="string">'dense0_'</span>))</span><br><span class="line">        net.<span class="builtin-name">add</span>(nn.BatchNorm())</span><br><span class="line">        net.<span class="builtin-name">add</span>(nn.Dropout(0.5))</span><br><span class="line">        net.<span class="builtin-name">add</span>(nn.Dense(256, <span class="attribute">activation</span>=<span class="string">'relu'</span>, <span class="attribute">prefix</span>=<span class="string">'dense1_'</span>))</span><br><span class="line">        net.<span class="builtin-name">add</span>(nn.BatchNorm())</span><br><span class="line">        net.<span class="builtin-name">add</span>(nn.Dropout(0.5))</span><br><span class="line">        net.<span class="builtin-name">add</span>(nn.Dense(128, <span class="attribute">activation</span>=<span class="string">'relu'</span>, <span class="attribute">prefix</span>=<span class="string">'dense2_'</span>))</span><br><span class="line">        net.<span class="builtin-name">add</span>(nn.BatchNorm())</span><br><span class="line">        net.<span class="builtin-name">add</span>(nn.Dropout(0.5))</span><br><span class="line">        net.<span class="builtin-name">add</span>(nn.Dense(64, <span class="attribute">activation</span>=<span class="string">'relu'</span>, <span class="attribute">prefix</span>=<span class="string">'dense3_'</span>))</span><br><span class="line">        net.<span class="builtin-name">add</span>(nn.BatchNorm())</span><br><span class="line">        net.<span class="builtin-name">add</span>(nn.Dropout(0.5))</span><br><span class="line">        net.<span class="builtin-name">add</span>(nn.Dense(num_labels, <span class="attribute">prefix</span>=<span class="string">'dense4_'</span>))</span><br><span class="line">    return net</span><br></pre></td></tr></table></figure><p>由于增加了 BN 和 Dropout，所以在生成 Core ML 模型文件的时候，需要判断下层的类型。增加对 BN 层的支持，忽略 Dropout 层。这里构建 Core ML 所需网络描述的 <code>builder</code> 是 coremltools 的 <code>NeuralNetworkBuilder</code>。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">input_name, output_name = input_name, <span class="number">0</span></span><br><span class="line">import mxnet as _mx</span><br><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span>, cur_layer <span class="keyword">in</span> enumerate(self._custom_classifier):</span><br><span class="line">output_name = str(i)</span><br><span class="line"><span class="keyword">if</span> type(cur_layer) == _mx<span class="selector-class">.gluon</span><span class="selector-class">.nn</span><span class="selector-class">.basic_layers</span><span class="selector-class">.Dense</span>:</span><br><span class="line">    W = cur_layer<span class="selector-class">.weight</span><span class="selector-class">.data</span>(ctx).asnumpy()</span><br><span class="line">    nC, nB = W.shape</span><br><span class="line">    Wb = cur_layer<span class="selector-class">.bias</span><span class="selector-class">.data</span>(ctx).asnumpy()</span><br><span class="line"></span><br><span class="line">    builder.add_inner_product(name=<span class="string">'inner_product_'</span>+str(i),</span><br><span class="line">                              W=W,</span><br><span class="line">                              b=Wb,</span><br><span class="line">                              input_channels=nB,</span><br><span class="line">                              output_channels=nC,</span><br><span class="line">                              has_bias=True,</span><br><span class="line">                              input_name=input_name,</span><br><span class="line">                              output_name=<span class="string">'inner_product_'</span>+output_name)</span><br><span class="line">    <span class="keyword">if</span> cur_layer<span class="selector-class">.act</span>:</span><br><span class="line">        builder.add_activation(<span class="string">"activation"</span>+str(i), <span class="string">'RELU'</span>, <span class="string">'inner_product_'</span>+output_name, output_name)</span><br><span class="line">elif type(cur_layer) == _mx<span class="selector-class">.gluon</span><span class="selector-class">.nn</span><span class="selector-class">.basic_layers</span><span class="selector-class">.BatchNorm</span>:</span><br><span class="line">    zeros = _np.zeros(nC)</span><br><span class="line">    ones = _np.ones(nC)</span><br><span class="line">    builder.add_batchnorm(name=<span class="string">'bn_layer_'</span>+str(i),</span><br><span class="line">                          channels=nC,</span><br><span class="line">                          gamma=ones,</span><br><span class="line">                          beta=zeros,</span><br><span class="line">                          mean=zeros,</span><br><span class="line">                          variance=ones,</span><br><span class="line">                          input_name=input_name,</span><br><span class="line">                          output_name=output_name)</span><br><span class="line">elif type(cur_layer) == _mx<span class="selector-class">.gluon</span><span class="selector-class">.nn</span><span class="selector-class">.basic_layers</span><span class="selector-class">.Dropout</span>:</span><br><span class="line">    continue</span><br><span class="line">input_name = output_name</span><br><span class="line"></span><br><span class="line">last_output = builder<span class="selector-class">.spec</span><span class="selector-class">.neuralNetworkClassifier</span><span class="selector-class">.layers</span>[-<span class="number">1</span>]<span class="selector-class">.output</span>[<span class="number">0</span>]</span><br><span class="line">builder.add_softmax(<span class="string">'softmax'</span>, last_output, self.target)</span><br></pre></td></tr></table></figure><h3 id="部署到-Core-ML"><a href="#部署到-Core-ML" class="headerlink" title="部署到 Core ML"></a>部署到 Core ML</h3><p>虽然生成了 mlmodel 模型文件，但是模型文件不包含第一步预处理的算法。需要依赖官方提供的 <code>libAudioPreprocessing.dylib</code>，只支持 64 位。 在使用 Core ML 预测之前，需要将 wav 文件按照输入格式切割，官方给了实例代码，但是有 bug。建议使用我提供的 iOS Sample。</p><h2 id="Put-features-to-Keras"><a href="#Put-features-to-Keras" class="headerlink" title="Put features to Keras"></a>Put features to Keras</h2><p>在这个方案中，先是提取出音频文件的一系列特征组成一个 26 维向量，再输入自定义神经网络中进行训练。这些音频特征包括：chromagram、RMS、spectral centroid、spectral bandwidth、spectral rolloff、zero-crossing rate、MFCC。</p><p>将音频特征提取后，与文件名和 label 一起保存在一个 csv 文件中。这部分代码实现在 <code>extract_audio_feature.py</code> 里。</p><p>然后使用 Keras 搭建一个比较简单的神经网络进行训练，这部分的逻辑与 Turicreate 中第三步类似，实现代码在 <code>train_audio.py</code> 里。</p><p>此方案参照了一个音乐分类的 Python Book 代码：<a href="https://gist.github.com/parulnith/7f8c174e6ac099e86f0495d3d9a4c01e" target="_blank" rel="noopener">Music_genre_classification.ipynb</a></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://zh.wikipedia.org/wiki/梅尔频率倒谱系数" target="_blank" rel="noopener">梅尔频率倒谱系数</a></p><p><a href="https://research.google.com/audioset/download.html" target="_blank" rel="noopener">AudioSet</a></p><p><a href="https://github.com/tensorflow/models/tree/master/research/audioset" target="_blank" rel="noopener">Models for AudioSet: A Large Scale Dataset of Audio Events</a></p><p><a href="https://apple.github.io/turicreate/docs/userguide/sound_classifier/" target="_blank" rel="noopener">Sound Classifier</a></p><p><a href="https://zenodo.org/record/1188976" target="_blank" rel="noopener">The Ryerson Audio-Visual Database of Emotional Speech and Song (RAVDESS)</a></p><p><a href="https://towardsdatascience.com/music-genre-classification-with-python-c714d032f0d8" target="_blank" rel="noopener">Music Genre Classification with Python</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何识别声音所蕴含的情绪呢？在大部分场景下，人声的情绪更有意义。可以先将人声转文字，再通过 NLP 分析语义情绪。不过人类语言博大精深，一句『卧槽』的不同语调和语境下会有很多种意义，真的是卧槽啊！&lt;/p&gt;
&lt;p&gt;于是我从音频特征提取入手，将人声分类识别为八种情绪，实现了两个方案并都得到了测试集 70% 以上的准确率：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 VGGish 网络做特征提取，输入自定义网络进行训练。&lt;/li&gt;
&lt;li&gt;使用音频库导出一系列特征作为输入向量，自定义网络进行训练。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Python 工程和 iOS Sample 开源在 GitHub 上了：&lt;a href=&quot;https://github.com/yulingtianxia/AudioEmotion&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/yulingtianxia/AudioEmotion&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Machine Leaning" scheme="http://yulingtianxia.com/tags/Machine-Leaning/"/>
    
  </entry>
  
  <entry>
    <title>Parallel Computation using MPS</title>
    <link href="http://yulingtianxia.com/blog/2019/02/28/Parallel-Computation-using-MPS/"/>
    <id>http://yulingtianxia.com/blog/2019/02/28/Parallel-Computation-using-MPS/</id>
    <published>2019-02-27T17:50:50.000Z</published>
    <updated>2019-07-20T09:51:45.781Z</updated>
    
    <content type="html"><![CDATA[<p>在照片质量评分组件 <a href="https://github.com/yulingtianxia/PhotoAssessment" target="_blank" rel="noopener">PhotoAssessment</a> 项目上，有些算法的实现是使用 CPU 运行的。通过使用 MPS(Metal Performance Shader) 在 GPU 上并行计算，显著提升了性能，算法执行耗时降低了 99.9% 以上。震惊，呵呵。随着性能上成百上千倍的提升，可以在相等时间内处理更大尺寸的图片，进而提升组件的准确度和用户体验。</p><p>至此，几乎所有图像处理与计算任务都交由 GPU 完成。之前利用 Sobel 算子边缘检测是使用了苹果封装好的 MPS 类，剩余的色彩分布指纹向量和饱和度均值当然都是需要自己写 Shader 的，现在终于补齐了。Metal Shading Language 与 GLSL 使用习惯和理念很相似，只不过 Metal Shader 的语法是基于 C++ 14 的。</p><p>关于整个组件的实现思路，可以查阅<a href="http://yulingtianxia.com/blog/2018/11/30/Photo-Assessment/">『使用 Metal 和 Core ML 评价照片质量』</a>。本篇文章所涉及到的 <a href="https://github.com/yulingtianxia/PhotoAssessment/blob/master/PhotoAssessment-Sample/Sources/PhotoAssessmentShaders.metal" target="_blank" rel="noopener">Shader 代码</a> 也在其中。</p><a id="more"></a><p>工程升级到 Swift 5 结果 CI 不支持，编不过哎。</p><h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p>对一张 4032x3024 彩色图片在 iPhone 8 Plus 上进行测试的 Benchmark 如下（单位：秒）：</p><p>计算平均饱和度：（耗时降低 99.90%）<br>CPU meanSaturation cost: 27.276064038276672<br>GPU meanSaturation cost: 0.02604210376739502</p><p>计算指纹向量算法：（耗时降低 99.28%）<br>CPU fingerprint cost: 8.9078871011734<br>GPU fingerprint cost: 0.06412196159362793</p><p>优化后的耗时降低幅度也跟图片本身有关，色彩分布更广的图片优化效果会更好。图片尺寸越大，优化效果越好。</p><p>再来看看 500x500 尺寸下的数据：</p><p>500x500 降采样到 50x50（包含降采样耗时）<br>cpu total cost: 0.3883340358734131<br>gpu total cost: 0.0030889511108398438</p><p>直接处理 500x500 尺寸图片<br>gpu total cost: 0.008553862571716</p><p>可以看出，降采样有一定耗时。即便是降采样到 50x50 这种很小的尺寸，在 CPU 上运行算法也会有较多的耗时。<strong>相比之下，直接 GPU 处理 500x500 尺寸图片具有更大的优势：耗时远小于降采样后跑 CPU，略高于降采样后跑 GPU，但能够处理更大尺寸更多信息，相当于有更高的准确率。</strong></p><p>实现这两个功能的 Shader kernel 函数分别封装成 Swift 类： <a href="https://github.com/yulingtianxia/PhotoAssessment/blob/master/PhotoAssessment-Sample/Sources/MPSSaturationKernel.swift" target="_blank" rel="noopener"><code>MPSSaturationKernel</code></a> 和 <a href="https://github.com/yulingtianxia/PhotoAssessment/blob/master/PhotoAssessment-Sample/Sources/MSPFingerprintImageKernel.swift" target="_blank" rel="noopener"><code>MSPFingerprintImageKernel</code></a>。</p><h2 id="Shader-的实现"><a href="#Shader-的实现" class="headerlink" title="Shader 的实现"></a>Shader 的实现</h2><p>Command Encoder 会使用 Texture、Buffer、Sampler、Pipeline 等内容构建出 Command，并装载到 Command Buffer 上。</p><p><img src="https://raw.githubusercontent.com/yulingtianxia/Blog-Hexo-Source/master/source/resources/MPS/command%20structure0.png" alt="from Apple Doc"></p><p>从 CPU 各个线程创建的 Command Buffer 都将会传入 Command Queue。运行在 GPU 上的 Shader 代码会处理这些 Command。</p><p><img src="https://raw.githubusercontent.com/yulingtianxia/Blog-Hexo-Source/master/source/resources/MPS/command%20structure1.png" alt="from Apple Doc"></p><p>Command Encoder 有三种：Render、Compute 和 Blit。区别在于用途和用法，但创建的 Command 都可以放入同一个 Command Buffer 中。</p><p><img src="https://raw.githubusercontent.com/yulingtianxia/Blog-Hexo-Source/master/source/resources/MPS/Cmd-Model-threads.png" alt="from Apple Doc"></p><p>为了在 GPU 上并行计算图片的饱和度和指纹向量，需要用到 Compute Command Encoder，并传入以下几个参数构建 Command：</p><ol><li>Texture：输入或输出用到的图像纹理</li><li>Buffer：可作为额外的入参或结果，可设定 CPU 和 GPU 间共享</li><li>Compute Pipeline State：用于配置 Shader 函数名，也可用于计算 threadgroup 相关信息。</li></ol><h3 id="Threadgroup"><a href="#Threadgroup" class="headerlink" title="Threadgroup"></a>Threadgroup</h3><p>GPU 并行计算时，每条线程处理一个像素。整个 Texture 看做一个 Grid，可以进一步划分成多个 threadgroup。</p><p><img src="https://raw.githubusercontent.com/yulingtianxia/Blog-Hexo-Source/master/source/resources/MPS/threadgroups.png" alt="from Apple Doc"></p><p>threadgroup 还会按照 GPU 能同时执行的线程数 <code>threadExecutionWidth</code> 被划分为 SIMD group。</p><p><img src="https://raw.githubusercontent.com/yulingtianxia/Blog-Hexo-Source/master/source/resources/MPS/SIMD%20group.png" alt="from Apple Doc"></p><p>为了达到更好的性能，需要将 threadgroup 包含的线程数量设定为 <code>threadExecutionWidth</code> 的整数倍。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">let w</span> = computePipelineState.threadExecutionWidth;</span><br><span class="line"><span class="attribute">let h</span> = computePipelineState.maxTotalThreadsPerThreadgroup / w;</span><br><span class="line"><span class="attribute">threadGroupSize</span> = MTLSize(width: w, height: h, depth: 1);</span><br></pre></td></tr></table></figure><p>在编写 Shader 时，可以通过参数获取到当前处理的像素所处的相对位置。在 C++ 14 中是使用属性的方式来标记参数用途。比如 <code>thread_position_in_grid</code> 指的是当前线程处理的像素在 Grid 中的位置。类似的属性很多，比如 <code>threadgroup_position_in_grid</code>, <code>thread_position_in_threadgroup</code>,<code>threads_per_threadgroup</code>, <code>simdgroup_index_in_threadgroup</code>, <code>thread_index_in_simdgroup</code> …</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kernel void</span><br><span class="line">rgb2hsvKernelNonuniform(texture2d&lt;float, access::<span class="built_in">read</span>&gt; inTexture <span class="string">[[texture(0)]]</span>,</span><br><span class="line">              texture2d&lt;float, access::<span class="built_in">write</span>&gt; outTexture <span class="string">[[texture(1)]]</span>,</span><br><span class="line">              uint2 gid <span class="string">[[thread_position_in_grid]]</span>)</span><br><span class="line">&#123;</span><br><span class="line">    float4 pixel = inTexture.<span class="built_in">read</span>(gid);</span><br><span class="line">    // 省略部分代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如传入的 <code>gid</code> 为 (9, 10)，那么就可以从 <code>inTexture</code> 中读取到此位置像素的数据。因为 Grid 坐标系是基于这个 Texture 的。</p><p><img src="https://raw.githubusercontent.com/yulingtianxia/Blog-Hexo-Source/master/source/resources/MPS/grid%20coordinates.png" alt="from Apple Doc"></p><h3 id="Non-uniform-Threadgroup-Size"><a href="#Non-uniform-Threadgroup-Size" class="headerlink" title="Non-uniform Threadgroup Size"></a>Non-uniform Threadgroup Size</h3><p>Command Encoder 需要知道要处理的 Grid 的分组情况，比如Grid 包含多少 threadgroup，每个 threadgroup 包含多少 thread。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> w = threadGroupSize.<span class="built_in">width</span>;</span><br><span class="line"><span class="built_in">let</span> h = threadGroupSize.<span class="built_in">height</span>;</span><br><span class="line"><span class="built_in">let</span> threadgroupsPerGrid = MTLSize(<span class="built_in">width</span>: (sourceTexture.<span class="built_in">width</span> + w - <span class="number">1</span>) / w, <span class="built_in">height</span>: (sourceTexture.<span class="built_in">height</span> + h - <span class="number">1</span>) / h, depth: <span class="number">1</span>);</span><br><span class="line">encoder?.dispatchThreadgroups(threadgroupsPerGrid, threadsPerThreadgroup: threadGroupSize)</span><br></pre></td></tr></table></figure><p>确定好这些信息后，GPU 就会开始按分组矩阵批量处理像素。但是因为 Grid 的尺寸是 Texture 的尺寸，长和宽不一定都能整除 threadgroup，所以处理到图片边缘的 threadgroup 时，会有一部分调用传入的 <code>gid</code> 超出了范围。此时要在 Shader 中做边界保护逻辑：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kernel void</span><br><span class="line">rgb2hsvKernel(texture2d&lt;float, access::<span class="built_in">read</span>&gt; inTexture <span class="string">[[texture(0)]]</span>,</span><br><span class="line">              texture2d&lt;float, access::<span class="built_in">write</span>&gt; outTexture <span class="string">[[texture(1)]]</span>,</span><br><span class="line">              uint2 gid <span class="string">[[thread_position_in_grid]]</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>((gid.x &gt;= outTexture.get_width()) || (gid.y &gt;= outTexture.get_height()))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    rgb2hsv(inTexture, outTexture, gid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是超范围的调用都被 <code>return</code> 掉了，GPU 的一些线程没利用上，造成了浪费:</p><p><img src="https://raw.githubusercontent.com/yulingtianxia/Blog-Hexo-Source/master/source/resources/MPS/underutilization%20of%20threads.png" alt="from Apple Doc"></p><p>为了提升性能，Metal 在部分 GPU 特性集上支持了 “Non-uniform Threadgroup Size”。可以允许存在不同 size 的 threadgroup：</p><p><img src="https://raw.githubusercontent.com/yulingtianxia/Blog-Hexo-Source/master/source/resources/MPS/nonuniform%20threadgroups.png" alt="from Apple Doc"></p><p>这样只需要传入 Grid 的 size，以及 threadgroup 的 size，Metal 就会自动划分边缘部分的 threadgroup size，充分利用好 GPU 的运算效率。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> threadsPerGrid = MTLSize(<span class="built_in">width</span>: sourceTexture.<span class="built_in">width</span>, <span class="built_in">height</span>: sourceTexture.<span class="built_in">height</span>, depth: <span class="number">1</span>);</span><br><span class="line">encoder?.dispatchThreads(threadsPerGrid, threadsPerThreadgroup: threadGroupSize)</span><br></pre></td></tr></table></figure><p>这样一来 Shader 部分的代码就不需要加边界判断了：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kernel void</span><br><span class="line">rgb2hsvKernelNonuniform(texture2d&lt;float, access::<span class="built_in">read</span>&gt; inTexture <span class="string">[[texture(0)]]</span>,</span><br><span class="line">              texture2d&lt;float, access::<span class="built_in">write</span>&gt; outTexture <span class="string">[[texture(1)]]</span>,</span><br><span class="line">              uint2 gid <span class="string">[[thread_position_in_grid]]</span>)</span><br><span class="line">&#123;</span><br><span class="line">    rgb2hsv(inTexture, outTexture, gid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过并不是所有系统和设备都支持这项特性。目前支持 Non-uniform Threadgroup Size 的 GPU Feature Set 如下：</p><ul><li>iOS11 GPUFamily4_v1</li><li>iOS12 GPUFamily4_v2</li><li>iOS12 GPUFamily5_v1</li><li>macOS13 GPUFamily1_v3</li><li>macOS14 GPUFamily1_v4</li><li>macOS14 GPUFamily2_v1</li></ul><p>所以目前我的策略是先判断是否支持 Non-uniform Threadgroup Size，然后决定使用的 Shader 函数版本、以及 Encoder 分发线程的方式。</p><h3 id="原子操作生成-Histogram"><a href="#原子操作生成-Histogram" class="headerlink" title="原子操作生成 Histogram"></a>原子操作生成 Histogram</h3><p>在计算指纹向量的时，并行将每个像素的内容处理完后，还需要统计成柱状图。比如处理完的像素种类一共有 <code>HistogramBufferSize</code> 种，需要统计每种类型的像素数量，可以声明一个 Buffer，包含长度为 <code>HistogramBufferSize</code> 的数组 <code>bucket</code>，将其传入 Shader 函数用于统计。</p><p>下面是用 Shader 实现的指纹向量生成代码，MPS 实现了部分 C++ 原子操作的接口，<code>atomic_fetch_add_explicit</code> 用于原子累加操作。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    atomic_int bucket[HistogramBufferSize];</span><br><span class="line">&#125; PAHistogramBuffer;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> fingerprint(texture2d&lt;<span class="type">uint</span>, access::read&gt; inTexture [[<span class="built_in">texture</span>(<span class="number">0</span>)]],</span><br><span class="line">                 device PAHistogramBuffer &amp;<span class="keyword">buffer</span> [[<span class="keyword">buffer</span>(<span class="number">0</span>)]],</span><br><span class="line">                 uint2 gid [[thread_position_in_grid]])</span><br><span class="line">&#123;</span><br><span class="line">    uint4 c = inTexture.read(gid);</span><br><span class="line">    <span class="type">uint</span> width = inTexture.get_width();</span><br><span class="line">    <span class="type">uint</span> height = inTexture.get_height();</span><br><span class="line">    <span class="type">uint</span> blockCount = <span class="number">2</span>;</span><br><span class="line">    <span class="type">uint</span> rowCount = <span class="built_in">min</span>(blockCount, height);</span><br><span class="line">    <span class="type">uint</span> countPerRow = <span class="built_in">min</span>(blockCount, width);</span><br><span class="line">    <span class="type">uint</span> hStep = width / countPerRow;</span><br><span class="line">    <span class="type">uint</span> vStep = height / rowCount;</span><br><span class="line">    <span class="type">uint</span> row = gid.y / vStep;</span><br><span class="line">    <span class="type">uint</span> col = gid.x / hStep;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// |-3bit-|-3bit-|-3bit-|-2bit-|</span></span><br><span class="line">    <span class="type">uint</span> result = (row * countPerRow + col) + ((c.y &gt;&gt; <span class="number">5</span>) &lt;&lt; <span class="number">2</span>) + ((c.z &gt;&gt; <span class="number">5</span>) &lt;&lt; <span class="number">5</span>) + ((c.w &gt;&gt; <span class="number">5</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    atomic_fetch_add_explicit(&amp;<span class="keyword">buffer</span>.bucket[result], <span class="number">1</span>, memory_order_relaxed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MPS 支持的原子操作值类型很有限，无法选择占用内存更低的类型，只好忍受 <code>atomic_int</code> 带来的 4 Byte 吧。只要控制好 <code>HistogramBufferSize</code>，问题应该不大。</p><h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><p>MPS 中获取向量内容的方式可谓是方便，但是也是有坑在里面的。比如要注意无论是 <code>xyzw</code> 还是 <code>rgba</code> 分量获取的内容都是从低地址到高地址排列的。比如传入的像素格式是 RGBA，那么 <code>rgba</code> 获取的值正好是反过来的。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RGBA</span><br><span class="line">wzyx  <span class="comment">// x低 w 高</span></span><br><span class="line">abgr  <span class="comment">// r低 a 高</span></span><br></pre></td></tr></table></figure><p>同样向 Texture 写数据的时候也要注意构造向量的时候，从左往右也是从低到高。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0x04030201</span></span><br><span class="line">outTexture.write(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), gid);</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://developer.apple.com/metal/Metal-Shading-Language-Specification.pdf" target="_blank" rel="noopener">https://developer.apple.com/metal/Metal-Shading-Language-Specification.pdf</a></li><li><a href="https://developer.apple.com/metal/Metal-Feature-Set-Tables.pdf" target="_blank" rel="noopener">https://developer.apple.com/metal/Metal-Feature-Set-Tables.pdf</a></li><li><a href="https://stackoverflow.com/questions/47738441/passing-textures-with-uint8-component-type-to-metal-compute-shader" target="_blank" rel="noopener">https://stackoverflow.com/questions/47738441/passing-textures-with-uint8-component-type-to-metal-compute-shader</a></li><li><a href="https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl" target="_blank" rel="noopener">https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在照片质量评分组件 &lt;a href=&quot;https://github.com/yulingtianxia/PhotoAssessment&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PhotoAssessment&lt;/a&gt; 项目上，有些算法的实现是使用 CPU 运行的。通过使用 MPS(Metal Performance Shader) 在 GPU 上并行计算，显著提升了性能，算法执行耗时降低了 99.9% 以上。震惊，呵呵。随着性能上成百上千倍的提升，可以在相等时间内处理更大尺寸的图片，进而提升组件的准确度和用户体验。&lt;/p&gt;
&lt;p&gt;至此，几乎所有图像处理与计算任务都交由 GPU 完成。之前利用 Sobel 算子边缘检测是使用了苹果封装好的 MPS 类，剩余的色彩分布指纹向量和饱和度均值当然都是需要自己写 Shader 的，现在终于补齐了。Metal Shading Language 与 GLSL 使用习惯和理念很相似，只不过 Metal Shader 的语法是基于 C++ 14 的。&lt;/p&gt;
&lt;p&gt;关于整个组件的实现思路，可以查阅&lt;a href=&quot;http://yulingtianxia.com/blog/2018/11/30/Photo-Assessment/&quot;&gt;『使用 Metal 和 Core ML 评价照片质量』&lt;/a&gt;。本篇文章所涉及到的 &lt;a href=&quot;https://github.com/yulingtianxia/PhotoAssessment/blob/master/PhotoAssessment-Sample/Sources/PhotoAssessmentShaders.metal&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Shader 代码&lt;/a&gt; 也在其中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Metal" scheme="http://yulingtianxia.com/tags/Metal/"/>
    
  </entry>
  
  <entry>
    <title>使用 OCLint 自定义 MVVM 规则</title>
    <link href="http://yulingtianxia.com/blog/2019/01/27/MVVM-Rules-for-OCLint/"/>
    <id>http://yulingtianxia.com/blog/2019/01/27/MVVM-Rules-for-OCLint/</id>
    <published>2019-01-27T11:00:51.000Z</published>
    <updated>2019-05-26T10:08:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在搞 iOS MVVM 框架，虽说是 N 年前就老生常谈的知识了，但设计模式毕竟是只一种规范，无法约束项目中所有程序员都去遵循。我做了个 OCLint 的自定义规则，对 ViewModel 运行静态检查。</p><p>然而过程中踩了不少坑，OCLint 的官方 Repo 早已失效，可以使用我修改后基于 LLVM 7 的版本：<a href="https://github.com/yulingtianxia/oclint/tree/llvm-7.0" target="_blank" rel="noopener">https://github.com/yulingtianxia/oclint/tree/llvm-7.0</a></p><p>伸手党也可以使用我写的<a href="https://github.com/yulingtianxia/oclint/releases/download/0.18.10/install-0.18.10" target="_blank" rel="noopener">脚本</a>直接安装，已包含 MVVM 规则。</p><a id="more"></a><h2 id="编译-OCLint"><a href="#编译-OCLint" class="headerlink" title="编译 OCLint"></a>编译 OCLint</h2><p>编译 OCLint 时，会先下载 LLVM 等项目。由于 LLVM 源码废弃了在 SVN 上的版本管理，将其迁移到了 Git 上，所以目前各种版本的 OCLint 都无法编译了。而且最新版本的 OCLint 还是基于 LLVM 5 的！我从作者的 Repo 那发现有 LLVM 7 的 branch，依然无法编译，只好自己动手改了。</p><p>虽然 Git 上的提交与历史 SVN 提交记录有映射，但是经过实践发现并不精准可信。编译时需要用到 llvm-project 下的 llvm，cfe 和 compile-rt，而且三个 repo 的 release 版本一定要一致。然而  LLVM 在 Git 上同一个 release 的代码却无法编译通过。更离谱的是即便 LLVM 在 GitHub 上把整个 llvm-project 作为一个 repo，依然无法将其 release 版本编译通过。</p><p>算了，Git 不靠谱，还是改下 OCLint 的代码，从官网直接下以前打包好的吧。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">llvm</span> = <span class="string">'http://releases.llvm.org/7.0.0/llvm'</span></span><br><span class="line"><span class="attr">clang</span> = <span class="string">'http://releases.llvm.org/7.0.0/cfe'</span></span><br><span class="line"><span class="attr">clang_rt</span> = <span class="string">'http://releases.llvm.org/7.0.0/compiler-rt'</span></span><br></pre></td></tr></table></figure><p>我把最终可以正常编译的 0.18.10 版本发了个非官方的 release 包，macOS 亲测 ok：<a href="https://github.com/yulingtianxia/oclint/releases/tag/0.18.10" target="_blank" rel="noopener">https://github.com/yulingtianxia/oclint/releases/tag/0.18.10</a></p><p>嫌麻烦不想编译的，可以直接跑我提供的脚本来安装已经编译好的 0.18.10 版本。以前安装过 OCLint 旧版本的可以先备份下，因为会被覆盖安装。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate -O install-oclint https:<span class="regexp">//gi</span>thub.com<span class="regexp">/yulingtianxia/</span>oclint<span class="regexp">/releases/</span>download<span class="regexp">/0.18.10/i</span>nstall-<span class="number">0.18</span>.<span class="number">10</span></span><br><span class="line">chmod +x install-oclint</span><br><span class="line">.<span class="regexp">/install-oclint</span></span><br></pre></td></tr></table></figure><h2 id="自定义规则"><a href="#自定义规则" class="headerlink" title="自定义规则"></a>自定义规则</h2><p>网上有很多介绍如何编写自定义规则的文章，这里假设已经成功编译好 OCLint，总体流程如下。</p><h3 id="创建规则"><a href="#创建规则" class="headerlink" title="创建规则"></a>创建规则</h3><p>使用 oclint-scripts 文件夹下的 scaffoldRule 脚本创建一个新规则，并指定模板。注意规则名不需要带 “Rule”:</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oclint-scripts/scaffoldRule MVVM -<span class="built_in">t</span> ASTVisitor</span><br></pre></td></tr></table></figure><h3 id="生成调试工程"><a href="#生成调试工程" class="headerlink" title="生成调试工程"></a>生成调试工程</h3><p>创建一个文件夹用于生成调试 Rule 的工程。我已经创建好了：<a href="https://github.com/yulingtianxia/oclint/tree/llvm-7.0/oclint-xcodeproject" target="_blank" rel="noopener">https://github.com/yulingtianxia/oclint/tree/llvm-7.0/oclint-xcodeproject</a></p><p>运行 xcode-debug.sh 脚本即可使用 oclint-rules 文件夹的内容创建一个 Xcode 工程。因为这里是想调试刚刚创建的 MVVM 规则，所以选择 oclint-rules。理论上可以修改脚本参数使用其他文件夹创建 Xcode 工程。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /bin/sh -e</span></span><br><span class="line"></span><br><span class="line">cmake -G Xcode -D <span class="attribute">CMAKE_CXX_COMPILER</span>=../build/llvm-install/bin/clang++  -D <span class="attribute">CMAKE_C_COMPILER</span>=../build/llvm-install/bin/clang -D <span class="attribute">OCLINT_BUILD_DIR</span>=../build/oclint-core -D <span class="attribute">OCLINT_SOURCE_DIR</span>=../oclint-core -D <span class="attribute">OCLINT_METRICS_SOURCE_DIR</span>=../oclint-metrics -D <span class="attribute">OCLINT_METRICS_BUILD_DIR</span>=../build/oclint-metrics -D <span class="attribute">LLVM_ROOT</span>=../build/llvm-install/ <span class="built_in">..</span>/oclint-rules</span><br></pre></td></tr></table></figure><p>每个规则都有对应的 Scheme，选择我们自定义的 MVVMRule，添加启动参数。<code>-R</code> 传入自定义的规则名，这里使用调试工程生成的 Debug 目录。接着传入一个随便写的测试用文件 <code>TestViewModel.m</code>，此文件所依赖的 Framework 等环境参数也需要传入。别忘了需要把我贴的绝对路径修改成你电脑上的路径。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-R <span class="regexp">/Users/</span>yangxiaoyu<span class="regexp">/Code/</span>oclint<span class="regexp">/oclint-xcodeproject/</span>rules.dl<span class="regexp">/Debug /</span>Users<span class="regexp">/yangxiaoyu/</span>Code<span class="regexp">/oclint/</span>oclint-rules-test<span class="regexp">/OCLintTest/</span>OCLintTest/TestViewModel.m  -- -x objective-c </span><br><span class="line">-isystem <span class="regexp">/Users/</span>yangxiaoyu<span class="regexp">/Code/</span>oclint<span class="regexp">/build/</span>oclint-release<span class="regexp">/lib/</span>clang<span class="regexp">/7.0.0/</span>include</span><br><span class="line">-iframework <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/</span>iPhoneSimulator.platform<span class="regexp">/Developer/</span>SDKs<span class="regexp">/iPhoneSimulator.sdk/</span>System<span class="regexp">/Library/</span>Frameworks</span><br><span class="line">-isystem <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/</span>iPhoneSimulator.platform<span class="regexp">/Developer/</span>SDKs<span class="regexp">/iPhoneSimulator.sdk/</span>usr/include</span><br></pre></td></tr></table></figure><p>为了能够调试运行，还需要在 Scheme 的 Info 下选择 Executable 为编译好的 oclint 的可执行文件。oclint-0.18.10 文件由于后缀名问题不允许被选择为 Executable，删掉后缀名的数字就可以了。这样就可以无需重新编译 OCLint 直接运行调试了！</p><h3 id="实现规则"><a href="#实现规则" class="headerlink" title="实现规则"></a>实现规则</h3><p>在 MVVM 设计模式下，我想让 ViewModel 的属性都是只读的。因为我只想通过与 Model 的数据绑定来更新 ViewModel 的值，或是在其内部更新状态。现在我需要实现一个规则来找出那些非只读属性。</p><p>先找几个自带的规则例子看看，结合 <a href="https://clang.llvm.org/doxygen/" target="_blank" rel="noopener">Clang AST 文档</a>学习下各种数据结构的定义。如果不知道自己的测试代码如何下手，可以用 <code>clang</code> 命令将测试代码转化为 <a href="http://clang.llvm.org/docs/IntroductionToTheClangAST.html" target="_blank" rel="noopener">Clang AST</a>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">clang</span> <span class="selector-tag">-Xclang</span> <span class="selector-tag">-ast-dump</span> <span class="selector-tag">-fsyntax-only</span> <span class="selector-tag">TestViewModel</span><span class="selector-class">.m</span></span><br></pre></td></tr></table></figure><p>思路是遍历每个后缀名为 <code>ViewModel</code> 类的 Interface 中的所有 Property，判断每个 Property 的 Attribute，如果包含 <code>readwrite</code> 就触发 warning。提高优先级可以产生 error。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Visit ObjCImplementationDecl */</span></span><br><span class="line">bool VisitObjCImplementationDecl(ObjCImplementationDecl *node)</span><br><span class="line">&#123;</span><br><span class="line">    ObjCInterfaceDecl *<span class="class"><span class="keyword">interface</span> = <span class="title">node</span>-&gt;<span class="title">getClassInterface</span></span>();</span><br><span class="line">    </span><br><span class="line">    bool isViewModel = <span class="class"><span class="keyword">interface</span>-&gt;<span class="title">getName</span></span>().endswith(<span class="string">"ViewModel"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!isViewModel) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (auto property = <span class="class"><span class="keyword">interface</span>-&gt;<span class="title">instprop_begin</span></span>(),</span><br><span class="line">         propertyEnd = <span class="class"><span class="keyword">interface</span>-&gt;<span class="title">instprop_end</span></span>(); property != propertyEnd; property++)</span><br><span class="line">    &#123;</span><br><span class="line">        clang::ObjCPropertyDecl *propertyDecl = (clang::ObjCPropertyDecl *)*property;</span><br><span class="line">        <span class="keyword">if</span> (propertyDecl-&gt;getName().startswith(<span class="string">"UI"</span>)) &#123;</span><br><span class="line">            addViolation(propertyDecl, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        auto attrs = propertyDecl-&gt;getPropertyAttributes();</span><br><span class="line">        bool isReadwrite = (attrs &amp; ObjCPropertyDecl::PropertyAttributeKind::OBJC_PR_readwrite) &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (isReadwrite &amp;&amp; isViewModel) &#123;</span><br><span class="line">            addViolation(propertyDecl, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集成到-Xcode"><a href="#集成到-Xcode" class="headerlink" title="集成到 Xcode"></a>集成到 Xcode</h2><p>先放一张集成后的效果：</p><p><img src="http://yulingtianxia.com/resources/QQ20190127-175054@2x.png" alt></p><p>在 CI 运行静态检查可以减少一部分人工 Code Review 的成本，缺点是发现问题滞后，解决问题有一定成本。而如果在本地 Xcode 运行静态检查，则可把问题扼杀在摇篮之中，缺点是占用开发机资源。</p><p>如何在 Xcode 中集成 OCLint 静态检查，官方有很详细的文档，图文并茂: <a href="https://oclint-docs.readthedocs.io/en/stable/guide/xcode.html" target="_blank" rel="noopener">https://oclint-docs.readthedocs.io/en/stable/guide/xcode.html</a></p><p>美中不足的是 Xcode Run Script 欠一点火候，可以参考下下面我提供的脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">which</span> oclint 2&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'oclint exist'</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">wget --no-check-certificate -O install-oclint https://github.com/yulingtianxia/oclint/releases/download/0.18.10/install-0.18.10</span><br><span class="line">chmod +x install-oclint</span><br><span class="line">./install-oclint</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">which</span> xcpretty 2&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'xcpretty exist'</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">sudo gem install xcpretty</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;SRCROOT&#125;</span></span><br><span class="line">xcodebuild clean</span><br><span class="line">xcodebuild | xcpretty -r json-compilation-database --output compile_commands.json</span><br><span class="line">oclint-json-compilation-database -- -report-type xcode</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>我只是简单的写了一个 ViewModel 的规则来跑通和验证整个流程，其实 MVVM 设计模式里还有更多的规则需要实现，比如 ViewModel 中不能引入 <code>UIKit</code> 等。欢迎有兴趣的同学提 PR！</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="http://oclint.org" target="_blank" rel="noopener">OCLint</a></li><li><a href="http://releases.llvm.org/download.html#7.0.0" target="_blank" rel="noopener">LLVM Download Page</a></li><li><a href="https://github.com/llvm/llvm-project" target="_blank" rel="noopener">llvm-project</a></li><li><a href="http://clang.llvm.org/docs/IntroductionToTheClangAST.html" target="_blank" rel="noopener">Introduction to the Clang AST</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在搞 iOS MVVM 框架，虽说是 N 年前就老生常谈的知识了，但设计模式毕竟是只一种规范，无法约束项目中所有程序员都去遵循。我做了个 OCLint 的自定义规则，对 ViewModel 运行静态检查。&lt;/p&gt;
&lt;p&gt;然而过程中踩了不少坑，OCLint 的官方 Repo 早已失效，可以使用我修改后基于 LLVM 7 的版本：&lt;a href=&quot;https://github.com/yulingtianxia/oclint/tree/llvm-7.0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/yulingtianxia/oclint/tree/llvm-7.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;伸手党也可以使用我写的&lt;a href=&quot;https://github.com/yulingtianxia/oclint/releases/download/0.18.10/install-0.18.10&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;脚本&lt;/a&gt;直接安装，已包含 MVVM 规则。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yulingtianxia.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>DirtyWords for Xcode - 做个文明的程序员</title>
    <link href="http://yulingtianxia.com/blog/2018/12/30/Dirty-Words-for-Xcode/"/>
    <id>http://yulingtianxia.com/blog/2018/12/30/Dirty-Words-for-Xcode/</id>
    <published>2018-12-30T03:26:27.000Z</published>
    <updated>2019-05-26T10:08:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>开发者经常会在代码中看到各类脏话，有吐槽产品的瞎改早晚还会改回来的，有吐槽这块代码写的太烂无法直视的，或是干脆心情不好就一顿骂。公司内部的项目想必是无数天坑 f*ck 无数，连对外开源的项目也难逃一劫，比如前一段时间 <a href="https://bugs.openjdk.java.net/browse/JDK-8215217" target="_blank" rel="noopener">OpenJDK</a> 就因为脏话太多火了一把。</p><p>于是我做了一个 Xcode 插件来寻找代码中的脏话，将其高亮可以被选中，作为一个强提示让开发者修改。目前逻辑还只是简单替换而已，代码在这里：<a href="https://github.com/yulingtianxia/DirtyWords-for-Xcode" target="_blank" rel="noopener">DirtyWords-for-Xcode</a></p><p>为了体现汉字的博大精深，瞎画了个 icon，见笑了：</p><p><img src="https://github.com/yulingtianxia/DirtyWords-for-Xcode/blob/master/images/%E8%89%B9.png?raw=true" alt></p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="AppStore"><a href="#AppStore" class="headerlink" title="AppStore"></a>AppStore</h3><p><a href="https://itunes.apple.com/cn/app/dirtywords-for-xcode/id1447526628?mt=12" target="_blank" rel="noopener">DirtyWords for Xcode</a></p><h3 id="GitHub-Release"><a href="#GitHub-Release" class="headerlink" title="GitHub Release"></a>GitHub Release</h3><p>直接从 GitHub Release 页面下载最新的安装包：<br><a href="https://github.com/yulingtianxia/DirtyWords-for-Xcode/releases" target="_blank" rel="noopener">https://github.com/yulingtianxia/DirtyWords-for-Xcode/releases</a></p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>用法很简单，反正目前也就这么一个功能。Editer -&gt; Dirty Words -&gt; Highlight</p><p><img src="https://github.com/yulingtianxia/DirtyWords-for-Xcode/blob/master/images/usage.png?raw=true" alt></p><p>例如下图中的 “fuck” 就会被高亮，可以文明用语代之。</p><p><img src="https://github.com/yulingtianxia/DirtyWords-for-Xcode/blob/master/images/highlight.png?raw=true" alt></p><p>如果在 Editor 菜单中找不到的话，打开系统偏好设置 -&gt; 拓展，并勾选 “DirtyWords for Xcode” 拓展项.</p><p><img src="https://github.com/yulingtianxia/DirtyWords-for-Xcode/blob/master/images/appui.png?raw=true" alt></p><p>可以给 DirtyWords 自定义快捷键。 Xcode &gt; Preferences &gt; Key Bindings &gt; 搜索 “Dirty Words”.</p><p><img src="https://github.com/yulingtianxia/DirtyWords-for-Xcode/blob/master/images/keybindings.png?raw=true" alt></p><h2 id="脏词黑名单"><a href="#脏词黑名单" class="headerlink" title="脏词黑名单"></a>脏词黑名单</h2><p>脏词列表文件跟随 app 打包进去了。在拓展加载完成后，也会通过网络下载 <a href="https://github.com/yulingtianxia/DirtyWords-for-Xcode/blob/master/SourceEditorExtension/dirtywords" target="_blank" rel="noopener">dirtywords</a> 文件进行更新。这样方便以后调整脏词列表，也欢迎大家提 PR 补充。</p><p>在收集脏词的过程中真是长了见识了，不搜不知道一搜吓一跳，哈哈。有<a href="https://github.com/LDNOOBW/List-of-Dirty-Naughty-Obscene-and-Otherwise-Bad-Words" target="_blank" rel="noopener">各国语言版的</a>，还有据说是 <a href="https://github.com/RobertJGabriel/Google-profanity-words" target="_blank" rel="noopener">Google 版的</a>。</p><p>因为分词会比较耗性能，代码中有些 API 其实是触碰脏词的，比如 “UIButton” 中包含了 “butt”，所以有些脏词需要从黑名单剔除，避免误判。不过我觉得 “fuck” 这种词无论怎么组合都难洗白的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开发者经常会在代码中看到各类脏话，有吐槽产品的瞎改早晚还会改回来的，有吐槽这块代码写的太烂无法直视的，或是干脆心情不好就一顿骂。公司内部的项目想必是无数天坑 f*ck 无数，连对外开源的项目也难逃一劫，比如前一段时间 &lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-8215217&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OpenJDK&lt;/a&gt; 就因为脏话太多火了一把。&lt;/p&gt;
&lt;p&gt;于是我做了一个 Xcode 插件来寻找代码中的脏话，将其高亮可以被选中，作为一个强提示让开发者修改。目前逻辑还只是简单替换而已，代码在这里：&lt;a href=&quot;https://github.com/yulingtianxia/DirtyWords-for-Xcode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;DirtyWords-for-Xcode&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为了体现汉字的博大精深，瞎画了个 icon，见笑了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yulingtianxia/DirtyWords-for-Xcode/blob/master/images/%E8%89%B9.png?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用 Metal 和 Core ML 评价照片质量</title>
    <link href="http://yulingtianxia.com/blog/2018/11/30/Photo-Assessment/"/>
    <id>http://yulingtianxia.com/blog/2018/11/30/Photo-Assessment/</id>
    <published>2018-11-30T14:53:14.000Z</published>
    <updated>2019-05-26T10:08:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>如何评价一张照片的质量呢？</p><p>用算法可以客观地评价照片质量，也可以人为主观地给照片打分，并运用机器学习来训练模型。</p><p>我用 Swift 写了个 <a href="https://github.com/yulingtianxia/PhotoAssessment" target="_blank" rel="noopener">Demo</a>。用苹果的 Metal 跑一些算法得出客观评分，再用 Core ML 预测主观评分。得到照片评分后，就可以检测相似照片，并从中挑选最优的照片推荐给用户。</p><p><a href="https://github.com/yulingtianxia/PhotoAssessment" target="_blank" rel="noopener">Demo</a> 中展示了图片在 NIMA 模型预测结合人脸识别的主观评分、图片的 HSB 色彩空间、以及边缘检测结果的平均值和方差。代码兼容 iOS 和 macOS。下面示例图片拍摄自胡里山炮王和西塘。</p><p><img src="https://github.com/yulingtianxia/Blog-Hexo-Source/blob/master/source/resources/PhotoAssessment/AssessmentResult1.png?raw=true" alt><img src="https://github.com/yulingtianxia/Blog-Hexo-Source/blob/master/source/resources/PhotoAssessment/AssessmentResult2.png?raw=true" alt></p><a id="more"></a><h2 id="常规算法"><a href="#常规算法" class="headerlink" title="常规算法"></a>常规算法</h2><p>目前业界有很多衡量照片质量的维度，可以通过调整各个维度占的权重来计算照片的最终得分。常用的衡量维度都是一些图形学上的客观因素：</p><ul><li>饱和度（HSB/HSV 色彩空间中的 S）</li><li>亮度（HSB/HSV 色彩空间中的 B/V）</li><li>模糊度（边缘检测、二维离散傅里叶）</li><li>颜色分布（线性直方图分布）</li></ul><p>得出的结果可能还需要设定阈值来过滤掉一些质量比较差的照片，然后做归一化和调整加权系数，最终得到照片的评分。具体权重值没有统一的参考标准，需根据业务的需求不断调试和摸索。以上列的这些标准都可以找到一些通用的算法实现，甚至用 OpenCV 分分钟的事儿。但是对于移动客户端来说，OpenCV 可能并不是个好的选择。苹果的 <code>Metal</code> 技术更适合发挥其软硬件结合的优势，在性能和安装包上均有优势。</p><p>iOS 无法直接创建 HSB 色彩空间，需要借助 <code>UIColor</code> 等 API 将其他色彩空间颜色转换成 HSB 对应的值。于是我尝试使用 <code>Metal</code> 实现边缘检测算法，相关代码可以在 <a href="https://github.com/yulingtianxia/PhotoAssessment/blob/master/PhotoAssessment-Sample/Sources/PhotoMPSProcessor.swift" target="_blank" rel="noopener">PhotoMPSProcessor.swift</a> 上找到。</p><p>边缘检测有很多种实现，这里我使用的是 Sobel 算子。MPS 提供了很多 对图片做卷积运算的 Filter，其中就包含 <code>MPSImageSobel</code>。MPS 也提供了 <code>MPSImageLaplacian</code>，不过 Laplacian 算子对噪声处理较差，实际效果不好。各种算子的原理和介绍可以参考这篇简介：<a href="https://www.jianshu.com/p/2334bee37de5" target="_blank" rel="noopener">数字图像 - 边缘检测原理 - Sobel, Laplace, Canny算子</a></p><p>苹果的 <code>MetalKit</code> 拥有更简洁的 API，可以更方便地应用 <code>Metal</code> 技术。比如加载图片可以通过 <code>MTKTextureLoader</code> 几行代码轻松搞定。然而在实际应用中却发现是个大坑，比如 rgba16 格式的图片就会报错：”Image decoding failed”。<code>MTKTextureLoader</code> 应该是只能加载单通道 8 bit 的图片数据，毕竟外部没有传每个像素字节数，解析时估计写死了这个值。所以还是老老实实的用 <code>MTLTextureDescriptor</code> 描述好 Filter 的数据输入输出格式，并创建好对应的 <code>MTLTexture</code> 吧。</p><p>Sobel 算子卷积运算后的方差值可以用来检测模糊程度。下面的代码用了两个 Filter 串联起来，三种格式的数据：rgba8[w<em>h]-&gt;r8[w</em>h]-&gt;r8[2*1]。也就是 RGBA 色彩空间图片转成含有边缘信息的灰度图（如下所示），最后出计算均值和方差。</p><p><img src="https://github.com/yulingtianxia/Blog-Hexo-Source/blob/master/source/resources/PhotoAssessment/SobelImageFilter.png?raw=true" alt="PhotoAssessment"></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="keyword">public</span> func edgeDetect(<span class="string">imagePixels:</span> [Int32], <span class="string">width:</span> Int, <span class="string">height:</span> Int, _ <span class="string">block:</span> <span class="meta">@escaping</span> (_ <span class="string">mean:</span> Int8, _ <span class="string">variance:</span> Int8) -&gt; Void) -&gt; Void &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Make sure the current device supports MetalPerformanceShaders.</span></span><br><span class="line">    guard MPSSupportsMTLDevice(device) <span class="keyword">else</span> &#123;</span><br><span class="line">        print(<span class="string">"Metal Performance Shaders not Supported on current Device"</span>)</span><br><span class="line">        block(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var pixels = imagePixels</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// TextureDescriptors</span></span><br><span class="line">    let sobelSrcTextureDescriptor = MTLTextureDescriptor.texture2DDescriptor(<span class="string">pixelFormat:</span> .rgba8Snorm, <span class="string">width:</span> width, <span class="string">height:</span> height, <span class="string">mipmapped:</span> <span class="literal">false</span>)</span><br><span class="line">    sobelSrcTextureDescriptor.usage = [.shaderWrite, .shaderRead]</span><br><span class="line">    </span><br><span class="line">    let sobelDesTextureDescriptor = MTLTextureDescriptor.texture2DDescriptor(<span class="string">pixelFormat:</span> .r8Snorm, <span class="string">width:</span> width, <span class="string">height:</span> height, <span class="string">mipmapped:</span> <span class="literal">false</span>)</span><br><span class="line">    sobelDesTextureDescriptor.usage = [.shaderWrite, .shaderRead]</span><br><span class="line">    </span><br><span class="line">    let varianceTextureDescriptor = MTLTextureDescriptor.texture2DDescriptor(<span class="string">pixelFormat:</span> .r8Snorm, <span class="string">width:</span> <span class="number">2</span>, <span class="string">height:</span> <span class="number">1</span>, <span class="string">mipmapped:</span> <span class="literal">false</span>)</span><br><span class="line">    varianceTextureDescriptor.usage = [.shaderWrite, .shaderRead]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Textures</span></span><br><span class="line">    guard let <span class="string">sobelSrcTexture:</span> MTLTexture = device?.makeTexture(descriptor: sobelSrcTextureDescriptor) <span class="keyword">else</span> &#123;</span><br><span class="line">        print(<span class="string">"make sobelSrcTexture failed"</span>)</span><br><span class="line">        block(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    guard let <span class="string">sobelDesTexture:</span> MTLTexture = device?.makeTexture(descriptor: sobelDesTextureDescriptor) <span class="keyword">else</span> &#123;</span><br><span class="line">        print(<span class="string">"make sobelDesTexture failed"</span>)</span><br><span class="line">        block(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    guard let <span class="string">varianceTexture:</span> MTLTexture = device?.makeTexture(descriptor: varianceTextureDescriptor) <span class="keyword">else</span> &#123;</span><br><span class="line">        print(<span class="string">"make varianceTexture failed"</span>)</span><br><span class="line">        block(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Fill sobelSrcTexture with pixels</span></span><br><span class="line">    let sobelRegion = MTLRegionMake2D(<span class="number">0</span>, <span class="number">0</span>, width, height)</span><br><span class="line">    sobelSrcTexture.replace(<span class="string">region:</span> sobelRegion, <span class="string">mipmapLevel:</span> <span class="number">0</span>, <span class="string">withBytes:</span> &amp;pixels, <span class="string">bytesPerRow:</span> <span class="number">4</span> * width)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Run Image Filters</span></span><br><span class="line">    <span class="keyword">if</span> let commandBuffer = commandQueue?.makeCommandBuffer() &#123;</span><br><span class="line">        sobel?.encode(commandBuffer: commandBuffer, <span class="string">sourceTexture:</span> sobelSrcTexture, <span class="string">destinationTexture:</span> sobelDesTexture)</span><br><span class="line">        meanAndVariance?.encode(commandBuffer: commandBuffer, <span class="string">sourceTexture:</span> sobelDesTexture, <span class="string">destinationTexture:</span> varianceTexture)</span><br><span class="line">        commandBuffer.addCompletedHandler &#123; (buffer) <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            var result = [Int8](repeatElement(<span class="number">0</span>, <span class="string">count:</span> <span class="number">2</span>))</span><br><span class="line">            let region = MTLRegionMake2D(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            varianceTexture.getBytes(&amp;result, <span class="string">bytesPerRow:</span> <span class="number">1</span> * <span class="number">2</span>, <span class="string">from:</span> region, <span class="string">mipmapLevel:</span> <span class="number">0</span>)</span><br><span class="line">            block(result.first!, result.last!)</span><br><span class="line">            </span><br><span class="line"><span class="comment">//                let grayImage = self.imageOf(grayTexture: sobelDesTexture)</span></span><br><span class="line">        &#125;</span><br><span class="line">        commandBuffer.commit()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        print(<span class="string">"make CommandBuffer failed"</span>)</span><br><span class="line">        block(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常规做法都是利用客观评价指标来打分，可以通过设定阈值来过滤掉不符合要求的照片，但没能像大脑一样通过读懂图片的内容来评判质量。</p><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p>Google AI Blog 在 2017 年底发表过一篇博客：<a href="https://ai.googleblog.com/2017/12/introducing-nima-neural-image-assessment.html" target="_blank" rel="noopener">Introducing NIMA: Neural Image Assessment</a>。讲述了通过神经网络迁移学习来预测图片评分方法。损失函数为 EMD (earth mover’s distance)，分数分布范围是 1-10 分。先用一些已有的模型在 ImageNet 上预训练，再加个 10 节点的全连接层使用 AVA 等数据集 fune-tune。预测结果是 10 个分数的分布，而不是直接给出评分，所以可以进一步计算出期望分和方差等。</p><p>虽然论文没有给出源码或者训练好的模型，但是网上可以搜到一些第三方的实现。最后使用苹果提供的 coremltools 将其他机器学习框架的模型转成苹果的 Core ML 模型。</p><p>在网上搜索到了几个还算不错的开源实现：</p><ul><li><a href="https://github.com/idealo/image-quality-assessment" target="_blank" rel="noopener">idealo/image-quality-assessment</a>：使用 Keras + Docker + AWS 实现，MobileNet 的完成度较高，提供了 aesthetic 和 technical 两种训练好的评分模型。Keras 模型可以直接转成 mlmodel。</li><li><a href="https://github.com/titu1994/neural-image-assessment" target="_blank" rel="noopener">titu1994/neural-image-assessment</a>：使用 Keras 实现，提供了训练好的几种模型。效果最好的为 NASNet Mobile，loss = 0.067。Keras 模型可以直接转成 mlmodel。</li><li><a href="https://github.com/truskovskiyk/nima.pytorch" target="_blank" rel="noopener">truskovskiyk/nima.pytorch</a>：使用 pytorch 实现，完成度一般，只提供了 MobileNetV2 模型（loss = 0.08）。pytorch  模型需要先转为 ONNX，然后再转成 mlmodel 格式。</li></ul><p>经过反复试验与对比结果，最终使用了第一个开源实现的 MobileNet。在这个过程中踩了不少坑：</p><ol><li>机器学习涉及到的 python 库更新幅度较大，甚至连官方文档更新都严重滞后，更别提网上找的 demo 了。想跑通网上找的代码？不存在的。</li><li>既然官方文档不可信，只能看代码中的注释，在摸索中写。依然会有各种各样的报错，大部分都是版本兼容问题。虽然 coremltools 官网有说兼容的最低版本，但也千万不要直接用最高版本的 Keras 和 TensorFlow。我用的 Keras 2.1.3 和 TensorFlow 1.10，亲测 OK。</li><li>pytorch 转 ONNX 再转 mlmodel 更是麻烦，不得不吐槽机器学习相关的 python 库版本兼容性是真的差，API 说改就改，以为自己是 Swift 么？对于新手来说很不友好，过程几乎就是：改-&gt;报错-&gt;Google-&gt;改-&gt;继续报错。。。官网 demo 从来没跑通过，跟没有一样，不存在的。</li></ol><p>转换模型和权重使用的 python 代码放在这里：<a href="https://github.com/yulingtianxia/PhotoAssessment/blob/master/ConvertMLModel/NIMA/nima.py" target="_blank" rel="noopener">nima.py</a></p><p>最后转化的 mlmodel 包含在 PhotoAssessment-Sample 工程中：<a href="https://github.com/yulingtianxia/PhotoAssessment/blob/master/PhotoAssessment-Sample/Sources/MobileNet.mlmodel" target="_blank" rel="noopener">MobileNet.mlmodel</a></p><p>在得到 mlmodel 后，可以使用苹果的 Vision 框架加载模型，用 <code>VNImageRequestHandler</code> 请求处理静态图片。串联上 Vision 框架的 <code>VNDetectFaceRectanglesRequest</code> 可以顺便检测出人脸，为照片评分提供更多的参考。比如有人脸的照片可能是个加分项。</p><p>PS: 这里原本还加入了神经网络识别面部表情，但是由于准确率不高且不同表情的评分难以主观衡量，所以最后去掉了。</p><p>这部分的代码实现在这里： <a href="https://github.com/yulingtianxia/PhotoAssessment/blob/master/PhotoAssessment-Sample/Sources/PhotoMLProcessor.swift" target="_blank" rel="noopener">PhotoMLProcessor.swift</a></p><h2 id="照片相似度"><a href="#照片相似度" class="headerlink" title="照片相似度"></a>照片相似度</h2><p>我 2016 年曾经写过一篇文章：<a href="http://yulingtianxia.com/blog/2016/01/17/search-for-similar-images/">如何自制一款寻找相似图片的 Mac 工具</a>，原理是通过 RGBA 色彩空间和像素相对位置构造出一个特征向量，然后计算特征向量之间的余弦相似度作为照片的相似度。这种做法在处理移动客户端照片时可以进一步优化：</p><ol><li>手机拍照可以去掉 alpha 通道</li><li>需要对照片降采样，降低计算量</li><li>手机拍照的尺寸相同，宽高比因素可以去掉</li><li>手机拍照具有时序性，只计算比较时间相邻的照片的相似度</li></ol><p>计算特征向量的实现如下：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@objc</span> public class func fingerprintFor(imagePixels: [<span class="built_in">Int32</span>], width: <span class="built_in">Int</span>, height: <span class="built_in">Int</span>) -&gt; [<span class="built_in">UInt32</span>: Double] &#123;</span><br><span class="line">    </span><br><span class="line">    func downsample(component: <span class="built_in">UInt8</span>) -&gt; <span class="built_in">UInt32</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UInt32</span>(component / <span class="number">16</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func downsample(x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span>) -&gt; <span class="built_in">UInt32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> rowCount: <span class="built_in">Int</span> = min(<span class="number">4</span>, height)</span><br><span class="line">        <span class="keyword">let</span> countPerRow: <span class="built_in">Int</span> = min(<span class="number">4</span>, width)</span><br><span class="line">        <span class="keyword">let</span> hStep = width / countPerRow</span><br><span class="line">        <span class="keyword">let</span> vStep = height / rowCount</span><br><span class="line">        <span class="keyword">let</span> row = y / vStep</span><br><span class="line">        <span class="keyword">let</span> col = x / hStep</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UInt32</span>(row * countPerRow + col);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var bucket = [<span class="built_in">UInt32</span>: <span class="built_in">UInt</span>]()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span> ..&lt; height &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; width &#123;</span><br><span class="line">            <span class="keyword">let</span> color = imagePixels[width * j + i]</span><br><span class="line">            <span class="keyword">let</span> r = downsample(component: color.r()) &lt;&lt; <span class="number">24</span></span><br><span class="line">            <span class="keyword">let</span> g = downsample(component: color.g()) &lt;&lt; <span class="number">16</span></span><br><span class="line">            <span class="keyword">let</span> b = downsample(component: color.b()) &lt;&lt; <span class="number">8</span></span><br><span class="line">            <span class="keyword">let</span> location = downsample(x: i, y: j) &lt;&lt; <span class="number">12</span></span><br><span class="line">            <span class="keyword">let</span> fingerprint = r | g | b | location</span><br><span class="line">            bucket[fingerprint] = (bucket[fingerprint] ?? <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result: [<span class="built_in">UInt32</span>: Double] = bucket.mapValues &#123; (oldValue) -&gt; Double <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> newValue = Double(oldValue) / Double(imagePixels.count)</span><br><span class="line">        <span class="keyword">return</span> newValue</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为输入都是像素数组，降采样使用 <code>MPSImageBilinearScale</code>，实现细节类似于上面讲的边缘检测。代码在 <a href="https://github.com/yulingtianxia/PhotoAssessment/blob/master/PhotoAssessment-Sample/Sources/PhotoMPSProcessor.swift" target="_blank" rel="noopener">PhotoMPSProcessor.swift</a> 里。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>算法可以通过调整阈值来平衡准确度与性能。比如降采样的尺寸和相似度阈值都是可以影响到最终结果和性能开销的。这里不再展开讨论。使用 Vision + Core ML 预测图片和人脸识别依然耗时较久，处理 500 张图片可能要几十秒，在生产环境下批量处理图片时需要注意。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://github.com/yulingtianxia/PhotoAssessment" target="_blank" rel="noopener">yulingtianxia/PhotoAssessment</a></li><li><a href="https://www.jianshu.com/p/2334bee37de5" target="_blank" rel="noopener">数字图像 - 边缘检测原理 - Sobel, Laplace, Canny算子</a></li><li><a href="https://github.com/idealo/image-quality-assessment" target="_blank" rel="noopener">idealo/image-quality-assessment</a></li><li><a href="https://github.com/titu1994/neural-image-assessment" target="_blank" rel="noopener">titu1994/neural-image-assessment</a></li><li><a href="https://github.com/truskovskiyk/nima.pytorch" target="_blank" rel="noopener">truskovskiyk/nima.pytorch</a></li><li><a href="https://arxiv.org/abs/1709.05424" target="_blank" rel="noopener">NIMA: Neural Image Assessment</a></li><li><a href="https://ai.googleblog.com/2017/12/introducing-nima-neural-image-assessment.html" target="_blank" rel="noopener">Introducing NIMA: Neural Image Assessment</a></li><li><a href="https://developer.apple.com/documentation/coreml" target="_blank" rel="noopener">Core ML</a></li><li><a href="https://github.com/apple/coremltools" target="_blank" rel="noopener">apple/coremltools</a></li><li><a href="https://forums.developer.apple.com/thread/97218" target="_blank" rel="noopener">MTKTextureLoader fails for 16-big images</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何评价一张照片的质量呢？&lt;/p&gt;
&lt;p&gt;用算法可以客观地评价照片质量，也可以人为主观地给照片打分，并运用机器学习来训练模型。&lt;/p&gt;
&lt;p&gt;我用 Swift 写了个 &lt;a href=&quot;https://github.com/yulingtianxia/PhotoAssessment&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Demo&lt;/a&gt;。用苹果的 Metal 跑一些算法得出客观评分，再用 Core ML 预测主观评分。得到照片评分后，就可以检测相似照片，并从中挑选最优的照片推荐给用户。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/yulingtianxia/PhotoAssessment&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Demo&lt;/a&gt; 中展示了图片在 NIMA 模型预测结合人脸识别的主观评分、图片的 HSB 色彩空间、以及边缘检测结果的平均值和方差。代码兼容 iOS 和 macOS。下面示例图片拍摄自胡里山炮王和西塘。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yulingtianxia/Blog-Hexo-Source/blob/master/source/resources/PhotoAssessment/AssessmentResult1.png?raw=true&quot; alt&gt;&lt;img src=&quot;https://github.com/yulingtianxia/Blog-Hexo-Source/blob/master/source/resources/PhotoAssessment/AssessmentResult2.png?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Machine Leaning" scheme="http://yulingtianxia.com/tags/Machine-Leaning/"/>
    
      <category term="Metal" scheme="http://yulingtianxia.com/tags/Metal/"/>
    
  </entry>
  
  <entry>
    <title>Class written in Swift</title>
    <link href="http://yulingtianxia.com/blog/2018/10/28/Class-written-in-Swift/"/>
    <id>http://yulingtianxia.com/blog/2018/10/28/Class-written-in-Swift/</id>
    <published>2018-10-27T17:13:46.000Z</published>
    <updated>2019-05-26T10:08:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前 <a href="https://github.com/yulingtianxia/TBUIAutoTest" target="_blank" rel="noopener">TBUIAutoTest</a> 有个 <a href="https://github.com/yulingtianxia/TBUIAutoTest/issues/7" target="_blank" rel="noopener">issue</a>，我发现原因跟 Swift 有关，在解决问题时顺带稍微研究了下 Swift 编写的类。</p><a id="more"></a><h2 id="Swift-Class-与-Ivar"><a href="#Swift-Class-与-Ivar" class="headerlink" title="Swift Class 与 Ivar"></a>Swift Class 与 Ivar</h2><p>纯粹的 Swift 类（没继承自 <code>NSObject</code>）在 Runtime 上有很大的坑。虽然 Runtime 的接口都能调用，但因为 <code>Class</code> 实现和构成有很大差异，所以需要谨慎对待。比如 Swift 没有 <code>Ivar</code> 的概念，相应的 Runtime 接口也只是尽可能的封装，不保证返回的内容正确。Swift 将成员变量和属性统一起来，并统一存储和管理。</p><p>其实如果 Swift 类的属性类型是继承自 <code>NSObject</code> 的话，还是可以通过 <code>Ivar</code> 相关 Runtime 函数获取到内容的。这也是 <a href="https://github.com/yulingtianxia/TBUIAutoTest" target="_blank" rel="noopener">TBUIAutoTest</a> 能够兼容 Swift 的原因。有些 Objective-C 类型在 Swift 有对应的替代，比如 <code>NSString</code> 与 <code>String</code>。编译器会自动转换接口和类型，但在这些类型上的属性获取 Ivar 依然有些问题。比如使用 <a href="https://github.com/opensource-apple/objc4/blob/881b875d7aada4cbfc154e022e1297c9526de747/runtime/objc-class.mm#L360" target="_blank" rel="noopener">object_getIvar</a> 就会 <code>BAD_ACCESS</code>。</p><h2 id="Swift-Class-Runtime-Name"><a href="#Swift-Class-Runtime-Name" class="headerlink" title="Swift Class Runtime Name"></a>Swift Class Runtime Name</h2><p>在比较早的 Swift 版本，debug 时我们看到的 Swift 的类名都是一串很长很乱的字符串，其实那是经过 Objective-C Runtime Mangle 后的产物。大概的规则如下：</p><ol><li>前缀是 “_Tt”</li><li>如果是 Class，还会再加一个 “C”，Protocol 会跟着一个 “P”</li><li>Module名连着类名，并在每个名字前面标记字符串长度。</li></ol><p>如今 Swift 正酝酿着一套新的 Mangle 规则，但要等 Objective-C Runtime 那边实现好新的 Demangle 后才能实施！有兴趣可以看下 <a href="https://github.com/apple/swift/blob/1982d024a93b3246edecf6bf42530a835ffc479f/lib/AST/ASTMangler.cpp#L419" target="_blank" rel="noopener">mangleObjCRuntimeName</a> 函数的实现。</p><p>现在 lldb 中打印 Swift 类型更加友好了，但是底层还是会生成一个 Runtime Name。在 <code>$(SWIFT_MODULE_NAME)-Swift.h</code> 文件中可以看到 Swift AST 对应 Objective-C 的头文件，里面就有 Swift Runtime Name。Swift 源码里有个 <a href="https://github.com/apple/swift/blob/master/lib/PrintAsObjC/PrintAsObjC.cpp" target="_blank" rel="noopener">PrintAsObjC.cpp</a> 文件，它的作用就是生成 Swift AST 头文件。</p><p>举个栗子：使用 <code>NSClassFromString(@&quot;_TtC19ClassWrittenInSwift11AppDelegate&quot;)</code> 获取到的类是 <code>ClassWrittenInSwift</code> Module 中的 <code>AppDelegate</code> 类。</p><h2 id="Swift-Class-Check"><a href="#Swift-Class-Check" class="headerlink" title="Swift Class Check"></a>Swift Class Check</h2><p>如何判断一个类是否用 Swift 写的呢？Runtime 中 <code>Class</code> 是有标志位的，只是没对外暴露接口而已。映射到 Runtime 源码中 <code>Class</code> 的内存模型，将标志位取出即可，关键代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">yxy_objc_object</span> &#123;</span></span><br><span class="line">    <span class="keyword">yxy_isa_t</span> isa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class is a Swift class</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IS_SWIFT         (1UL&lt;&lt;0)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">yxy_class_data_bits_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// Values are the FAST_ flags above.</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">getBit</span><span class="params">(<span class="keyword">uintptr_t</span> bit)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bits &amp; bit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSwift</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBit(FAST_IS_SWIFT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">yxy_objc_class</span> :</span> yxy_objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="keyword">yxy_cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    <span class="keyword">yxy_class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">isWrittenInSwift</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls || !object_isClass(cls)) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">yxy_objc_class</span> *<span class="title">objc_cls</span> = (__<span class="title">bridge</span> <span class="title">struct</span> <span class="title">yxy_objc_class</span> *)<span class="title">cls</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> isSwift = objc_cls-&gt;bits.isSwift();</span><br><span class="line">    <span class="keyword">return</span> isSwift;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现很简单，封装了下：<a href="https://github.com/yulingtianxia/ClassWrittenInSwift/blob/master/ClassWrittenInSwiftKit/Source/ClassWrittenInSwift.mm" target="_blank" rel="noopener">ClassWrittenInSwift</a></p><p>哎，自己的 Repo 真是越来越水了。</p><h2 id="Swift-Class-Lazy-Property"><a href="#Swift-Class-Lazy-Property" class="headerlink" title="Swift Class Lazy Property"></a>Swift Class Lazy Property</h2><p>Swift 类的 <code>lazy</code> 属性的存储比较特殊，毕竟是懒加载。它的属性名有个后缀 “.storage”，所以在 Runtime 里获取属性名时要注意，使用时是要过滤掉后缀的。</p><p>写了个简单的接口获取 Swift 类中的 <code>lazy</code> 属性名列表，代码同样放在 <a href="https://github.com/yulingtianxia/ClassWrittenInSwift/blob/master/ClassWrittenInSwiftKit/Source/ClassWrittenInSwift.mm" target="_blank" rel="noopener">ClassWrittenInSwift</a> 里面了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前 &lt;a href=&quot;https://github.com/yulingtianxia/TBUIAutoTest&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TBUIAutoTest&lt;/a&gt; 有个 &lt;a href=&quot;https://github.com/yulingtianxia/TBUIAutoTest/issues/7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;issue&lt;/a&gt;，我发现原因跟 Swift 有关，在解决问题时顺带稍微研究了下 Swift 编写的类。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://yulingtianxia.com/tags/Swift/"/>
    
      <category term="Runtime" scheme="http://yulingtianxia.com/tags/Runtime/"/>
    
  </entry>
  
</feed>
