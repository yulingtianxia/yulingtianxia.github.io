<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yulingtianxia&#39;s blog</title>
  <subtitle>玉令天下的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yulingtianxia.com/"/>
  <updated>2018-12-30T03:26:55.226Z</updated>
  <id>http://yulingtianxia.com/</id>
  
  <author>
    <name>杨萧玉</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DirtyWords for Xcode - 做个文明的程序员</title>
    <link href="http://yulingtianxia.com/blog/2018/12/30/Dirty-Words-for-Xcode/"/>
    <id>http://yulingtianxia.com/blog/2018/12/30/Dirty-Words-for-Xcode/</id>
    <published>2018-12-30T03:26:27.000Z</published>
    <updated>2018-12-30T03:26:55.226Z</updated>
    
    <content type="html">&lt;p&gt;开发者经常会在代码中看到各类脏话，有吐槽产品的瞎改早晚还会改回来的，有吐槽这块代码写的太烂无法直视的，或是干脆心情不好就一顿骂。公司内部的项目想必是无数天坑 f*ck 无数，连对外开源的项目也难逃一劫，比如前一段时间 &lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-8215217&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;OpenJDK&lt;/a&gt; 就因为脏话太多火了一把。&lt;/p&gt;
&lt;p&gt;于是我做了一个 Xcode 插件来寻找代码中的脏话，将其高亮可以被选中，作为一个强提示让开发者修改。目前逻辑还只是简单替换而已，代码在这里：&lt;a href=&quot;https://github.com/yulingtianxia/DirtyWords-for-Xcode&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DirtyWords-for-Xcode&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为了体现汉字的博大精深，瞎画了个 icon，见笑了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yulingtianxia/DirtyWords-for-Xcode/blob/master/images/艹.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;h3 id=&quot;AppStore&quot;&gt;&lt;a href=&quot;#AppStore&quot; class=&quot;headerlink&quot; title=&quot;AppStore&quot;&gt;&lt;/a&gt;AppStore&lt;/h3&gt;&lt;p&gt;圣诞节苹果暂停审核。。。日&lt;br&gt;还没审核通过&lt;/p&gt;
&lt;h3 id=&quot;GitHub-Release&quot;&gt;&lt;a href=&quot;#GitHub-Release&quot; class=&quot;headerlink&quot; title=&quot;GitHub Release&quot;&gt;&lt;/a&gt;GitHub Release&lt;/h3&gt;&lt;p&gt;直接从 GitHub Release 页面下载最新的安装包：&lt;br&gt;&lt;a href=&quot;https://github.com/yulingtianxia/DirtyWords-for-Xcode/releases&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/yulingtianxia/DirtyWords-for-Xcode/releases&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用方式&quot;&gt;&lt;a href=&quot;#使用方式&quot; class=&quot;headerlink&quot; title=&quot;使用方式&quot;&gt;&lt;/a&gt;使用方式&lt;/h2&gt;&lt;p&gt;用法很简单，反正目前也就这么一个功能。Editer -&amp;gt; Dirty Words -&amp;gt; Highlight&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yulingtianxia/DirtyWords-for-Xcode/blob/master/images/usage.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;例如下图中的 “fuck” 就会被高亮，可以文明用语代之。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yulingtianxia/DirtyWords-for-Xcode/blob/master/images/highlight.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果在 Editor 菜单中找不到的话，打开系统偏好设置 -&amp;gt; 拓展，并勾选 “DirtyWords for Xcode” 拓展项.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yulingtianxia/DirtyWords-for-Xcode/blob/master/images/appui.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以给 DirtyWords 自定义快捷键。 Xcode &amp;gt; Preferences &amp;gt; Key Bindings &amp;gt; 搜索 “Dirty Words”.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yulingtianxia/DirtyWords-for-Xcode/blob/master/images/keybindings.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;脏词黑名单&quot;&gt;&lt;a href=&quot;#脏词黑名单&quot; class=&quot;headerlink&quot; title=&quot;脏词黑名单&quot;&gt;&lt;/a&gt;脏词黑名单&lt;/h2&gt;&lt;p&gt;脏词列表文件跟随 app 打包进去了。在拓展加载完成后，也会通过网络下载 &lt;a href=&quot;https://github.com/yulingtianxia/DirtyWords-for-Xcode/blob/master/SourceEditorExtension/dirtywords&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;dirtywords&lt;/a&gt; 文件进行更新。这样方便以后调整脏词列表，也欢迎大家提 PR 补充。&lt;/p&gt;
&lt;p&gt;在收集脏词的过程中真是长了见识了，不搜不知道一搜吓一跳，哈哈。有&lt;a href=&quot;https://github.com/LDNOOBW/List-of-Dirty-Naughty-Obscene-and-Otherwise-Bad-Words&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;各国语言版的&lt;/a&gt;，还有据说是 &lt;a href=&quot;https://github.com/RobertJGabriel/Google-profanity-words&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Google 版的&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;因为分词会比较耗性能，代码中有些 API 其实是触碰脏词的，比如 “UIButton” 中包含了 “butt”，所以有些脏词需要从黑名单剔除，避免误判。不过我觉得 “fuck” 这种词无论怎么组合都难洗白的。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;开发者经常会在代码中看到各类脏话，有吐槽产品的瞎改早晚还会改回来的，有吐槽这块代码写的太烂无法直视的，或是干脆心情不好就一顿骂。公司内部的项目想必是无数天坑 f*ck 无数，连对外开源的项目也难逃一劫，比如前一段时间 &lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-8215217&quot;&gt;OpenJDK&lt;/a&gt; 就因为脏话太多火了一把。&lt;/p&gt;
&lt;p&gt;于是我做了一个 Xcode 插件来寻找代码中的脏话，将其高亮可以被选中，作为一个强提示让开发者修改。目前逻辑还只是简单替换而已，代码在这里：&lt;a href=&quot;https://github.com/yulingtianxia/DirtyWords-for-Xcode&quot;&gt;DirtyWords-for-Xcode&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为了体现汉字的博大精深，瞎画了个 icon，见笑了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yulingtianxia/DirtyWords-for-Xcode/blob/master/images/艹.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用 Metal 和 Core ML 评价照片质量</title>
    <link href="http://yulingtianxia.com/blog/2018/11/30/Photo-Assessment/"/>
    <id>http://yulingtianxia.com/blog/2018/11/30/Photo-Assessment/</id>
    <published>2018-11-30T14:53:14.000Z</published>
    <updated>2018-12-23T07:33:20.335Z</updated>
    
    <content type="html">&lt;p&gt;如何评价一张照片的质量呢？&lt;/p&gt;
&lt;p&gt;用算法可以客观地评价照片质量，也可以人为主观地给照片打分，并运用机器学习来训练模型。&lt;/p&gt;
&lt;p&gt;我用 Swift 写了个 &lt;a href=&quot;https://github.com/yulingtianxia/PhotoAssessment&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Demo&lt;/a&gt;。用苹果的 Metal 跑一些算法得出客观评分，再用 Core ML 预测主观评分。得到照片评分后，就可以检测相似照片，并从中挑选最优的照片推荐给用户。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/yulingtianxia/PhotoAssessment&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Demo&lt;/a&gt; 中展示了图片在 NIMA 模型预测结合人脸识别的主观评分、图片的 HSB 色彩空间、以及边缘检测结果的平均值和方差。代码兼容 iOS 和 macOS。下面示例图片拍摄自胡里山炮王和西塘。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yulingtianxia/Blog-Hexo-Source/blob/master/source/resources/PhotoAssessment/AssessmentResult1.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;https://github.com/yulingtianxia/Blog-Hexo-Source/blob/master/source/resources/PhotoAssessment/AssessmentResult2.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;常规算法&quot;&gt;&lt;a href=&quot;#常规算法&quot; class=&quot;headerlink&quot; title=&quot;常规算法&quot;&gt;&lt;/a&gt;常规算法&lt;/h2&gt;&lt;p&gt;目前业界有很多衡量照片质量的维度，可以通过调整各个维度占的权重来计算照片的最终得分。常用的衡量维度都是一些图形学上的客观因素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;饱和度（HSB/HSV 色彩空间中的 S）&lt;/li&gt;
&lt;li&gt;亮度（HSB/HSV 色彩空间中的 B/V）&lt;/li&gt;
&lt;li&gt;模糊度（边缘检测、二维离散傅里叶）&lt;/li&gt;
&lt;li&gt;颜色分布（线性直方图分布）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;得出的结果可能还需要设定阈值来过滤掉一些质量比较差的照片，然后做归一化和调整加权系数，最终得到照片的评分。具体权重值没有统一的参考标准，需根据业务的需求不断调试和摸索。以上列的这些标准都可以找到一些通用的算法实现，甚至用 OpenCV 分分钟的事儿。但是对于移动客户端来说，OpenCV 可能并不是个好的选择。苹果的 &lt;code&gt;Metal&lt;/code&gt; 技术更适合发挥其软硬件结合的优势，在性能和安装包上均有优势。&lt;/p&gt;
&lt;p&gt;iOS 无法直接创建 HSB 色彩空间，需要借助 &lt;code&gt;UIColor&lt;/code&gt; 等 API 将其他色彩空间颜色转换成 HSB 对应的值。于是我尝试使用 &lt;code&gt;Metal&lt;/code&gt; 实现边缘检测算法，相关代码可以在 &lt;a href=&quot;https://github.com/yulingtianxia/PhotoAssessment/blob/master/PhotoAssessment-Sample/Sources/PhotoMPSProcessor.swift&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PhotoMPSProcessor.swift&lt;/a&gt; 上找到。&lt;/p&gt;
&lt;p&gt;边缘检测有很多种实现，这里我使用的是 Sobel 算子。MPS 提供了很多 对图片做卷积运算的 Filter，其中就包含 &lt;code&gt;MPSImageSobel&lt;/code&gt;。MPS 也提供了 &lt;code&gt;MPSImageLaplacian&lt;/code&gt;，不过 Laplacian 算子对噪声处理较差，实际效果不好。各种算子的原理和介绍可以参考这篇简介：&lt;a href=&quot;https://www.jianshu.com/p/2334bee37de5&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;数字图像 - 边缘检测原理 - Sobel, Laplace, Canny算子&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;苹果的 &lt;code&gt;MetalKit&lt;/code&gt; 拥有更简洁的 API，可以更方便地应用 &lt;code&gt;Metal&lt;/code&gt; 技术。比如加载图片可以通过 &lt;code&gt;MTKTextureLoader&lt;/code&gt; 几行代码轻松搞定。然而在实际应用中却发现是个大坑，比如 rgba16 格式的图片就会报错：”Image decoding failed”。&lt;code&gt;MTKTextureLoader&lt;/code&gt; 应该是只能加载单通道 8 bit 的图片数据，毕竟外部没有传每个像素字节数，解析时估计写死了这个值。所以还是老老实实的用 &lt;code&gt;MTLTextureDescriptor&lt;/code&gt; 描述好 Filter 的数据输入输出格式，并创建好对应的 &lt;code&gt;MTLTexture&lt;/code&gt; 吧。&lt;/p&gt;
&lt;p&gt;Sobel 算子卷积运算后的方差值可以用来检测模糊程度。下面的代码用了两个 Filter 串联起来，三种格式的数据：rgba8[w&lt;em&gt;h]-&amp;gt;r8[w&lt;/em&gt;h]-&amp;gt;r8[2*1]。也就是 RGBA 色彩空间图片转成含有边缘信息的灰度图（如下所示），最后出计算均值和方差。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yulingtianxia/Blog-Hexo-Source/blob/master/source/resources/PhotoAssessment/SobelImageFilter.png?raw=true&quot; alt=&quot;PhotoAssessment&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@objc&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; func edgeDetect(&lt;span class=&quot;string&quot;&gt;imagePixels:&lt;/span&gt; [Int32], &lt;span class=&quot;string&quot;&gt;width:&lt;/span&gt; Int, &lt;span class=&quot;string&quot;&gt;height:&lt;/span&gt; Int, _ &lt;span class=&quot;string&quot;&gt;block:&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@escaping&lt;/span&gt; (_ &lt;span class=&quot;string&quot;&gt;mean:&lt;/span&gt; Int8, _ &lt;span class=&quot;string&quot;&gt;variance:&lt;/span&gt; Int8) -&amp;gt; Void) -&amp;gt; Void &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Make sure the current device supports MetalPerformanceShaders.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    guard MPSSupportsMTLDevice(device) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(&lt;span class=&quot;string&quot;&gt;&quot;Metal Performance Shaders not Supported on current Device&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        block(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var pixels = imagePixels&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// TextureDescriptors&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let sobelSrcTextureDescriptor = MTLTextureDescriptor.texture2DDescriptor(&lt;span class=&quot;string&quot;&gt;pixelFormat:&lt;/span&gt; .rgba8Snorm, &lt;span class=&quot;string&quot;&gt;width:&lt;/span&gt; width, &lt;span class=&quot;string&quot;&gt;height:&lt;/span&gt; height, &lt;span class=&quot;string&quot;&gt;mipmapped:&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sobelSrcTextureDescriptor.usage = [.shaderWrite, .shaderRead]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let sobelDesTextureDescriptor = MTLTextureDescriptor.texture2DDescriptor(&lt;span class=&quot;string&quot;&gt;pixelFormat:&lt;/span&gt; .r8Snorm, &lt;span class=&quot;string&quot;&gt;width:&lt;/span&gt; width, &lt;span class=&quot;string&quot;&gt;height:&lt;/span&gt; height, &lt;span class=&quot;string&quot;&gt;mipmapped:&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sobelDesTextureDescriptor.usage = [.shaderWrite, .shaderRead]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let varianceTextureDescriptor = MTLTextureDescriptor.texture2DDescriptor(&lt;span class=&quot;string&quot;&gt;pixelFormat:&lt;/span&gt; .r8Snorm, &lt;span class=&quot;string&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;mipmapped:&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    varianceTextureDescriptor.usage = [.shaderWrite, .shaderRead]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Textures&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    guard let &lt;span class=&quot;string&quot;&gt;sobelSrcTexture:&lt;/span&gt; MTLTexture = device?.makeTexture(descriptor: sobelSrcTextureDescriptor) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(&lt;span class=&quot;string&quot;&gt;&quot;make sobelSrcTexture failed&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        block(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    guard let &lt;span class=&quot;string&quot;&gt;sobelDesTexture:&lt;/span&gt; MTLTexture = device?.makeTexture(descriptor: sobelDesTextureDescriptor) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(&lt;span class=&quot;string&quot;&gt;&quot;make sobelDesTexture failed&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        block(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    guard let &lt;span class=&quot;string&quot;&gt;varianceTexture:&lt;/span&gt; MTLTexture = device?.makeTexture(descriptor: varianceTextureDescriptor) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(&lt;span class=&quot;string&quot;&gt;&quot;make varianceTexture failed&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        block(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Fill sobelSrcTexture with pixels&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let sobelRegion = MTLRegionMake2D(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, width, height)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sobelSrcTexture.replace(&lt;span class=&quot;string&quot;&gt;region:&lt;/span&gt; sobelRegion, &lt;span class=&quot;string&quot;&gt;mipmapLevel:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;withBytes:&lt;/span&gt; &amp;amp;pixels, &lt;span class=&quot;string&quot;&gt;bytesPerRow:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; * width)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Run Image Filters&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; let commandBuffer = commandQueue?.makeCommandBuffer() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sobel?.encode(commandBuffer: commandBuffer, &lt;span class=&quot;string&quot;&gt;sourceTexture:&lt;/span&gt; sobelSrcTexture, &lt;span class=&quot;string&quot;&gt;destinationTexture:&lt;/span&gt; sobelDesTexture)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        meanAndVariance?.encode(commandBuffer: commandBuffer, &lt;span class=&quot;string&quot;&gt;sourceTexture:&lt;/span&gt; sobelDesTexture, &lt;span class=&quot;string&quot;&gt;destinationTexture:&lt;/span&gt; varianceTexture)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        commandBuffer.addCompletedHandler &amp;#123; (buffer) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            var result = [Int8](repeatElement(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;count:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            let region = MTLRegionMake2D(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            varianceTexture.getBytes(&amp;amp;result, &lt;span class=&quot;string&quot;&gt;bytesPerRow:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;from:&lt;/span&gt; region, &lt;span class=&quot;string&quot;&gt;mipmapLevel:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            block(result.first!, result.last!)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//                let grayImage = self.imageOf(grayTexture: sobelDesTexture)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        commandBuffer.commit()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(&lt;span class=&quot;string&quot;&gt;&quot;make CommandBuffer failed&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        block(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;常规做法都是利用客观评价指标来打分，可以通过设定阈值来过滤掉不符合要求的照片，但没能像大脑一样通过读懂图片的内容来评判质量。&lt;/p&gt;
&lt;h2 id=&quot;机器学习&quot;&gt;&lt;a href=&quot;#机器学习&quot; class=&quot;headerlink&quot; title=&quot;机器学习&quot;&gt;&lt;/a&gt;机器学习&lt;/h2&gt;&lt;p&gt;Google AI Blog 在 2017 年底发表过一篇博客：&lt;a href=&quot;https://ai.googleblog.com/2017/12/introducing-nima-neural-image-assessment.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Introducing NIMA: Neural Image Assessment&lt;/a&gt;。讲述了通过神经网络迁移学习来预测图片评分方法。损失函数为 EMD (earth mover’s distance)，分数分布范围是 1-10 分。先用一些已有的模型在 ImageNet 上预训练，再加个 10 节点的全连接层使用 AVA 等数据集 fune-tune。预测结果是 10 个分数的分布，而不是直接给出评分，所以可以进一步计算出期望分和方差等。&lt;/p&gt;
&lt;p&gt;虽然论文没有给出源码或者训练好的模型，但是网上可以搜到一些第三方的实现。最后使用苹果提供的 coremltools 将其他机器学习框架的模型转成苹果的 Core ML 模型。&lt;/p&gt;
&lt;p&gt;在网上搜索到了几个还算不错的开源实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/idealo/image-quality-assessment&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;idealo/image-quality-assessment&lt;/a&gt;：使用 Keras + Docker + AWS 实现，MobileNet 的完成度较高，提供了 aesthetic 和 technical 两种训练好的评分模型。Keras 模型可以直接转成 mlmodel。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/titu1994/neural-image-assessment&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;titu1994/neural-image-assessment&lt;/a&gt;：使用 Keras 实现，提供了训练好的几种模型。效果最好的为 NASNet Mobile，loss = 0.067。Keras 模型可以直接转成 mlmodel。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/truskovskiyk/nima.pytorch&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;truskovskiyk/nima.pytorch&lt;/a&gt;：使用 pytorch 实现，完成度一般，只提供了 MobileNetV2 模型（loss = 0.08）。pytorch  模型需要先转为 ONNX，然后再转成 mlmodel 格式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;经过反复试验与对比结果，最终使用了第一个开源实现的 MobileNet。在这个过程中踩了不少坑：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;机器学习涉及到的 python 库更新幅度较大，甚至连官方文档更新都严重滞后，更别提网上找的 demo 了。想跑通网上找的代码？不存在的。&lt;/li&gt;
&lt;li&gt;既然官方文档不可信，只能看代码中的注释，在摸索中写。依然会有各种各样的报错，大部分都是版本兼容问题。虽然 coremltools 官网有说兼容的最低版本，但也千万不要直接用最高版本的 Keras 和 TensorFlow。我用的 Keras 2.1.3 和 TensorFlow 1.10，亲测 OK。&lt;/li&gt;
&lt;li&gt;pytorch 转 ONNX 再转 mlmodel 更是麻烦，不得不吐槽机器学习相关的 python 库版本兼容性是真的差，API 说改就改，以为自己是 Swift 么？对于新手来说很不友好，过程几乎就是：改-&amp;gt;报错-&amp;gt;Google-&amp;gt;改-&amp;gt;继续报错。。。官网 demo 从来没跑通过，跟没有一样，不存在的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;转换模型和权重使用的 python 代码放在这里：&lt;a href=&quot;https://github.com/yulingtianxia/PhotoAssessment/blob/master/ConvertMLModel/NIMA/nima.py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;nima.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后转化的 mlmodel 包含在 PhotoAssessment-Sample 工程中：&lt;a href=&quot;https://github.com/yulingtianxia/PhotoAssessment/blob/master/PhotoAssessment-Sample/Sources/MobileNet.mlmodel&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MobileNet.mlmodel&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在得到 mlmodel 后，可以使用苹果的 Vision 框架加载模型，用 &lt;code&gt;VNImageRequestHandler&lt;/code&gt; 请求处理静态图片。串联上 Vision 框架的 &lt;code&gt;VNDetectFaceRectanglesRequest&lt;/code&gt; 可以顺便检测出人脸，为照片评分提供更多的参考。比如有人脸的照片可能是个加分项。&lt;/p&gt;
&lt;p&gt;PS: 这里原本还加入了神经网络识别面部表情，但是由于准确率不高且不同表情的评分难以主观衡量，所以最后去掉了。&lt;/p&gt;
&lt;p&gt;这部分的代码实现在这里： &lt;a href=&quot;https://github.com/yulingtianxia/PhotoAssessment/blob/master/PhotoAssessment-Sample/Sources/PhotoMLProcessor.swift&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PhotoMLProcessor.swift&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;照片相似度&quot;&gt;&lt;a href=&quot;#照片相似度&quot; class=&quot;headerlink&quot; title=&quot;照片相似度&quot;&gt;&lt;/a&gt;照片相似度&lt;/h2&gt;&lt;p&gt;我 2016 年曾经写过一篇文章：&lt;a href=&quot;http://yulingtianxia.com/blog/2016/01/17/search-for-similar-images/&quot;&gt;如何自制一款寻找相似图片的 Mac 工具&lt;/a&gt;，原理是通过 RGBA 色彩空间和像素相对位置构造出一个特征向量，然后计算特征向量之间的余弦相似度作为照片的相似度。这种做法在处理移动客户端照片时可以进一步优化：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;手机拍照可以去掉 alpha 通道&lt;/li&gt;
&lt;li&gt;需要对照片降采样，降低计算量&lt;/li&gt;
&lt;li&gt;手机拍照的尺寸相同，宽高比因素可以去掉&lt;/li&gt;
&lt;li&gt;手机拍照具有时序性，只计算比较时间相邻的照片的相似度&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;计算特征向量的实现如下：&lt;/p&gt;
&lt;figure class=&quot;highlight maxima&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@objc public class func fingerprintFor(imagePixels: [Int32], &lt;span class=&quot;built_in&quot;&gt;width&lt;/span&gt;: Int, &lt;span class=&quot;built_in&quot;&gt;height&lt;/span&gt;: Int) -&amp;gt; [UInt32: Double] &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    func downsample(component: UInt8) -&amp;gt; UInt32 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; UInt32(component / &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    func downsample(x: Int, y: Int) -&amp;gt; UInt32 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;let&lt;/span&gt; rowCount: Int = &lt;span class=&quot;built_in&quot;&gt;min&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;height&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;let&lt;/span&gt; countPerRow: Int = &lt;span class=&quot;built_in&quot;&gt;min&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;width&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;let&lt;/span&gt; hStep = &lt;span class=&quot;built_in&quot;&gt;width&lt;/span&gt; / countPerRow&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;let&lt;/span&gt; vStep = &lt;span class=&quot;built_in&quot;&gt;height&lt;/span&gt; / rowCount&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;row&lt;/span&gt; = y / vStep&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;col&lt;/span&gt; = x / hStep&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; UInt32(&lt;span class=&quot;built_in&quot;&gt;row&lt;/span&gt; * countPerRow + &lt;span class=&quot;built_in&quot;&gt;col&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;var&lt;/span&gt; bucket = [UInt32: UInt]()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ..&amp;lt; &lt;span class=&quot;built_in&quot;&gt;height&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ..&amp;lt; &lt;span class=&quot;built_in&quot;&gt;width&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;color&lt;/span&gt; = imagePixels[&lt;span class=&quot;built_in&quot;&gt;width&lt;/span&gt; * j + i]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;let&lt;/span&gt; r = downsample(component: &lt;span class=&quot;built_in&quot;&gt;color&lt;/span&gt;.r()) &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;let&lt;/span&gt; g = downsample(component: &lt;span class=&quot;built_in&quot;&gt;color&lt;/span&gt;.g()) &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;let&lt;/span&gt; b = downsample(component: &lt;span class=&quot;built_in&quot;&gt;color&lt;/span&gt;.b()) &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;let&lt;/span&gt; location = downsample(x: i, y: j) &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;let&lt;/span&gt; fingerprint = r | g | b | location&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            bucket[fingerprint] = (bucket[fingerprint] ?? &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;let&lt;/span&gt; result: [UInt32: Double] = bucket.mapValues &amp;#123; (oldValue) -&amp;gt; Double &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;let&lt;/span&gt; newValue = Double(oldValue) / Double(imagePixels.count)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; newValue&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; result&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;因为输入都是像素数组，降采样使用 &lt;code&gt;MPSImageBilinearScale&lt;/code&gt;，实现细节类似于上面讲的边缘检测。代码在 &lt;a href=&quot;https://github.com/yulingtianxia/PhotoAssessment/blob/master/PhotoAssessment-Sample/Sources/PhotoMPSProcessor.swift&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PhotoMPSProcessor.swift&lt;/a&gt; 里。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;算法可以通过调整阈值来平衡准确度与性能。比如降采样的尺寸和相似度阈值都是可以影响到最终结果和性能开销的。这里不再展开讨论。使用 Vision + Core ML 预测图片和人脸识别依然耗时较久，处理 500 张图片可能要几十秒，在生产环境下批量处理图片时需要注意。&lt;/p&gt;
&lt;h2 id=&quot;Reference&quot;&gt;&lt;a href=&quot;#Reference&quot; class=&quot;headerlink&quot; title=&quot;Reference&quot;&gt;&lt;/a&gt;Reference&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yulingtianxia/PhotoAssessment&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;yulingtianxia/PhotoAssessment&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/2334bee37de5&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;数字图像 - 边缘检测原理 - Sobel, Laplace, Canny算子&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/idealo/image-quality-assessment&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;idealo/image-quality-assessment&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/titu1994/neural-image-assessment&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;titu1994/neural-image-assessment&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/truskovskiyk/nima.pytorch&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;truskovskiyk/nima.pytorch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1709.05424&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NIMA: Neural Image Assessment&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ai.googleblog.com/2017/12/introducing-nima-neural-image-assessment.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Introducing NIMA: Neural Image Assessment&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/documentation/coreml&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Core ML&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/apple/coremltools&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;apple/coremltools&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://forums.developer.apple.com/thread/97218&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MTKTextureLoader fails for 16-big images&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;如何评价一张照片的质量呢？&lt;/p&gt;
&lt;p&gt;用算法可以客观地评价照片质量，也可以人为主观地给照片打分，并运用机器学习来训练模型。&lt;/p&gt;
&lt;p&gt;我用 Swift 写了个 &lt;a href=&quot;https://github.com/yulingtianxia/PhotoAssessment&quot;&gt;Demo&lt;/a&gt;。用苹果的 Metal 跑一些算法得出客观评分，再用 Core ML 预测主观评分。得到照片评分后，就可以检测相似照片，并从中挑选最优的照片推荐给用户。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/yulingtianxia/PhotoAssessment&quot;&gt;Demo&lt;/a&gt; 中展示了图片在 NIMA 模型预测结合人脸识别的主观评分、图片的 HSB 色彩空间、以及边缘检测结果的平均值和方差。代码兼容 iOS 和 macOS。下面示例图片拍摄自胡里山炮王和西塘。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yulingtianxia/Blog-Hexo-Source/blob/master/source/resources/PhotoAssessment/AssessmentResult1.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;https://github.com/yulingtianxia/Blog-Hexo-Source/blob/master/source/resources/PhotoAssessment/AssessmentResult2.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Machine Leaning" scheme="http://yulingtianxia.com/tags/Machine-Leaning/"/>
    
      <category term="Metal" scheme="http://yulingtianxia.com/tags/Metal/"/>
    
  </entry>
  
  <entry>
    <title>Class written in Swift</title>
    <link href="http://yulingtianxia.com/blog/2018/10/28/Class-written-in-Swift/"/>
    <id>http://yulingtianxia.com/blog/2018/10/28/Class-written-in-Swift/</id>
    <published>2018-10-27T17:13:46.000Z</published>
    <updated>2018-10-27T17:36:48.392Z</updated>
    
    <content type="html">&lt;p&gt;之前 &lt;a href=&quot;https://github.com/yulingtianxia/TBUIAutoTest&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TBUIAutoTest&lt;/a&gt; 有个 &lt;a href=&quot;https://github.com/yulingtianxia/TBUIAutoTest/issues/7&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;issue&lt;/a&gt;，我发现原因跟 Swift 有关，在解决问题时顺带稍微研究了下 Swift 编写的类。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;Swift-Class-与-Ivar&quot;&gt;&lt;a href=&quot;#Swift-Class-与-Ivar&quot; class=&quot;headerlink&quot; title=&quot;Swift Class 与 Ivar&quot;&gt;&lt;/a&gt;Swift Class 与 Ivar&lt;/h2&gt;&lt;p&gt;纯粹的 Swift 类（没继承自 &lt;code&gt;NSObject&lt;/code&gt;）在 Runtime 上有很大的坑。虽然 Runtime 的接口都能调用，但因为 &lt;code&gt;Class&lt;/code&gt; 实现和构成有很大差异，所以需要谨慎对待。比如 Swift 没有 &lt;code&gt;Ivar&lt;/code&gt; 的概念，相应的 Runtime 接口也只是尽可能的封装，不保证返回的内容正确。Swift 将成员变量和属性统一起来，并统一存储和管理。&lt;/p&gt;
&lt;p&gt;其实如果 Swift 类的属性类型是继承自 &lt;code&gt;NSObject&lt;/code&gt; 的话，还是可以通过 &lt;code&gt;Ivar&lt;/code&gt; 相关 Runtime 函数获取到内容的。这也是 &lt;a href=&quot;https://github.com/yulingtianxia/TBUIAutoTest&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TBUIAutoTest&lt;/a&gt; 能够兼容 Swift 的原因。有些 Objective-C 类型在 Swift 有对应的替代，比如 &lt;code&gt;NSString&lt;/code&gt; 与 &lt;code&gt;String&lt;/code&gt;。编译器会自动转换接口和类型，但在这些类型上的属性获取 Ivar 依然有些问题。比如使用 &lt;a href=&quot;https://github.com/opensource-apple/objc4/blob/881b875d7aada4cbfc154e022e1297c9526de747/runtime/objc-class.mm#L360&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;object_getIvar&lt;/a&gt; 就会 &lt;code&gt;BAD_ACCESS&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;Swift-Class-Runtime-Name&quot;&gt;&lt;a href=&quot;#Swift-Class-Runtime-Name&quot; class=&quot;headerlink&quot; title=&quot;Swift Class Runtime Name&quot;&gt;&lt;/a&gt;Swift Class Runtime Name&lt;/h2&gt;&lt;p&gt;在比较早的 Swift 版本，debug 时我们看到的 Swift 的类名都是一串很长很乱的字符串，其实那是经过 Objective-C Runtime Mangle 后的产物。大概的规则如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;前缀是 “_Tt”&lt;/li&gt;
&lt;li&gt;如果是 Class，还会再加一个 “C”，Protocol 会跟着一个 “P”&lt;/li&gt;
&lt;li&gt;Module名连着类名，并在每个名字前面标记字符串长度。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如今 Swift 正酝酿着一套新的 Mangle 规则，但要等 Objective-C Runtime 那边实现好新的 Demangle 后才能实施！有兴趣可以看下 &lt;a href=&quot;https://github.com/apple/swift/blob/1982d024a93b3246edecf6bf42530a835ffc479f/lib/AST/ASTMangler.cpp#L419&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;mangleObjCRuntimeName&lt;/a&gt; 函数的实现。&lt;/p&gt;
&lt;p&gt;现在 lldb 中打印 Swift 类型更加友好了，但是底层还是会生成一个 Runtime Name。在 &lt;code&gt;$(SWIFT_MODULE_NAME)-Swift.h&lt;/code&gt; 文件中可以看到 Swift AST 对应 Objective-C 的头文件，里面就有 Swift Runtime Name。Swift 源码里有个 &lt;a href=&quot;https://github.com/apple/swift/blob/master/lib/PrintAsObjC/PrintAsObjC.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PrintAsObjC.cpp&lt;/a&gt; 文件，它的作用就是生成 Swift AST 头文件。&lt;/p&gt;
&lt;p&gt;举个栗子：使用 &lt;code&gt;NSClassFromString(@&amp;quot;_TtC19ClassWrittenInSwift11AppDelegate&amp;quot;)&lt;/code&gt; 获取到的类是 &lt;code&gt;ClassWrittenInSwift&lt;/code&gt; Module 中的 &lt;code&gt;AppDelegate&lt;/code&gt; 类。&lt;/p&gt;
&lt;h2 id=&quot;Swift-Class-Check&quot;&gt;&lt;a href=&quot;#Swift-Class-Check&quot; class=&quot;headerlink&quot; title=&quot;Swift Class Check&quot;&gt;&lt;/a&gt;Swift Class Check&lt;/h2&gt;&lt;p&gt;如何判断一个类是否用 Swift 写的呢？Runtime 中 &lt;code&gt;Class&lt;/code&gt; 是有标志位的，只是没对外暴露接口而已。映射到 Runtime 源码中 &lt;code&gt;Class&lt;/code&gt; 的内存模型，将标志位取出即可，关键代码如下。&lt;/p&gt;
&lt;figure class=&quot;highlight gauss&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; yxy_objc_object &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    yxy_isa_t isa;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// class is a Swift class&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FAST_IS_SWIFT         (1UL&amp;lt;&amp;lt;0)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; yxy_class_data_bits_t &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Values are the FAST_ flags above.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    uintptr_t bits;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; getBit(uintptr_t bit)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; bits &amp;amp; bit;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; isSwift() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; getBit(FAST_IS_SWIFT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; yxy_objc_class : yxy_objc_object &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Class ISA;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class superclass;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    yxy_cache_t cache;             &lt;span class=&quot;comment&quot;&gt;// formerly cache pointer and vtable&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    yxy_class_data_bits_t bits;    &lt;span class=&quot;comment&quot;&gt;// class_rw_t * plus custom rr/alloc flags&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;BOOL&lt;/span&gt; isWrittenInSwift(Class &lt;span class=&quot;keyword&quot;&gt;cls&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;keyword&quot;&gt;cls&lt;/span&gt; || !object_isClass(&lt;span class=&quot;keyword&quot;&gt;cls&lt;/span&gt;)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; NO;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; yxy_objc_class *objc_cls = (__bridge &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; yxy_objc_class *)&lt;span class=&quot;keyword&quot;&gt;cls&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; isSwift = objc_cls-&amp;gt;bits.isSwift();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; isSwift;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实现很简单，封装了下：&lt;a href=&quot;https://github.com/yulingtianxia/ClassWrittenInSwift/blob/master/ClassWrittenInSwiftKit/Source/ClassWrittenInSwift.mm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ClassWrittenInSwift&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;哎，自己的 Repo 真是越来越水了。&lt;/p&gt;
&lt;h2 id=&quot;Swift-Class-Lazy-Property&quot;&gt;&lt;a href=&quot;#Swift-Class-Lazy-Property&quot; class=&quot;headerlink&quot; title=&quot;Swift Class Lazy Property&quot;&gt;&lt;/a&gt;Swift Class Lazy Property&lt;/h2&gt;&lt;p&gt;Swift 类的 &lt;code&gt;lazy&lt;/code&gt; 属性的存储比较特殊，毕竟是懒加载。它的属性名有个后缀 “.storage”，所以在 Runtime 里获取属性名时要注意，使用时是要过滤掉后缀的。&lt;/p&gt;
&lt;p&gt;写了个简单的接口获取 Swift 类中的 &lt;code&gt;lazy&lt;/code&gt; 属性名列表，代码同样放在 &lt;a href=&quot;https://github.com/yulingtianxia/ClassWrittenInSwift/blob/master/ClassWrittenInSwiftKit/Source/ClassWrittenInSwift.mm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ClassWrittenInSwift&lt;/a&gt; 里面了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;之前 &lt;a href=&quot;https://github.com/yulingtianxia/TBUIAutoTest&quot;&gt;TBUIAutoTest&lt;/a&gt; 有个 &lt;a href=&quot;https://github.com/yulingtianxia/TBUIAutoTest/issues/7&quot;&gt;issue&lt;/a&gt;，我发现原因跟 Swift 有关，在解决问题时顺带稍微研究了下 Swift 编写的类。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://yulingtianxia.com/tags/Swift/"/>
    
      <category term="Runtime" scheme="http://yulingtianxia.com/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>GitHub 虚假 Star 净网行动</title>
    <link href="http://yulingtianxia.com/blog/2018/09/16/Fuck-Fake-GitHub-Stars/"/>
    <id>http://yulingtianxia.com/blog/2018/09/16/Fuck-Fake-GitHub-Stars/</id>
    <published>2018-09-16T08:20:55.000Z</published>
    <updated>2018-09-17T15:18:38.377Z</updated>
    
    <content type="html">&lt;p&gt;前一阵子看到一篇文章 &lt;a href=&quot;https://juejin.im/post/5b8c9310f265da4361530560&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《石锤 github 买 star 行为》&lt;/a&gt;，第一反应是很震惊。是真的很震惊，因为文章中提到的 CocoaDebug 我也 star 了，没想到竟然涉嫌购买 star 炒作，蒙蔽了好多人的双眼。没错，我就是跟风 star，看别的大神 star 啥就顺手 star。 也有的人看 Trending 上啥火顺手 star，甚至用脚本自动 star。&lt;/p&gt;
&lt;p&gt;这条黑产背后到底隐藏着什么？GitHub 上还有哪些大笨蛋也曾靠买 Star 蒙蔽了大神们的双眼呢？我写了个简单的程序用于挖掘基于 Star 的关系链，并进行聚类分析。然后从 CocoaDebug 这个 repo 入手，沿着关系链一层层深挖下去。&lt;/p&gt;
&lt;p&gt;用数据说话，结果一定也会让你大开眼界。正义可能会迟到，但绝不会缺席！&lt;/p&gt;
&lt;p&gt;项目源码：&lt;a href=&quot;https://github.com/yulingtianxia/FuckFakeGitHubStars&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FuckFakeGitHubStars&lt;/a&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;用 GitHub 的 API 获取 repo 有哪些用户 star 了，然后再看看这些用户都 star 了哪些 repo。&lt;/li&gt;
&lt;li&gt;将 star 行为相似的用户和 repo 聚类&lt;/li&gt;
&lt;li&gt;疑似黑产的用户集合一般数量较多，且每个用户 star 的 repo 并不多。将这种集合纳入黑名单。（肯定会有误判，但影响不大）&lt;/li&gt;
&lt;li&gt;计算 repo 的 star 中黑名单用户占比。&lt;/li&gt;
&lt;li&gt;继续遍历黑名单中的用户，挖掘下一层关系链，揪出更多花钱买 star 的 repo。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;爆料&quot;&gt;&lt;a href=&quot;#爆料&quot; class=&quot;headerlink&quot; title=&quot;爆料&quot;&gt;&lt;/a&gt;爆料&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;郑重声明&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;结果不一定准确，仅做参考，毕竟黑名单有误判。&lt;/li&gt;
&lt;li&gt;买 Star 都只是推测，没有交易记录就没有实锤。本文仅是分析 GitHub 社区这一有趣而又奇妙的的现象。&lt;/li&gt;
&lt;li&gt;不排除有人恶意给别人的 Repo 买 Star 的情况，也说不定有人注册了一堆账号喜欢没事给别人 Star 呢！&lt;/li&gt;
&lt;li&gt;由于脚本是广度优先搜索，每个 batch 跑完结果都会更准确。跑完整个 GitHub 需要巨长的时间。跑的 batch 越多，有些 Repo 就越能露出马脚。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于数据量实在是太大了，而且也受限于 GitHub API 请求频率的限制和 CPU 计算的耗时，在上面思路中的第五步中只运行了一部分。当然，全部深挖都只是时间问题，无奈数据量级的恐怖，先把阶段性成果输出下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从 CocoaDebug 入手挖掘出的疑似黑产账号达到了900左右。&lt;/li&gt;
&lt;li&gt;CocoaDebug 有 30% 左右的 Star 可能是买的。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在 &lt;a href=&quot;https://juejin.im/post/5b8c9310f265da4361530560&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《石锤 github 买 star 行为》&lt;/a&gt; 文章中跟 CocoaDebug 一起被揭露的『难兄难弟』所购买的 Star 更为夸张，超过了半数：&lt;/p&gt;
 &lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;repo owner&lt;span class=&quot;regexp&quot;&gt;/name: baoleiji/&lt;/span&gt;QilinBaoleiji stargazer &lt;span class=&quot;string&quot;&gt;num:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1447&lt;/span&gt; black &lt;span class=&quot;string&quot;&gt;percent:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;0.5770559778852798&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;repo owner&lt;span class=&quot;regexp&quot;&gt;/name: 3348375016/&lt;/span&gt;ITSecrets stargazer &lt;span class=&quot;string&quot;&gt;num:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1589&lt;/span&gt; black &lt;span class=&quot;string&quot;&gt;percent:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;0.5173064820641913&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; 当然，再深挖跑一轮数据可能会发现这个比例更大。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Jinxiansen 的 SwiftServerSide-Vapor 曾在 8 月 5 日登上了 Trending，当日收获 104个 Star。如果我没记错的话，mattt 大神也 star 并 follow 过（现在发现又取关了，果然即便蒙蔽了大神的双眼那也只是暂时的事儿）。神奇的是，这个 repo 中有 105 个 Star 疑似来自黑产。附上&lt;a href=&quot;https://www.v2ex.com/t/471479&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇 V 站的贴子更有趣&lt;/a&gt;。这哥们写的另外一个 JHUD 也是同理。&lt;/p&gt;
 &lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;repo owner&lt;span class=&quot;regexp&quot;&gt;/name: Jinxiansen/&lt;/span&gt;SwiftServerSide-Vapor stargazer &lt;span class=&quot;string&quot;&gt;num:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;583&lt;/span&gt; black &lt;span class=&quot;string&quot;&gt;percent:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;0.18010291595197256&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;UCodeUStory 的 S-MVP，你慢慢涨 Star 就能逃得了么？&lt;/p&gt;
 &lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;repo owner&lt;span class=&quot;regexp&quot;&gt;/name: UCodeUStory/&lt;/span&gt;S-MVP stargazer &lt;span class=&quot;string&quot;&gt;num:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1103&lt;/span&gt; black &lt;span class=&quot;string&quot;&gt;percent:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;0.28014505893019037&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;买一个 Star 到底要多少钱啊，有的 repo 还不到一百个 Star，占比还不低呢，也不多买点，真抠啊（我甚至怀疑是黑产为了伪装自己的账号，随意 star 了一些没花钱买 star 的库）：&lt;/p&gt;
 &lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;repo owner&lt;span class=&quot;regexp&quot;&gt;/name: jianhaod/&lt;/span&gt;Kaggle stargazer &lt;span class=&quot;string&quot;&gt;num:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;37&lt;/span&gt; black &lt;span class=&quot;string&quot;&gt;percent:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;0.5945945945945946&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;repo owner&lt;span class=&quot;regexp&quot;&gt;/name: whsgzcy/&lt;/span&gt;DEMOS_TO_MySelf_Android stargazer &lt;span class=&quot;string&quot;&gt;num:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;63&lt;/span&gt; black &lt;span class=&quot;string&quot;&gt;percent:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;0.4603174603174603&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;搞区块链的？7月7日那天涨了 246 个 star，一算比例还真差不多：&lt;/p&gt;
 &lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;repo owner&lt;span class=&quot;regexp&quot;&gt;/name: DeuroIO/&lt;/span&gt;erc20-ico-onchain-technical-analysis stargazer &lt;span class=&quot;string&quot;&gt;num:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;512&lt;/span&gt; black &lt;span class=&quot;string&quot;&gt;percent:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;0.427734375&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;仿豆瓣的、仿知乎的。MelonRice 还有个放虎扑的，我脚本还没扫到它，手动点进去一看 star 的人，还是那尿性，也都 star 了前面那位 Jinxiansen。&lt;/p&gt;
 &lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;repo owner&lt;span class=&quot;regexp&quot;&gt;/name: jianxiaoBai/&lt;/span&gt;douban stargazer &lt;span class=&quot;string&quot;&gt;num:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;288&lt;/span&gt; black &lt;span class=&quot;string&quot;&gt;percent:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;0.3715277777777778&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;repo owner&lt;span class=&quot;regexp&quot;&gt;/name: MelonRice/&lt;/span&gt;zhihudaily_flutter stargazer &lt;span class=&quot;string&quot;&gt;num:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;163&lt;/span&gt; black &lt;span class=&quot;string&quot;&gt;percent:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;0.2085889570552147&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为找出来的数据太多了，这里就不逐个去看了，这里只是随便拎几个出来。&lt;/p&gt;
&lt;p&gt;要是 GitHub API 没有请求限频，再搞个云服务器成天跑，再做个前端页面支持查找，就完美了。要是家里有矿，说不定还能上 GPU 搞神经网络在线学习？！&lt;/p&gt;
&lt;p&gt;我好担心被这些人报复啊。&lt;/p&gt;
&lt;h2 id=&quot;使用方法&quot;&gt;&lt;a href=&quot;#使用方法&quot; class=&quot;headerlink&quot; title=&quot;使用方法&quot;&gt;&lt;/a&gt;使用方法&lt;/h2&gt;&lt;p&gt;直接看 &lt;a href=&quot;https://github.com/yulingtianxia/FuckFakeGitHubStars/blob/master/README.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;README.md&lt;/a&gt; 吧。&lt;/p&gt;
&lt;p&gt;因为 GitHub API 用到的 token 没有上传，所以需要填你自己的 token 才可以抓数据。而且我只上传了部分数据，生成的 json 文件太大了，又懒得用数据库。&lt;/p&gt;
&lt;p&gt;最终的可读性比较强的信息输出在 log 里，没有上传。有兴趣的可以自己跑下。&lt;/p&gt;
&lt;h2 id=&quot;技术实现&quot;&gt;&lt;a href=&quot;#技术实现&quot; class=&quot;headerlink&quot; title=&quot;技术实现&quot;&gt;&lt;/a&gt;技术实现&lt;/h2&gt;&lt;p&gt;技术栈就是 python3 + GraphQL。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;REPOSITORY_STARGAZERS.json&lt;/code&gt; 存储了 repo 有哪些用户 star 了。&lt;code&gt;USER_STAR_REPOSITORIES.json&lt;/code&gt; 存储了用户 star 了哪些 repo。repo 或用户都是一个 node，都有唯一的 node ID。这样就构成了一张有向图。再根据节点的出度或入度集合将节点使用 Jaccard 相似度进行聚类。节点的详细信息以及与其他节点的相似度信息都保存在 &lt;code&gt;NODE_ID_CONTENT.json&lt;/code&gt; 中。整理出的疑似黑产黑名单用户保存在 &lt;code&gt;BLACK_LIST.json&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;最初的设想是在这张巨大的有向图中广度优先遍历，层层扒皮。后来迫于面对现实，就只跑了两层，先有个阶段性结论。可以分析单个 repo star 的黑产占比，想把全网数据一网打尽需要耗费更多的时间成本。&lt;/p&gt;
&lt;p&gt;本项目用到的技术都是现学现卖，纯粹是玩票性质，代码烂的一逼，求轻喷。某大神都深入 Python 底层实现原理开课赚钱了，我还在这边查语法边写垃圾代码，差距太大了哎！&lt;/p&gt;
&lt;h2 id=&quot;后记&quot;&gt;&lt;a href=&quot;#后记&quot; class=&quot;headerlink&quot; title=&quot;后记&quot;&gt;&lt;/a&gt;后记&lt;/h2&gt;&lt;p&gt;愿以后 GitHub 能够清静些，虽然我大清自有国情在，但也别让一些别有用心之人一条臭鱼坏了一坨粥。&lt;/p&gt;
&lt;p&gt;写这篇文章的时候，强台风『山竹』还在蹂躏着深圳。&lt;/p&gt;
&lt;p&gt;就做了一点微小的工作，谢谢大家。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;前一阵子看到一篇文章 &lt;a href=&quot;https://juejin.im/post/5b8c9310f265da4361530560&quot;&gt;《石锤 github 买 star 行为》&lt;/a&gt;，第一反应是很震惊。是真的很震惊，因为文章中提到的 CocoaDebug 我也 star 了，没想到竟然涉嫌购买 star 炒作，蒙蔽了好多人的双眼。没错，我就是跟风 star，看别的大神 star 啥就顺手 star。 也有的人看 Trending 上啥火顺手 star，甚至用脚本自动 star。&lt;/p&gt;
&lt;p&gt;这条黑产背后到底隐藏着什么？GitHub 上还有哪些大笨蛋也曾靠买 Star 蒙蔽了大神们的双眼呢？我写了个简单的程序用于挖掘基于 Star 的关系链，并进行聚类分析。然后从 CocoaDebug 这个 repo 入手，沿着关系链一层层深挖下去。&lt;/p&gt;
&lt;p&gt;用数据说话，结果一定也会让你大开眼界。正义可能会迟到，但绝不会缺席！&lt;/p&gt;
&lt;p&gt;项目源码：&lt;a href=&quot;https://github.com/yulingtianxia/FuckFakeGitHubStars&quot;&gt;FuckFakeGitHubStars&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="GitHub" scheme="http://yulingtianxia.com/tags/GitHub/"/>
    
      <category term="瞎折腾" scheme="http://yulingtianxia.com/tags/%E7%9E%8E%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>iOS 自动化测试标签生成工具接入指南</title>
    <link href="http://yulingtianxia.com/blog/2018/08/13/TBUIAutoTest-Usage/"/>
    <id>http://yulingtianxia.com/blog/2018/08/13/TBUIAutoTest-Usage/</id>
    <published>2018-08-12T16:24:45.000Z</published>
    <updated>2018-09-15T08:28:13.645Z</updated>
    
    <content type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/yulingtianxia/TBUIAutoTest&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TBUIAutoTest&lt;/a&gt; 可以帮开发人员生成UI 控件的标签，便于自动化测试。只需一行代码或一个配置，几乎所有的 iOS Native UI 都会在运行时生成一个页面内唯一且不变的标签。不仅节省了开发人员手动为每个 UI 控件加标签的时间，也节省了测试人员与开发人员的沟通成本。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;#应用场景&quot; class=&quot;headerlink&quot; title=&quot;应用场景&quot;&gt;&lt;/a&gt;应用场景&lt;/h2&gt;&lt;p&gt;目前已经有 QQ、今日头条、兴趣部落、NOW直播等几十款 App 接入 &lt;a href=&quot;https://github.com/yulingtianxia/TBUIAutoTest&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TBUIAutoTest&lt;/a&gt;。阿里系自动化测试开源框架 &lt;a href=&quot;https://github.com/macacajs/iosHookViewId&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Macaca&lt;/a&gt; 也在使用此方案，服务阿里多款 App。&lt;/p&gt;
&lt;p&gt;以往的工作流程是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;测试同学梳理出需要加标签的 UI 控件，通过截图标注给开发同学。&lt;/li&gt;
&lt;li&gt;开发同学按照标注，给相应的 UI 控件手写代码添加标签。（花时间起唯一的标签名，增加安装包体积）&lt;/li&gt;
&lt;li&gt;测试同学使用工具抓取控件树，查看控件标签，编写脚本。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果使用 &lt;a href=&quot;https://github.com/yulingtianxia/TBUIAutoTest&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TBUIAutoTest&lt;/a&gt;，只需要简化成一个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;测试同学使用工具抓取控件树，查看控件标签，编写脚本。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而且几乎是&lt;strong&gt;一劳永逸&lt;/strong&gt;的，后续新增的代码也会在运行时生成标签，&lt;strong&gt;以不变应万变&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;近些年苹果的自动化测试框架经历过一些变化，但是始终是使用无障碍化相关的 API 来获取控件树和标签。&lt;/p&gt;
&lt;p&gt;实现的思路和原理：&lt;a href=&quot;http://yulingtianxia.com/blog/2016/03/28/Add-UITest-Label-for-UIAutomation/&quot;&gt;为 UIAutomation 添加自动化测试标签的探索&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;集成方式&quot;&gt;&lt;a href=&quot;#集成方式&quot; class=&quot;headerlink&quot; title=&quot;集成方式&quot;&gt;&lt;/a&gt;集成方式&lt;/h2&gt;&lt;h3 id=&quot;手动拖拽文件&quot;&gt;&lt;a href=&quot;#手动拖拽文件&quot; class=&quot;headerlink&quot; title=&quot;手动拖拽文件&quot;&gt;&lt;/a&gt;手动拖拽文件&lt;/h3&gt;&lt;p&gt;将 TBUIAutoTest 文件夹内的所有文件加入到工程中即可。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;TB&lt;span class=&quot;built_in&quot;&gt;UIAutoTest&lt;/span&gt;.h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;TB&lt;span class=&quot;built_in&quot;&gt;UIAutoTest&lt;/span&gt;.m&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt;+TB&lt;span class=&quot;built_in&quot;&gt;UIAutoTest&lt;/span&gt;.h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt;+TB&lt;span class=&quot;built_in&quot;&gt;UIAutoTest&lt;/span&gt;.m&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UIResponder&lt;/span&gt;+TB&lt;span class=&quot;built_in&quot;&gt;UIAutoTest&lt;/span&gt;.h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UIResponder&lt;/span&gt;+TB&lt;span class=&quot;built_in&quot;&gt;UIAutoTest&lt;/span&gt;.m&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UIView&lt;/span&gt;+TB&lt;span class=&quot;built_in&quot;&gt;UIAutoTest&lt;/span&gt;.h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UIView&lt;/span&gt;+TB&lt;span class=&quot;built_in&quot;&gt;UIAutoTest&lt;/span&gt;.m&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;CocoaPods&quot;&gt;&lt;a href=&quot;#CocoaPods&quot; class=&quot;headerlink&quot; title=&quot;CocoaPods&quot;&gt;&lt;/a&gt;CocoaPods&lt;/h3&gt;&lt;p&gt;首先要安装 CocoaPods：&lt;/p&gt;
&lt;figure class=&quot;highlight cmake&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;gem &lt;span class=&quot;keyword&quot;&gt;install&lt;/span&gt; cocoapods&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 &lt;code&gt;Podfile&lt;/code&gt; 中添加 TBUIAutoTest。需要将 “MyApp” 替换成自己的名字：&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;source &lt;span class=&quot;string&quot;&gt;&#39;https://github.com/CocoaPods/Specs.git&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;platform &lt;span class=&quot;symbol&quot;&gt;:ios&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;6.0&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;use_frameworks!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;target &lt;span class=&quot;string&quot;&gt;&#39;MyApp&#39;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	pod &lt;span class=&quot;string&quot;&gt;&#39;TBUIAutoTest&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最后需要运行下面的命令行安装下：&lt;/p&gt;
&lt;figure class=&quot;highlight cmake&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pod &lt;span class=&quot;keyword&quot;&gt;install&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Carthage&quot;&gt;&lt;a href=&quot;#Carthage&quot; class=&quot;headerlink&quot; title=&quot;Carthage&quot;&gt;&lt;/a&gt;Carthage&lt;/h3&gt;&lt;p&gt;首先要通过 homebrew 安装 Carthage:&lt;/p&gt;
&lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;brew &lt;/span&gt;update&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;brew &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;install &lt;/span&gt;carthage&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后在 &lt;code&gt;Cartfile&lt;/code&gt; 文件中添加&lt;/p&gt;
&lt;figure class=&quot;highlight nginx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;github&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;yulingtianxia/TBUIAutoTest&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行 &lt;code&gt;carthage update&lt;/code&gt; 命令来获取 &lt;code&gt;TBUIAutoTest.framework&lt;/code&gt;，将其拖拽到工程中使用即可。&lt;/p&gt;
&lt;h2 id=&quot;使用方法&quot;&gt;&lt;a href=&quot;#使用方法&quot; class=&quot;headerlink&quot; title=&quot;使用方法&quot;&gt;&lt;/a&gt;使用方法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;kAutoTestUITurnOnKey&lt;/code&gt; ：是否生成 UI 标签&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kAutoTestUILongPressKey&lt;/code&gt; ：是否开启长按弹窗显示 UI 标签&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/yulingtianxia/TBUIAutoTest&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TBUIAutoTest&lt;/a&gt; 会在 &lt;code&gt;+ load&lt;/code&gt; 方法中从 &lt;code&gt;NSUserDefaults&lt;/code&gt; 中读取 &lt;code&gt;kAutoTestUITurnOnKey&lt;/code&gt; 和 &lt;code&gt;kAutoTestUILongPressKey&lt;/code&gt; 的值。所以在设置这两个 Key 之后，一般需要下次启动 App 才生效。这里推荐拉一条自动化测试专用分支，通过宏控制在 App 启动更早的时机设置这两个 Key。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; kAutoTest&lt;span class=&quot;built_in&quot;&gt;UITurnOnKey&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; kAutoTest&lt;span class=&quot;built_in&quot;&gt;UILongPressKey&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;built_in&quot;&gt;NSUserDefaults&lt;/span&gt;.standardUserDefaults setBool:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt; forKey:kAutoTest&lt;span class=&quot;built_in&quot;&gt;UITurnOnKey&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;built_in&quot;&gt;NSUserDefaults&lt;/span&gt;.standardUserDefaults setBool:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt; forKey:kAutoTest&lt;span class=&quot;built_in&quot;&gt;UILongPressKey&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;注意事项&quot;&gt;&lt;a href=&quot;#注意事项&quot; class=&quot;headerlink&quot; title=&quot;注意事项&quot;&gt;&lt;/a&gt;注意事项&lt;/h2&gt;&lt;p&gt;系统一些自带的 UI 控件的 &lt;code&gt;isAccessibilityElement&lt;/code&gt; 属性默认是 &lt;code&gt;YES&lt;/code&gt;，但是如果想让自定义的 UI 控件能够被捕获，需要手动将其设为 &lt;code&gt;YES&lt;/code&gt;。除此之外还有一些容器控件之间的嵌套场景，需要在容器类中实现 &lt;code&gt;UIAccessibilityContainer&lt;/code&gt;，这样才能捕获到容器控件内的子视图。最简单的一种实现如下：&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-id&quot;&gt;#pragma&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;mark&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;UIAccessibilityContainer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-id&quot;&gt;#ifdef&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;AUTO_TEST_ENV&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;-&lt;/span&gt;(BOOL)&lt;span class=&quot;selector-tag&quot;&gt;isAccessibilityElement&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return NO;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;-&lt;/span&gt; (NSInteger)&lt;span class=&quot;selector-tag&quot;&gt;accessibilityElementCount&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return &lt;span class=&quot;selector-attr&quot;&gt;[[self subviews]&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;count&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;-&lt;/span&gt; (id)&lt;span class=&quot;selector-tag&quot;&gt;accessibilityElementAtIndex&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:(NSInteger)index&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return &lt;span class=&quot;selector-attr&quot;&gt;[[self subviews]&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;objectAtIndex&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:index&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;-&lt;/span&gt; (NSInteger)&lt;span class=&quot;selector-tag&quot;&gt;indexOfAccessibilityElement&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:(id)element&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return &lt;span class=&quot;selector-attr&quot;&gt;[[self subviews]&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;indexOfObject&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:element&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-id&quot;&gt;#endif&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对于那种绘制上去的 UI，但非使用原生 UI 控件的场景，就需要自己创建 &lt;code&gt;UIAccessibilityElement&lt;/code&gt; 对象，并手动设置标签了。这部分其实都是 App 无障碍化的知识，具体细节可以参考苹果官方文档：&lt;a href=&quot;https://developer.apple.com/documentation/uikit/accessibility/uiaccessibilitycontainer?language=objc&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.apple.com/documentation/uikit/accessibility/uiaccessibilitycontainer?language=objc&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/yulingtianxia/TBUIAutoTest&quot;&gt;TBUIAutoTest&lt;/a&gt; 可以帮开发人员生成UI 控件的标签，便于自动化测试。只需一行代码或一个配置，几乎所有的 iOS Native UI 都会在运行时生成一个页面内唯一且不变的标签。不仅节省了开发人员手动为每个 UI 控件加标签的时间，也节省了测试人员与开发人员的沟通成本。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MessageThrottle Safety</title>
    <link href="http://yulingtianxia.com/blog/2018/07/31/MessageThrottle-Safety/"/>
    <id>http://yulingtianxia.com/blog/2018/07/31/MessageThrottle-Safety/</id>
    <published>2018-07-30T16:50:24.000Z</published>
    <updated>2018-09-15T08:28:13.897Z</updated>
    
    <content type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/yulingtianxia/MessageThrottle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MessageThrottle&lt;/a&gt; 是我开发的Objective-C 节流限频组件，其原理基于 Hook 消息转发流程，在运行时应用了一套节流限频的规则。&lt;/p&gt;
&lt;p&gt;新版本再次提升性能的同时，确保了 hook 流程、多线程操作、规则管理的安全性，支持了持久化规则，并对 KVO 等场景进行兼容。&lt;a href=&quot;https://github.com/yulingtianxia/MessageThrottle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MessageThrottle&lt;/a&gt; 的代码测试覆盖率在 80% 以上，在编写测试用例的同时也发现了一些安全隐患，有些甚至是业界知名开源库都没有发现和解决的。&lt;/p&gt;
&lt;p&gt;本文是关于 &lt;a href=&quot;https://github.com/yulingtianxia/MessageThrottle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MessageThrottle&lt;/a&gt; 的第四篇文章。前三篇如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2017/11/05/Objective-C-Message-Throttle-and-Debounce/&quot;&gt;Objective-C Message Throttle and Debounce&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2017/12/15/Associated-Object-and-Dealloc/&quot;&gt;Associated Object 与 Dealloc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2018/05/31/MessageThrottle-Performance-Benchmark-and-Optimization/&quot;&gt;MessageThrottle Performance Benchmark and Optimization&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;主要类的关系如下图，虚线为 &lt;code&gt;weak&lt;/code&gt; 属性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://yulingtianxia.com/resources/MessageThrottle1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;继承链消息转发缺陷&quot;&gt;&lt;a href=&quot;#继承链消息转发缺陷&quot; class=&quot;headerlink&quot; title=&quot;继承链消息转发缺陷&quot;&gt;&lt;/a&gt;继承链消息转发缺陷&lt;/h2&gt;&lt;p&gt;由于是在消息转发流程搞事情，把所有消息都经由一个统一的路由函数 &lt;code&gt;mt_forwardInvocation&lt;/code&gt; 进行处理。子类和父类不能同时 Hook 同一个方法，原因是如果子类的方法调用了父类方法，那么父类的方法调用走到统一路由函数 &lt;code&gt;mt_forwardInvocation&lt;/code&gt; 的时候，『调用父类方法』这一信息早已经丢失了，接着会转发给子类的方法实现，从而造成死循环。最后 crash。&lt;/p&gt;
&lt;p&gt;解决方法就是在 Hook 之前判断关系链，如果已经有子类或者父类被 Hook 了就报错，无法继续 Hook。&lt;/p&gt;
&lt;p&gt;在消息转发流程将所有消息通过统一的路由函数处理并转发这件事的缺陷就是丢失了类的信息，因为全都『统一』到同一个函数处理了，而不是在各自类的内部处理。诸如 Aspects 等业界知名开源库也有此问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://yulingtianxia.com/resources/MessageThrottle2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;兼容-KVO、其他-Hook-框架&quot;&gt;&lt;a href=&quot;#兼容-KVO、其他-Hook-框架&quot; class=&quot;headerlink&quot; title=&quot;兼容 KVO、其他 Hook 框架&quot;&gt;&lt;/a&gt;兼容 KVO、其他 Hook 框架&lt;/h2&gt;&lt;p&gt;首先先了解下 KVO 的原理：当监听类型为 &lt;code&gt;A&lt;/code&gt; 的对象 &lt;code&gt;a&lt;/code&gt; 时，会动态创建 &lt;code&gt;A&lt;/code&gt; 的子类 &lt;code&gt;NSKVONotifying_A&lt;/code&gt;，并把 &lt;code&gt;a&lt;/code&gt; 的类型改成 &lt;code&gt;NSKVONotifying_A&lt;/code&gt;。&lt;code&gt;NSKVONotifying_A&lt;/code&gt; 会覆写监听的属性村粗方法，以及 &lt;code&gt;class&lt;/code&gt; 方法，让外部以为 &lt;code&gt;a&lt;/code&gt; 的类型依然是 &lt;code&gt;A&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;其余开源框架在 hook 一个对象的时候，也是通过加前缀或后缀动态创建子类，然后覆写相关方法。继承链总有先来后到，这时候问题就来了。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;class&lt;/code&gt; 方法获取到的类型可能是被『篡改过』的类，使用 &lt;code&gt;objc_getClass()&lt;/code&gt; 函数获取到的才是真正的类。KVO 的做法是在用 &lt;code&gt;objc_getClass()&lt;/code&gt; 获取到真正的类之后，直接创建带 &lt;code&gt;NSKVONotifying_&lt;/code&gt; 前缀的子类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://yulingtianxia.com/resources/MessageThrottle3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如图所示，MessageThrottle 在 hook 一个对象的时候也会动态创建带前缀 &lt;code&gt;MTSubclassPrefix&lt;/code&gt; 的子类，但是不会像 KVO 那样无脑创建，而是先判断通过 &lt;code&gt;class&lt;/code&gt; 与 &lt;code&gt;objc_getClass()&lt;/code&gt; 获取到的类是否相同。如果不同，则说明已经有现成的子类了，直接在 &lt;code&gt;objc_getClass()&lt;/code&gt; 获取的类中 hook 就行了。这里是借鉴了 Aspects 的做法。&lt;/p&gt;
&lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Class cls&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Class statedClass = [target class]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Class &lt;span class=&quot;keyword&quot;&gt;baseClass &lt;/span&gt;= object_getClass(target)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSString *className = NSStringFromClass(&lt;span class=&quot;keyword&quot;&gt;baseClass);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if ([className hasPrefix:MTSubclassPrefix]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   cls = &lt;span class=&quot;keyword&quot;&gt;baseClass;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;else if (mt_object_isClass(target)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   cls = target&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;else if (statedClass != &lt;span class=&quot;keyword&quot;&gt;baseClass) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   cls = &lt;span class=&quot;keyword&quot;&gt;baseClass;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   const char *&lt;span class=&quot;keyword&quot;&gt;subclassName &lt;/span&gt;= [MTSubclassPrefix stringByAppendingString:className].UTF8String&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   Class &lt;span class=&quot;keyword&quot;&gt;subclass &lt;/span&gt;= objc_getClass(&lt;span class=&quot;keyword&quot;&gt;subclassName);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   if (&lt;span class=&quot;keyword&quot;&gt;subclass &lt;/span&gt;== nil) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;subclass &lt;/span&gt;= objc_allocateClassPair(&lt;span class=&quot;keyword&quot;&gt;baseClass, &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;subclassName, &lt;/span&gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       if (&lt;span class=&quot;keyword&quot;&gt;subclass &lt;/span&gt;== nil) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           NSLog(@&lt;span class=&quot;string&quot;&gt;&quot;objc_allocateClassPair failed to allocate class %s.&quot;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;subclassName);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;           return NO&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       mt_hookedGetClass(&lt;span class=&quot;keyword&quot;&gt;subclass, &lt;/span&gt;statedClass)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       mt_hookedGetClass(object_getClass(&lt;span class=&quot;keyword&quot;&gt;subclass), &lt;/span&gt;statedClass)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       objc_registerClassPair(&lt;span class=&quot;keyword&quot;&gt;subclass);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   object_setClass(target, &lt;span class=&quot;keyword&quot;&gt;subclass);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;   cls = &lt;span class=&quot;keyword&quot;&gt;subclass;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;有来就有回，如果要 remove KVO 或 hook 呢？肯定无法确保各个框架或 KVO add 和 remove『先入后出』的顺序，所以必然要做兼容处理。&lt;/p&gt;
&lt;p&gt;在 revert hook 的时候需要判断真实类型的前缀是否是 &lt;code&gt;MTSubclassPrefix&lt;/code&gt;。如果是，则将实例对象的类型还原回去。最后会判断是否还有其他相同类型的对象也被 hook 了，如果没有，则可以对这个类 revert hook。&lt;/p&gt;
&lt;p&gt;添加 KVO 和应用限频规则有先后顺序，移除 KVO 和废除限频规则也有先后顺序，那么可以排列组合出四种结果：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;初始类为 A&lt;/th&gt;
&lt;th&gt;先添加 KVO&lt;/th&gt;
&lt;th&gt;先应用限频规则&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;先移除 KVO&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;A&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;A&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;先废除限频规则&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;A&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;_MessageThrottle_A&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;PS: &lt;code&gt;MTSubclassPrefix&lt;/code&gt; 常量内容就是 &lt;code&gt;_MessageThrottle_&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;因为通过 &lt;code&gt;MTDealloc&lt;/code&gt; 记录了 hook 的类，所以 revert hook 的时候使用的是当初 hook 的类，而不是当前实例对象真实的类。这主要是针对上面表格中的 『先应用限频规则，先废除限频规则』的情况。在废除规则的时候，真实的类为 &lt;code&gt;NSKVONotifying__MessageThrottle_A&lt;/code&gt;，而当初应用规则时 hook 的类为 &lt;code&gt;_MessageThrottle_A&lt;/code&gt;。这里要注意区分处理下。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; mt_recoverMethod(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; target, SEL selector, SEL aliasSelector)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class cls;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mt_object_isClass(target)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cls = target;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([MTEngine.defaultEngine containsSelector:selector onTargetsOfClass:cls]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        MTDealloc *mtDealloc = objc_getAssociatedObject(target, selector);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// get class when apply rule on target.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cls = mtDealloc.cls;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// target current real class name&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *className = &lt;span class=&quot;built_in&quot;&gt;NSStringFromClass&lt;/span&gt;(object_getClass(target));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([className hasPrefix:MTSubclassPrefix]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Class originalClass = &lt;span class=&quot;built_in&quot;&gt;NSClassFromString&lt;/span&gt;([className stringByReplacingOccurrencesOfString:MTSubclassPrefix withString:&lt;span class=&quot;string&quot;&gt;@&quot;&quot;&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;NSCAssert&lt;/span&gt;(originalClass != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;@&quot;Original class must exist&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (originalClass) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                object_setClass(target, originalClass);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([MTEngine.defaultEngine containsSelector:selector onTarget:cls] ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [MTEngine.defaultEngine containsSelector:selector onTargetsOfClass:cls]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mt_revertHook(cls, selector, aliasSelector);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Revert-Hook-的缺陷&quot;&gt;&lt;a href=&quot;#Revert-Hook-的缺陷&quot; class=&quot;headerlink&quot; title=&quot;Revert Hook 的缺陷&quot;&gt;&lt;/a&gt;Revert Hook 的缺陷&lt;/h2&gt;&lt;p&gt;前提：子类和父类都实现了同一个方法，并且子类的方法会调用 &lt;code&gt;super&lt;/code&gt; 的方法。&lt;/p&gt;
&lt;p&gt;在 Aspects 中有两种异常场景：&lt;/p&gt;
&lt;h3 id=&quot;先-Hook-父类，然后-revert，接着-Hook-子类。最后调用子类实例对象方法。&quot;&gt;&lt;a href=&quot;#先-Hook-父类，然后-revert，接着-Hook-子类。最后调用子类实例对象方法。&quot; class=&quot;headerlink&quot; title=&quot;先 Hook 父类，然后 revert，接着 Hook 子类。最后调用子类实例对象方法。&quot;&gt;&lt;/a&gt;先 Hook 父类，然后 revert，接着 Hook 子类。最后调用子类实例对象方法。&lt;/h3&gt;&lt;p&gt;结果是只执行了父类的方法，子类的方法没执行到。&lt;/p&gt;
&lt;p&gt;原因是当子类没有对应的方法和实现时，&lt;code&gt;instancesRespondToSelector:&lt;/code&gt; 会判断在继承链上查找是否有父类实现了方法。在 hook 某个方法前如果只通过 &lt;code&gt;instancesRespondToSelector:&lt;/code&gt; 来判断是否已经添加过 &lt;code&gt;aliasSelector&lt;/code&gt; 的话，是不够严谨的。父类 hook 后会添加 &lt;code&gt;aliasSelector&lt;/code&gt; 方法，revert 后这个方法还在。hook 子类的时候因为判断出已经有 &lt;code&gt;aliasSelector&lt;/code&gt; 方法了就没给子类添加该方法，实际上子类是继承的父类的实现，结果就是只执行了父类的方法实现。&lt;/p&gt;
&lt;p&gt;MessageThrottle 的解决方案是通过比较父类和子类的 &lt;code&gt;Method&lt;/code&gt; 是否相同。如果 &lt;code&gt;instancesRespondToSelector:&lt;/code&gt; 方法返回 &lt;code&gt;YES&lt;/code&gt; 并且父类和子类的 &lt;code&gt;Method&lt;/code&gt; 相同，那么就说明子类的 Method 是来自父类的，仍然需要为子类添加 &lt;code&gt;aliasSelector&lt;/code&gt; 对应的方法。&lt;/p&gt;
&lt;figure class=&quot;highlight oxygene&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; char *typeEncoding = method_getTypeEncoding(targetMethod);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;Method&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;targetAliasMethod&lt;/span&gt; = &lt;span class=&quot;title&quot;&gt;class_getInstanceMethod&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(cls, aliasSelector)&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;Method&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;targetAliasMethodSuper&lt;/span&gt; = &lt;span class=&quot;title&quot;&gt;class_getInstanceMethod&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(superCls, aliasSelector)&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (![cls instancesRespondToSelector:aliasSelector] || targetAliasMethod == targetAliasMethodSuper) &lt;span class=&quot;comment&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  __unused BOOL addedAlias = class_addMethod(cls, aliasSelector, method_getImplementation(targetMethod), typeEncoding);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  NSCAssert(addedAlias, @&quot;Original implementation for %@ is already copied to %@ on %@&quot;, NSStringFromSelector(selector), NSStringFromSelector(aliasSelector), cls);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class_replaceMethod(cls, &lt;span class=&quot;keyword&quot;&gt;selector&lt;/span&gt;, mt_getMsgForwardIMP(statedClass, &lt;span class=&quot;keyword&quot;&gt;selector&lt;/span&gt;), typeEncoding);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;测试了下 Aspects 的表现，果然是只调用了父类的实现，这是一个很大的漏洞。&lt;/p&gt;
&lt;h3 id=&quot;先-Hook-子类，然后-revert，接着-Hook-父类。最后调用子类实例对象方法。&quot;&gt;&lt;a href=&quot;#先-Hook-子类，然后-revert，接着-Hook-父类。最后调用子类实例对象方法。&quot; class=&quot;headerlink&quot; title=&quot;先 Hook 子类，然后 revert，接着 Hook 父类。最后调用子类实例对象方法。&quot;&gt;&lt;/a&gt;先 Hook 子类，然后 revert，接着 Hook 父类。最后调用子类实例对象方法。&lt;/h3&gt;&lt;p&gt;结果是 crash。&lt;/p&gt;
&lt;p&gt;因为 Objective-C Runtime 没有提供移除方法的 API，所以在 revert hook 的时候，无法将 hook 过的 &lt;code&gt;forwardInvocation:&lt;/code&gt; 方法彻底复原，只能塞入 &lt;code&gt;NSObject&lt;/code&gt; 的默认实现（IMP）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;当子类的方法调用 &lt;code&gt;super&lt;/code&gt; 方法时，因为父类的方法被 hook 了（通过替换 &lt;code&gt;IMP&lt;/code&gt; 为 &lt;code&gt;_objc_msgForward&lt;/code&gt;），会触发调用 &lt;code&gt;forwardInvocation:&lt;/code&gt; 方法。但是子类的 &lt;code&gt;forwardInvocation:&lt;/code&gt; 方法曾经被 Hook 过，所以此时不再是直接调用父类的实现，而是调用子类自己的实现，那么结果就是找不到方法，抛异常。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果子类没被 hook 过，子类是没有 &lt;code&gt;forwardInvocation:&lt;/code&gt; 方法的，会调用父类的方法实现。因为父类被 hook 了，所以会走 MessageThrottle 的消息转发流程，所以是不会出问题的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;两者差别在于，调用 &lt;code&gt;forwardInvocation:&lt;/code&gt; 方法时，已经 Hook 过的类会调用自己的实现，而不会调用父类的实现。&lt;/p&gt;
&lt;p&gt;MessageThrottle 解决方案是记录所有 Hook 过的类，在 Hook 其他类之前先判断下是否已经有子类被 Hook 过。如果有，则作降级处理，打 Log 报错，不能继续 Hook。&lt;/p&gt;
&lt;p&gt;这个方案虽然不完美，但总比抛异常 crash 好。连 Aspects 也没有注意到这点，亲测会 crash。&lt;/p&gt;
&lt;h2 id=&quot;规则持久化&quot;&gt;&lt;a href=&quot;#规则持久化&quot; class=&quot;headerlink&quot; title=&quot;规则持久化&quot;&gt;&lt;/a&gt;规则持久化&lt;/h2&gt;&lt;p&gt;如果限频规则只存在于内存中，那么其实是很不安全的。&lt;/p&gt;
&lt;p&gt;有些场景下限频的周期很长，比如为了减少某条协议请求后台的次数，要求客户端一小时内最多请求一次。如果在一小时内 App 进程杀掉了然后又打开 App，这样就需要限频规则信息能够持久化存储，下次打开 App 读取并应用上次保存的规则。&lt;/p&gt;
&lt;p&gt;对于 &lt;code&gt;target&lt;/code&gt; 为类或元类、&lt;code&gt;MTPerformModeFirstly&lt;/code&gt; 模式下且限频周期大于 5 秒的规则，MessageThrottle 会自动将其标记为持久化规则。&lt;/p&gt;
&lt;p&gt;可以通过设置 &lt;code&gt;MTRule&lt;/code&gt; 的 &lt;code&gt;persistent&lt;/code&gt; 属性为 &lt;code&gt;YES&lt;/code&gt;，来标记规则为需要持久化。对于 &lt;code&gt;target&lt;/code&gt; 为实例对象的规则持久化是无意义的，因为进程杀掉后，实例对象的生命周期也就结束了，规则也就自动失效了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MTRule&lt;/code&gt; 中只有一部分数据能够持久化，一些动态的内容无法持久化，比如队列、block 等。需要注意区分类对象和元类。&lt;/p&gt;
&lt;p&gt;可以使用 &lt;code&gt;savePersistentRules&lt;/code&gt; 方法来保存持久化规则。对于 iOS、macOS 和 tvOS，会在收到 Terminate 通知时自动调用 &lt;code&gt;savePersistentRules&lt;/code&gt; 方法。&lt;/p&gt;
&lt;h2 id=&quot;线程安全&quot;&gt;&lt;a href=&quot;#线程安全&quot; class=&quot;headerlink&quot; title=&quot;线程安全&quot;&gt;&lt;/a&gt;线程安全&lt;/h2&gt;&lt;p&gt;每个 &lt;code&gt;MTRule&lt;/code&gt; 都对应着一个递归锁，保证了此规则上的方法调用是线程安全的。&lt;br&gt;存储所有 target-selector 映射关系的 &lt;code&gt;MTEngine&lt;/code&gt; 添加和废除规则涉及到对 &lt;code&gt;NSMapTable&lt;/code&gt; 和 &lt;code&gt;NSMutableSet&lt;/code&gt; 的操作，使用一个互斥锁来保证 &lt;code&gt;apply&lt;/code&gt;、&lt;code&gt;discard&lt;/code&gt; 和 &lt;code&gt;allRules&lt;/code&gt; 等方法的线程安全。当一个 &lt;code&gt;MTRule&lt;/code&gt; 在多个线程被频繁 &lt;code&gt;apply&lt;/code&gt; 和 &lt;code&gt;discard&lt;/code&gt; 的同时也可能会有这个 &lt;code&gt;MTRule&lt;/code&gt; 的方法在多个线程频繁调用，所以还需要在 &lt;code&gt;apply&lt;/code&gt; 和 &lt;code&gt;discard&lt;/code&gt; 方法里也加一层 &lt;code&gt;MTRule&lt;/code&gt; 的递归锁。&lt;/p&gt;
&lt;p&gt;当然，如果在 hook 或 revert 的过程中调用了方法，但是没有走 MessageThrottle 的转发逻辑的话，还是有可能出现多线程问题。但这样的概率很低，我用下面类似的代码进行测试是 OK 的：&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_async(&lt;span class=&quot;name&quot;&gt;dispatch_get_global_queue&lt;/span&gt;(&lt;span class=&quot;name&quot;&gt;DISPATCH_QUEUE_PRIORITY_DEFAULT&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   for (&lt;span class=&quot;name&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;; i &amp;lt; 10000; i ++) &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       dispatch_async(&lt;span class=&quot;name&quot;&gt;dispatch_get_global_queue&lt;/span&gt;(&lt;span class=&quot;name&quot;&gt;DISPATCH_QUEUE_PRIORITY_DEFAULT&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           [rule apply]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_async(&lt;span class=&quot;name&quot;&gt;dispatch_get_global_queue&lt;/span&gt;(&lt;span class=&quot;name&quot;&gt;DISPATCH_QUEUE_PRIORITY_DEFAULT&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   for (&lt;span class=&quot;name&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;; i &amp;lt; 10000; i ++) &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       dispatch_async(&lt;span class=&quot;name&quot;&gt;dispatch_get_global_queue&lt;/span&gt;(&lt;span class=&quot;name&quot;&gt;DISPATCH_QUEUE_PRIORITY_DEFAULT&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           [self.stub foo:[NSDate date]]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_async(&lt;span class=&quot;name&quot;&gt;dispatch_get_global_queue&lt;/span&gt;(&lt;span class=&quot;name&quot;&gt;DISPATCH_QUEUE_PRIORITY_DEFAULT&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   for (&lt;span class=&quot;name&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;; i &amp;lt; 10000; i ++) &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       dispatch_async(&lt;span class=&quot;name&quot;&gt;dispatch_get_global_queue&lt;/span&gt;(&lt;span class=&quot;name&quot;&gt;DISPATCH_QUEUE_PRIORITY_DEFAULT&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           [rule discard]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_async(&lt;span class=&quot;name&quot;&gt;dispatch_get_global_queue&lt;/span&gt;(&lt;span class=&quot;name&quot;&gt;DISPATCH_QUEUE_PRIORITY_DEFAULT&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   for (&lt;span class=&quot;name&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;; i &amp;lt; 10000; i ++) &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       dispatch_async(&lt;span class=&quot;name&quot;&gt;dispatch_get_global_queue&lt;/span&gt;(&lt;span class=&quot;name&quot;&gt;DISPATCH_QUEUE_PRIORITY_DEFAULT&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           [self.stub foo:[NSDate date]]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;因为 &lt;code&gt;MTPerformModeLast&lt;/code&gt; 和 &lt;code&gt;MTPerformModeDebounce&lt;/code&gt; 都是延时执行模式，所以有可能在延时的过程中，规则已经被废弃了，但是依然会调用到 &lt;code&gt;[invocation invoke]&lt;/code&gt;，而此时需要注意 &lt;code&gt;invocation&lt;/code&gt; 的 &lt;code&gt;selector&lt;/code&gt;。如果规则已经被废弃了，需要使用原始的 &lt;code&gt;selector&lt;/code&gt;，而不是 &lt;code&gt;aliasSelector&lt;/code&gt;。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/yulingtianxia/MessageThrottle&quot;&gt;MessageThrottle&lt;/a&gt; 是我开发的Objective-C 节流限频组件，其原理基于 Hook 消息转发流程，在运行时应用了一套节流限频的规则。&lt;/p&gt;
&lt;p&gt;新版本再次提升性能的同时，确保了 hook 流程、多线程操作、规则管理的安全性，支持了持久化规则，并对 KVO 等场景进行兼容。&lt;a href=&quot;https://github.com/yulingtianxia/MessageThrottle&quot;&gt;MessageThrottle&lt;/a&gt; 的代码测试覆盖率在 80% 以上，在编写测试用例的同时也发现了一些安全隐患，有些甚至是业界知名开源库都没有发现和解决的。&lt;/p&gt;
&lt;p&gt;本文是关于 &lt;a href=&quot;https://github.com/yulingtianxia/MessageThrottle&quot;&gt;MessageThrottle&lt;/a&gt; 的第四篇文章。前三篇如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2017/11/05/Objective-C-Message-Throttle-and-Debounce/&quot;&gt;Objective-C Message Throttle and Debounce&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2017/12/15/Associated-Object-and-Dealloc/&quot;&gt;Associated Object 与 Dealloc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2018/05/31/MessageThrottle-Performance-Benchmark-and-Optimization/&quot;&gt;MessageThrottle Performance Benchmark and Optimization&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yulingtianxia.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>追踪 Objective-C Block 代码定义的位置</title>
    <link href="http://yulingtianxia.com/blog/2018/06/24/Objective-C-Block-Mangle-Name/"/>
    <id>http://yulingtianxia.com/blog/2018/06/24/Objective-C-Block-Mangle-Name/</id>
    <published>2018-06-24T09:19:03.000Z</published>
    <updated>2018-09-15T08:28:13.753Z</updated>
    
    <content type="html">&lt;p&gt;之前写了一篇文章&lt;a href=&quot;http://yulingtianxia.com/blog/2018/03/31/Track-Block-Arguments-of-Objective-C-Method/&quot;&gt;《追踪 Objective-C 方法中的 Block 参数对象》&lt;/a&gt;，利用 &lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BlockHook&lt;/a&gt; 和 Objective-C 的动态特性实现对 block 对象执行和销毁的追踪。本文在此基础上，通过 Mach-O 文件格式获取 Mangle Name 并根据 Clang 源码实现对其解析，探寻如何追踪 block 代码定义的位置。&lt;/p&gt;
&lt;p&gt;主要代码已经整合到 &lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BlockHook&lt;/a&gt; 1.0.2 版本中。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;解决思路&quot;&gt;&lt;a href=&quot;#解决思路&quot; class=&quot;headerlink&quot; title=&quot;解决思路&quot;&gt;&lt;/a&gt;解决思路&lt;/h2&gt;&lt;p&gt;能想到的最直接的方法就是获取 block 内部 invoke 函数的内存地址，并找到这个地址对应的 image，然后根据对基地址的偏移量，利用 dYSM 文件存储的符号表查找到对应代码位置。这属于很常规的操作了，即便没有 dYSM 文件，用 Mach-O 反汇编也能知道 block 定义在哪个方法的大概位置。&lt;/p&gt;
&lt;p&gt;本文完？？？&lt;/p&gt;
&lt;p&gt;太水了！！！&lt;/p&gt;
&lt;p&gt;如果只需要知道 block 定义在哪个方法里的话，其实有更简单的方法呀！在程序运行时就能知道的，不用那么多麻烦的后续操作。解决思路如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过读取每个 Mach-O 镜像文件的符号表，建立 block invoke 函数偏移地址到符号名的映射。&lt;/li&gt;
&lt;li&gt;获取到的符号名是经过 Clang 处理后的 mangle name，根据生成规则反推出 block invoke 函数实现代码位置。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;Mach-O-文件格式&quot;&gt;&lt;a href=&quot;#Mach-O-文件格式&quot; class=&quot;headerlink&quot; title=&quot;Mach-O 文件格式&quot;&gt;&lt;/a&gt;Mach-O 文件格式&lt;/h2&gt;&lt;p&gt;网上关于 Mach-O 文件的介绍一大堆，这里不再赘述。其实就是个二进制文件格式定义，照着文档写代码读二进制内容罢了。苹果也提供了 Mach-O 文件数据结构的定义，直接用就行了。当二进制镜像被加载到虚拟内存中后，就可以通过计算各种偏移量来按图索骥了。下面的代码将 &lt;code&gt;_hunt_blocks_for_image&lt;/code&gt; 注册为镜像加载后的回调函数，这行代码执行前已经加载的镜像也会回调此函数：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;_dyld_register_func_&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;_add_image(_hunt_blocks_&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;_image);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;_hunt_blocks_for_image&lt;/code&gt; 函数会读取一个 Mach-O 文件中的符号表。具体操作是先从遍历 Load Commands 入手，找到 &lt;code&gt;__LINKEDIT&lt;/code&gt; 段的基地址以及符号表数据的偏移量及其字符串表的偏移量。然后遍历符号表，获取到符号地址和符号名的偏移量。如果符号名中包含 &lt;code&gt;_block_invoke&lt;/code&gt; 则说明是 block 实现函数，然后用字典保存符号地址到符号名的映射。&lt;/p&gt;
&lt;p&gt;遍历 Load Commands 时要注意，不同类型的 Load Command 数据类型也不一样，但是肯定会有 &lt;code&gt;cmd&lt;/code&gt; 和 &lt;code&gt;cmdsize&lt;/code&gt; 这两个字段。可以凭借 &lt;code&gt;cmd&lt;/code&gt; 简单区分其数据结构。比如符号表的 &lt;code&gt;cmd&lt;/code&gt; 是 &lt;code&gt;LC_SYMTAB&lt;/code&gt;，其数据结构为 &lt;code&gt;symtab_command&lt;/code&gt;。比如常见的 &lt;code&gt;cmd&lt;/code&gt; 为 &lt;code&gt;LC_SEGMENT&lt;/code&gt; 的『段』可以靠 &lt;code&gt;segname&lt;/code&gt; 区分，类型有 &lt;code&gt;__PAGEZERO&lt;/code&gt; &lt;code&gt;__TEXT&lt;/code&gt; &lt;code&gt;__DATA&lt;/code&gt; &lt;code&gt;__LINKEDIT&lt;/code&gt; &lt;code&gt;__OBJC&lt;/code&gt; 等等，有的『段』下面还有很多『节』(Section)。&lt;code&gt;__PAGEZERO&lt;/code&gt; 段在可执行文件才有，大小跟架构有关，是虚拟内存基地址。符号表是一个 &lt;code&gt;nlist&lt;/code&gt; 数组，保存着每个符号的一些信息，这里只用到了符号地址和符号名。&lt;/p&gt;
&lt;p&gt;因为使用 &lt;code&gt;NSMapTable&lt;/code&gt; 存储符号地址和符号名的映射，所以需要用 &lt;code&gt;pthread_mutex_t&lt;/code&gt; 确保线程安全。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;_hunt_blocks_for_image&lt;/code&gt; 函数实现如下。我觉得我思想解释的够明白了，对于看过 fishhook 源码的人来说应该很简单。实在看不懂就自己对照着 MachOView 和苹果文档，随便找个方法计算一遍偏移量就好了。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; NSMapTable *block_invoke_mangle_cache;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;pthread_mutex_t&lt;/span&gt; block_invoke_mangle_cache_mutex;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; _hunt_blocks_for_image(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; mach_header *header, &lt;span class=&quot;keyword&quot;&gt;intptr_t&lt;/span&gt; slide) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Dl_info info;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (dladdr(header, &amp;amp;info) == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;segment_command_t&lt;/span&gt; *cur_seg_cmd;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;segment_command_t&lt;/span&gt; *linkedit_segment = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;segment_command_t&lt;/span&gt; *pagezero_segment = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; symtab_command* symtab_cmd = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uintptr_t&lt;/span&gt; cur = (&lt;span class=&quot;keyword&quot;&gt;uintptr_t&lt;/span&gt;)header + &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;mach_header_t&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (uint i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; header-&amp;gt;ncmds; i++, cur += cur_seg_cmd-&amp;gt;cmdsize) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cur_seg_cmd = (&lt;span class=&quot;keyword&quot;&gt;segment_command_t&lt;/span&gt; *)cur;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (cur_seg_cmd-&amp;gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;strcmp&lt;/span&gt;(cur_seg_cmd-&amp;gt;segname, SEG_LINKEDIT) == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                linkedit_segment = cur_seg_cmd;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (strcmp(SEG_PAGEZERO, cur_seg_cmd-&amp;gt;segname) == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                pagezero_segment = (&lt;span class=&quot;keyword&quot;&gt;segment_command_t&lt;/span&gt;*)cur_seg_cmd;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (cur_seg_cmd-&amp;gt;cmd == LC_SYMTAB) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            symtab_cmd = (struct symtab_command*)cur_seg_cmd;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!symtab_cmd || !linkedit_segment ) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uintptr_t&lt;/span&gt; linkedit_base = (&lt;span class=&quot;keyword&quot;&gt;uintptr_t&lt;/span&gt;)slide + linkedit_segment-&amp;gt;vmaddr - linkedit_segment-&amp;gt;fileoff;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;nlist_t&lt;/span&gt; *symtab = (&lt;span class=&quot;keyword&quot;&gt;nlist_t&lt;/span&gt; *)(linkedit_base + symtab_cmd-&amp;gt;symoff);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *strtab = (char *)(linkedit_base + symtab_cmd-&amp;gt;stroff);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_mutex_lock(&amp;amp;block_invoke_mangle_cache_mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!block_invoke_mangle_cache) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        block_invoke_mangle_cache = [NSMapTable mapTableWithKeyOptions:NSPointerFunctionsOpaqueMemory | NSMapTableObjectPointerPersonality valueOptions:NSPointerFunctionsCopyIn];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (uint i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; symtab_cmd-&amp;gt;nsyms; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt; strtab_offset = symtab[i].n_un.n_strx;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *symbol_name = strtab + strtab_offset;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; symbol_name_longer_than_1 = symbol_name[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] &amp;amp;&amp;amp; symbol_name[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!symbol_name_longer_than_1) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;uintptr_t&lt;/span&gt; block_addr = (&lt;span class=&quot;keyword&quot;&gt;uintptr_t&lt;/span&gt;)info.dli_fbase + symtab[i].n_value - (pagezero_segment ? pagezero_segment-&amp;gt;vmsize : &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSString *symbolName = [NSString stringWithUTF8String:&amp;amp;symbol_name[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSRange range = [symbolName rangeOfString:@&lt;span class=&quot;string&quot;&gt;&quot;_block_invoke&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (range.location != NSNotFound &amp;amp;&amp;amp; range.location &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [block_invoke_mangle_cache setObject:symbolName forKey:(__bridge id)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *)block_addr];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_mutex_unlock(&amp;amp;block_invoke_mangle_cache_mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Block-Mangle-Name&quot;&gt;&lt;a href=&quot;#Block-Mangle-Name&quot; class=&quot;headerlink&quot; title=&quot;Block Mangle Name&quot;&gt;&lt;/a&gt;Block Mangle Name&lt;/h2&gt;&lt;p&gt;Clang 7.0.0 源码的 &lt;a href=&quot;https://clang.llvm.org/doxygen/Mangle_8cpp_source.html#l00060&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Mangle.cpp&lt;/a&gt; 文件实现了 Objective-C 和 block 的 mangle name。只需要看 &lt;code&gt;mangleBlock&lt;/code&gt; 和 &lt;code&gt;mangleGlobalBlock&lt;/code&gt; 两个函数即可大概了解 block mangle name 的生成规则。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;全局 block：block 变量名 + &lt;code&gt;_block_invoke&lt;/code&gt; + &lt;code&gt;discriminator&lt;/code&gt;。详见 &lt;code&gt;mangleGlobalBlock&lt;/code&gt; 函数实现。&lt;/li&gt;
&lt;li&gt;其他 block：&lt;code&gt;__&lt;/code&gt; + block 代码所处的函数或方法的 mangle name + &lt;code&gt;_block_invoke&lt;/code&gt; + &lt;code&gt;discriminator&lt;/code&gt;。详见 &lt;code&gt;mangleBlock&lt;/code&gt; 函数实现。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要注意的是 &lt;code&gt;discriminator&lt;/code&gt; 是从第二个才开始显示的。比如在 &lt;code&gt;Foo&lt;/code&gt; 类的 &lt;code&gt;bar&lt;/code&gt; 方法中定义了两个 block，那么这两个 block 的 mangle name 就是 &lt;code&gt;__10_-[Foo bar]_block_invoke&lt;/code&gt; 和 &lt;code&gt;__10_-[Foo bar]_block_invoke_2&lt;/code&gt;。在 gcc 里稍有区别，第一个 block 的 mangle name 也会显示 &lt;code&gt;discriminator&lt;/code&gt;。前面的 “10” 是方法名 &lt;code&gt;-[Foo bar]&lt;/code&gt; 的字符串长度。这部分属于 Objective-C 方法名的 mangle name 规则，C++ 函数也有类似的规则，不仅用数字保存字符串长度，还有其他字母表示方法类型和参数类型等。这里不展开细讲了，看源码都能找到。&lt;/p&gt;
&lt;p&gt;于是只要能拿到 mangle name，就能推断出定义 block 代码所处的位置咯。不带 &lt;code&gt;__&lt;/code&gt; 的就是全局 block 咯？我并没有打算写代码来解析下 mangle name 的规则，还是交给调用方去使用吧。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BlockHook&lt;/a&gt; 的 &lt;code&gt;BHToken&lt;/code&gt; 类新增了 &lt;code&gt;mangleName&lt;/code&gt; 属性，只需要使用原始的 invoke 函数地址作为 Key 即可从字典里获得这个 block 对应的 &lt;code&gt;mangleName&lt;/code&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight erlang&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- &lt;span class=&quot;params&quot;&gt;(NSString *)&lt;/span&gt;mangleName&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if &lt;span class=&quot;params&quot;&gt;(!_mangleName)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        pthread_mutex_lock&lt;span class=&quot;params&quot;&gt;(&amp;amp;block_invoke_mangle_cache_mutex)&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if &lt;span class=&quot;params&quot;&gt;(_originInvoke)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            _mangleName = [block_invoke_mangle_cache objectForKey:&lt;span class=&quot;params&quot;&gt;(__bridge id)&lt;/span&gt;_originInvoke];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        pthread_mutex_unlock&lt;span class=&quot;params&quot;&gt;(&amp;amp;block_invoke_mangle_cache_mutex)&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return _mangleName;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里有个多次 hook 的问题。所谓的 &lt;code&gt;_originInvoke&lt;/code&gt; 只是这次 hook 相对的原始实现函数，它可能处在多次 hook 中的一环，而不是最原始的 block 实现，此时是拿不到 &lt;code&gt;mangleName&lt;/code&gt;。所以需要用第一次 hook block 的 token 来获取 &lt;code&gt;mangleName&lt;/code&gt;。PS:想搞倒是可以搞，把 hook block 产生的 token 都保存起来，然后按照 &lt;code&gt;_originInvoke&lt;/code&gt; 和 &lt;code&gt;_replacementInvoke&lt;/code&gt; 顺藤摸瓜就行，不难，顺便还能解决 &lt;code&gt;remove&lt;/code&gt; 操作的顺序问题。我懒的搞，目前场景太小意义不大。&lt;/p&gt;
&lt;p&gt;想了解 &lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BlockHook&lt;/a&gt; 原理的，可以看这篇文章：&lt;a href=&quot;http://yulingtianxia.com/blog/2018/02/28/Hook-Objective-C-Block-with-Libffi/&quot;&gt;Hook Objective-C Block with Libffi&lt;/a&gt;。（继续疯狂炒冷饭。。。）&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;目前 &lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BlockHook&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/yulingtianxia/BlockTracker&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BlockTracker&lt;/a&gt; 都已经支持获取 block 的 mangle name 了。&lt;/p&gt;
&lt;p&gt;不知道 dyld 3 强制应用后会不会对此有影响，我就是遍历这个二进制文件自己的符号表而已呀，动态重定向的我又不 care。反正 fishhook 到时候估计是 gg 了，因为 dyld 3 会在加载时解析所有符号表，也就是固定下来了，没跳板了。&lt;/p&gt;
&lt;p&gt;然而我还是这么菜，赶在月底前写了个篇幅短小全是常识的大水文。。。&lt;/p&gt;
&lt;p&gt;本文完。。。&lt;/p&gt;
&lt;p&gt;太水了！！！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;之前写了一篇文章&lt;a href=&quot;http://yulingtianxia.com/blog/2018/03/31/Track-Block-Arguments-of-Objective-C-Method/&quot;&gt;《追踪 Objective-C 方法中的 Block 参数对象》&lt;/a&gt;，利用 &lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot;&gt;BlockHook&lt;/a&gt; 和 Objective-C 的动态特性实现对 block 对象执行和销毁的追踪。本文在此基础上，通过 Mach-O 文件格式获取 Mangle Name 并根据 Clang 源码实现对其解析，探寻如何追踪 block 代码定义的位置。&lt;/p&gt;
&lt;p&gt;主要代码已经整合到 &lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot;&gt;BlockHook&lt;/a&gt; 1.0.2 版本中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yulingtianxia.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>MessageThrottle Performance Benchmark and Optimization</title>
    <link href="http://yulingtianxia.com/blog/2018/05/31/MessageThrottle-Performance-Benchmark-and-Optimization/"/>
    <id>http://yulingtianxia.com/blog/2018/05/31/MessageThrottle-Performance-Benchmark-and-Optimization/</id>
    <published>2018-05-30T18:01:50.000Z</published>
    <updated>2018-09-15T08:28:13.562Z</updated>
    
    <content type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/yulingtianxia/MessageThrottle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MessageThrottle&lt;/a&gt; 是我开发的Objective-C 节流限频组件，其原理基于 Hook 消息转发流程，所以相比直接调用方法，会有一些性能上的损耗。本篇文章记录了对其性能进行测试的结果，并通过使用 &lt;code&gt;NSMapTable&lt;/code&gt; 改进存储结构和缓存来对性能进行大幅度的优化。&lt;/p&gt;
&lt;p&gt;这是你从未体验过的船新版本。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;关于 &lt;a href=&quot;https://github.com/yulingtianxia/MessageThrottle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MessageThrottle&lt;/a&gt; 最初的实现原理可以参考 &lt;a href=&quot;http://yulingtianxia.com/blog/2017/11/05/Objective-C-Message-Throttle-and-Debounce/&quot;&gt;Objective-C Message Throttle and Debounce&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;Benchmark&quot;&gt;&lt;a href=&quot;#Benchmark&quot; class=&quot;headerlink&quot; title=&quot;Benchmark&quot;&gt;&lt;/a&gt;Benchmark&lt;/h2&gt;&lt;p&gt;Xcode 自带的单元测试框架可以很方便的测量一个方法的执行效率，&lt;code&gt;measureBlock&lt;/code&gt; 里的代码会被执行十次，测试结束后会得到每次执行耗时，以及平均数和方差。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)testPerformanceExample &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// This is an example of a performance test case.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSDate&lt;/span&gt; *date = [&lt;span class=&quot;built_in&quot;&gt;NSDate&lt;/span&gt; date];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; measureBlock:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Put the code you want to measure the time of here.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;; i ++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;@autoreleasepool&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.sstub foo:date];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;性能损耗大多发生在消息转发流程上的处理，为了能够校准基线，需要让每次消息发送都执行。MessageThrottle 1.2.0 刚刚支持了让某些条件下消息永远执行的特性：&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)setUp &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; setUp];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Put setup code here. This method is called before the invocation of each test method in the class.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.sstub = [SuperStub &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MTRule *rule = [self.sstub &lt;span class=&quot;string&quot;&gt;mt_limitSelector:&lt;/span&gt;&lt;span class=&quot;meta&quot;&gt;@selector&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;foo:&lt;/span&gt;) &lt;span class=&quot;string&quot;&gt;oncePerDuration:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;usingMode:&lt;/span&gt;MTPerformModeDebounce];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rule.alwaysInvokeBlock =  ^(MTRule *rule, NSDate *date) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; YES; &lt;span class=&quot;comment&quot;&gt;// 让消息永远都执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过调整 &lt;code&gt;foo:&lt;/code&gt; 方法的耗时来得到调用不同耗时函数的测试结果。&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;-&lt;/span&gt; (void)&lt;span class=&quot;selector-tag&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:(NSDate&lt;/span&gt; *)&lt;span class=&quot;selector-tag&quot;&gt;arg&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;selector-attr&quot;&gt;[NSThread sleepForTimeInterval:0.0001]&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最终得到一组数据，测试机器为 iPhone 8 plus。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;执行模式\被调用方法耗时&lt;/th&gt;
&lt;th&gt;0.0001&lt;/th&gt;
&lt;th&gt;0.001&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;不使用 MT&lt;/td&gt;
&lt;td&gt;0.118(baseline)&lt;/td&gt;
&lt;td&gt;1.17(baseline)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MT 立即执行&lt;/td&gt;
&lt;td&gt;0.135(14.4%worse)&lt;/td&gt;
&lt;td&gt;1.33(13.8%worse)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MT debounce 0.01s&lt;/td&gt;
&lt;td&gt;0.0281(76.2%better)&lt;/td&gt;
&lt;td&gt;0.0279(97.6%better)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol&gt;
&lt;li&gt;测试的基准数据为不使用 MessageThottle，直接调用方法。&lt;/li&gt;
&lt;li&gt;使用 MessageThottle 后，消息转发流程会带来多余的耗时会导致性能下降，而且被调用方法耗时越少，性能下降得越明显（比较两列数据）。&lt;/li&gt;
&lt;li&gt;如果加了消息限频，会忽略掉一部分调用，这样当出现大量频繁调用时，方法真正执行的次数很少，性能反而大大提升了（第三行数据）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;Optimization&quot;&gt;&lt;a href=&quot;#Optimization&quot; class=&quot;headerlink&quot; title=&quot;Optimization&quot;&gt;&lt;/a&gt;Optimization&lt;/h2&gt;&lt;p&gt;通过性能优化，将消息转发流程产生的耗时降低了将近 50%。并加强了线程安全。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;执行模式\被调用方法耗时&lt;/th&gt;
&lt;th&gt;0.0001&lt;/th&gt;
&lt;th&gt;0.001&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;不使用 MT&lt;/td&gt;
&lt;td&gt;0.118(baseline)&lt;/td&gt;
&lt;td&gt;1.17(baseline)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MT 立即执行&lt;/td&gt;
&lt;td&gt;0.135(14.4%worse)&lt;/td&gt;
&lt;td&gt;1.33(13.8%worse)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;性能优化后&lt;/td&gt;
&lt;td&gt;0.126(6.88%worse)&lt;/td&gt;
&lt;td&gt;1.25(6.93%worse)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;为了方便管理和查看所有的 &lt;code&gt;MTRule&lt;/code&gt;，使用了 &lt;code&gt;MTEngine&lt;/code&gt; 单例进行中心化的管理。获取一个 &lt;code&gt;MTRule&lt;/code&gt; 之前，需要先用 &lt;code&gt;target&lt;/code&gt; 和 &lt;code&gt;selector&lt;/code&gt; 生成一个描述字符串，然后用这个字符串作为 Key 在 &lt;code&gt;MTEngine&lt;/code&gt; 的字典里查询对应的 &lt;code&gt;MTRule&lt;/code&gt; 对象。每次应用和废除规则、消息发送时都要频繁从 &lt;code&gt;MTEngine&lt;/code&gt; 获取 &lt;code&gt;MTRule&lt;/code&gt; 对象，由此也产生了大量开销。这里的性能瓶颈主要有两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;生成描述字符串造成的开销。&lt;/li&gt;
&lt;li&gt;从 &lt;code&gt;MTEngine&lt;/code&gt; 加锁的字典获取 &lt;code&gt;MTRule&lt;/code&gt; 的等待开销。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;应用和废除规则的时候，这两点开销并不明显。但当所有应用规则的消息发送都要经过这两步的时候，这俨然成了拥堵的重灾区。当然治理方案也是相对的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;改进 &lt;code&gt;MTEngine&lt;/code&gt; 中字典的存储结构，使用 &lt;code&gt;NSMapTable&lt;/code&gt; 替换 &lt;code&gt;NSMutableDictionary&lt;/code&gt;。因为 &lt;code&gt;NSMapTable&lt;/code&gt; 支持将任意指针作为 Key 且无需持有，可以将 &lt;code&gt;target&lt;/code&gt; 作为 Key，Value 为这个 &lt;code&gt;target&lt;/code&gt; 对应的 &lt;code&gt;selector&lt;/code&gt; 集合。&lt;code&gt;MTEngine&lt;/code&gt; 不再持有 &lt;code&gt;MTRule&lt;/code&gt; 对象，而只是存储了所有应用规则的 &lt;code&gt;target&lt;/code&gt; 及其 &lt;code&gt;selector&lt;/code&gt;。而 &lt;code&gt;MTRule&lt;/code&gt; 对象改为由其 &lt;code&gt;target&lt;/code&gt; 通过 AssociatedObject 的方式持有，可以很方便通过 &lt;code&gt;selector&lt;/code&gt; 存取。当 &lt;code&gt;target&lt;/code&gt; 销毁后，它关联的 &lt;code&gt;MTRule&lt;/code&gt; 对象也会被销毁，&lt;code&gt;NSMapTable&lt;/code&gt; 也会自动移除那些键或值为 &lt;code&gt;nil&lt;/code&gt; 的数据。下面是 &lt;code&gt;MTEngine&lt;/code&gt; 封装了 &lt;code&gt;NSMapTable&lt;/code&gt; 字典对应的便捷方法。&lt;/p&gt;
 &lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;_targetSELs = [&lt;span class=&quot;built_in&quot;&gt;NSMapTable&lt;/span&gt; weakToStrongObjectsMapTable];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//添加 target-selector 记录&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)addSelector:(SEL)selector onTarget:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)target&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!target) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSMutableSet&lt;/span&gt; *selectors = [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.targetSELs objectForKey:target];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!selectors) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        selectors = [&lt;span class=&quot;built_in&quot;&gt;NSMutableSet&lt;/span&gt; set];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [selectors addObject:&lt;span class=&quot;built_in&quot;&gt;NSStringFromSelector&lt;/span&gt;(selector)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.targetSELs setObject:selectors forKey:target];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//移除 target-selector 记录&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)removeSelector:(SEL)selector onTarget:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)target&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!target) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSMutableSet&lt;/span&gt; *selectors = [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.targetSELs objectForKey:target];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!selectors) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        selectors = [&lt;span class=&quot;built_in&quot;&gt;NSMutableSet&lt;/span&gt; set];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [selectors removeObject:&lt;span class=&quot;built_in&quot;&gt;NSStringFromSelector&lt;/span&gt;(selector)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.targetSELs setObject:selectors forKey:target];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//是否存在 target-selector 记录&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)containsSelector:(SEL)selector onTarget:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)target&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.targetSELs objectForKey:target] containsObject:&lt;span class=&quot;built_in&quot;&gt;NSStringFromSelector&lt;/span&gt;(selector)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//是否存在 target-selector 记录，未指定具体 target，但 target 的类型为 cls 即可&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)containsSelector:(SEL)selector onTargetsOfClass:(Class)cls&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; target &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; [[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.targetSELs keyEnumerator] allObjects]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!mt_object_isClass(target) &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [target isMemberOfClass:cls] &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.targetSELs objectForKey:target] containsObject:&lt;span class=&quot;built_in&quot;&gt;NSStringFromSelector&lt;/span&gt;(selector)]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每个 &lt;code&gt;MTRule&lt;/code&gt; 有自己独立的递归锁，这样避免了在 &lt;code&gt;forwardInvocation&lt;/code&gt; 里千军万马过独木桥的拥堵，且不妨碍递归调用的场景。存取 &lt;code&gt;MTEngine&lt;/code&gt; 的字典依然使用普通的互斥锁。这两个锁都使用性能较好的 &lt;code&gt;pthread_mutex_t&lt;/code&gt; 实现。&lt;/p&gt;
 &lt;figure class=&quot;highlight dns&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; // 初始化递归锁&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; pthread_mutexattr_t attr&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; pthread_mutexattr_init(&amp;amp;attr)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; pthread_mutexattr_settype(&amp;amp;attr, PTHREAD_MUTEX_RECURSIVE)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; pthread_mutex_t mutex = mtDealloc.invokeLock&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; pthread_mutex_init(&amp;amp;mutex, &amp;amp;attr)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; objc_setAssociatedObject(rule.target, rule.selector, mtDealloc, OBJC_ASSOCIATION_RETAIN)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; // 消息转发时保证线程安全&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; static void mt_forwardInvocation(__unsafe_unretained id assignSlf, SEL selector, NSInvocation *invocation)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     SEL originalSelector = invocation.selector&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     SEL fixedOriginalSelector = mt_aliasForSelector(originalSelector)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     if (![assignSlf respondsToSelector:fixedOriginalSelector]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         mt_executeOrigForwardInvocation(assignSlf, selector, invocation)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         return&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     MTDealloc *mtDealloc = objc_getAssociatedObject(invocation.target, selector)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     pthread_mutex_t mutex = mtDealloc.invokeLock&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     pthread_mutex_lock(&amp;amp;mutex)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     mt_handleInvocation(invocation, fixedOriginalSelector)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     pthread_mutex_unlock(&amp;amp;mutex)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;MTEngine&lt;/code&gt; 中字典的存储结构的改进不仅提高了性能，还让设计思路更清晰。在添加或废除规则的时候，旧方案需要遍历所有的 &lt;code&gt;MTRule&lt;/code&gt; 对象，然后通过检查 &lt;code&gt;target&lt;/code&gt; 和 &lt;code&gt;selector&lt;/code&gt; 来判断规则是否相互干扰；新方案直接存储了 &lt;code&gt;target&lt;/code&gt; 和对应的 &lt;code&gt;selector&lt;/code&gt; 数组，声明如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSMapTable&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;NSMutableSet&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *&amp;gt; *&amp;gt; *targetSELs;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样的存储方式可以更高效地找到某个对象或类的某个方法是否被限频了，增删规则也更快。&lt;/p&gt;
&lt;p&gt;在 Hook 某个方法的时候，会给它生成一个新的方法名，这就又涉及到字符串拼接的开销。解决方案是使用缓存来映射两个 &lt;code&gt;SEL&lt;/code&gt; 指针，又要用到 &lt;code&gt;NSMapTable&lt;/code&gt; 大显神威了。这又将节省 6% 左右的 CPU 耗时！需要注意的是创建 &lt;code&gt;NSMapTable&lt;/code&gt; 时的选项，以及存取时的类型强转：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 初始化 NSMapTable 缓存&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;_aliasSelectorCache = [&lt;span class=&quot;built_in&quot;&gt;NSMapTable&lt;/span&gt; mapTableWithKeyOptions:&lt;span class=&quot;built_in&quot;&gt;NSPointerFunctionsOpaqueMemory&lt;/span&gt; | &lt;span class=&quot;built_in&quot;&gt;NSMapTableObjectPointerPersonality&lt;/span&gt; valueOptions:&lt;span class=&quot;built_in&quot;&gt;NSPointerFunctionsOpaqueMemory&lt;/span&gt; | &lt;span class=&quot;built_in&quot;&gt;NSMapTableObjectPointerPersonality&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 在方法内部使用缓存优化性能&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; SEL mt_aliasForSelector(SEL selector)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_mutex_lock(&amp;amp;alias_selector_mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SEL aliasSelector = (__bridge &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *)[MTEngine.defaultEngine.aliasSelectorCache objectForKey:(__bridge &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *)selector];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!aliasSelector) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *selectorName = &lt;span class=&quot;built_in&quot;&gt;NSStringFromSelector&lt;/span&gt;(selector);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        aliasSelector = &lt;span class=&quot;built_in&quot;&gt;NSSelectorFromString&lt;/span&gt;([&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; stringWithFormat:&lt;span class=&quot;string&quot;&gt;@&quot;__mt_%@&quot;&lt;/span&gt;, selectorName]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [MTEngine.defaultEngine.aliasSelectorCache setObject:(__bridge &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *)aliasSelector forKey:(__bridge &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *)selector];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_mutex_unlock(&amp;amp;alias_selector_mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; aliasSelector;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可能有人会担心直接缓存 &lt;code&gt;SEL&lt;/code&gt; 指针会不会命中率很低。因为所有名字相同的方法都拥有同一个唯一的 &lt;code&gt;SEL&lt;/code&gt;，所以可以很快速地用直接指针地址判等。可以参考&lt;a href=&quot;https://stackoverflow.com/questions/11051528/understanding-uniqueness-of-selectors-in-objective-c?utm_medium=organic&amp;amp;utm_source=google_rich_qa&amp;amp;utm_campaign=google_rich_qa&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;更新 &lt;a href=&quot;https://github.com/yulingtianxia/MessageThrottle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MessageThrottle&lt;/a&gt; 到最新版即可获取到更快更强更安全的 Objective 消息节流限频功能，一行代码搞定频繁调用的问题。&lt;/p&gt;
&lt;p&gt;新版本在废除消息的时候，也增强了对合法性和安全性的检查。（说白了就是改 bug）&lt;/p&gt;
&lt;p&gt;理论上我的另一个组件 &lt;a href=&quot;https://github.com/yulingtianxia/BlockTracker&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BlockTracker&lt;/a&gt; 也可以按照本文的方案优化性能了，嘿嘿，有时间搞下。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/yulingtianxia/MessageThrottle&quot;&gt;MessageThrottle&lt;/a&gt; 是我开发的Objective-C 节流限频组件，其原理基于 Hook 消息转发流程，所以相比直接调用方法，会有一些性能上的损耗。本篇文章记录了对其性能进行测试的结果，并通过使用 &lt;code&gt;NSMapTable&lt;/code&gt; 改进存储结构和缓存来对性能进行大幅度的优化。&lt;/p&gt;
&lt;p&gt;这是你从未体验过的船新版本。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yulingtianxia.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Colorful Rounded Rect Dash Border</title>
    <link href="http://yulingtianxia.com/blog/2018/04/30/Colorful-Rounded-Rect-Dash-Border/"/>
    <id>http://yulingtianxia.com/blog/2018/04/30/Colorful-Rounded-Rect-Dash-Border/</id>
    <published>2018-04-30T09:25:44.000Z</published>
    <updated>2018-09-15T08:28:13.549Z</updated>
    
    <content type="html">&lt;p&gt;产品经理要求做个能展示进度的分段彩色外环，大概长这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yulingtianxia/YXYDashLayer/blob/master/Assets/YXYDashLayer.gif?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;花了两天左右来实现和优化，记录下踩坑经历。&lt;/p&gt;
&lt;p&gt;组件已经开源，取个名字叫 &lt;code&gt;YXYDashLayer&lt;/code&gt; 吧：&lt;a href=&quot;https://github.com/yulingtianxia/YXYDashLayer&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/yulingtianxia/YXYDashLayer&lt;/a&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;接口设计&quot;&gt;&lt;a href=&quot;#接口设计&quot; class=&quot;headerlink&quot; title=&quot;接口设计&quot;&gt;&lt;/a&gt;接口设计&lt;/h2&gt;&lt;p&gt;因为考虑到要做成稍微通用一些的组件，最底层的 &lt;code&gt;YXYMaskDashLayer&lt;/code&gt; 接口设计如下。其他类的属性也都是对它的封装。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 分段的间隙&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt; dashGap;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 线宽&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt; dashWidth;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 矩形的圆角半径&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt; dashCornerRadius;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 分段总数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSUInteger&lt;/span&gt; totalCount;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 需要显示哪些分段的 index&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;NSNumber&lt;/span&gt; *&amp;gt; *showIndexes;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 刷新整个Layer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)refresh;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 仅刷新 Dash 的 totalCount、dashGap 和 showIndexes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)refreshDash;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;因为有些属性改变后并不需要重新绘制 path，为了实现更好的性能，所以还提供了一个只刷新 dash 数据的接口 &lt;code&gt;refreshDash&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;具体使用的例子可以运行 Demo 程序。&lt;/p&gt;
&lt;h2 id=&quot;思路很重要&quot;&gt;&lt;a href=&quot;#思路很重要&quot; class=&quot;headerlink&quot; title=&quot;思路很重要&quot;&gt;&lt;/a&gt;思路很重要&lt;/h2&gt;&lt;p&gt;之前的样式是个圆形的分段外环，而且是纯色的，看了下以前的代码，是按照弧度均分后，从顶部开始按顺时针一段一段 path 组合起来的。用 &lt;code&gt;UIBezierPath&lt;/code&gt; 的 &lt;code&gt;+ bezierPathWithArcCenter:radius:startAngle:endAngle:clockwise:&lt;/code&gt; 方法即可画出来。&lt;/p&gt;
&lt;p&gt;然而现在改成了圆角矩形的，要按照周长均分来画分段，实现方式完全不同。因为圆形只是圆角矩形的一种特殊情况，所以需要另一种更通用的实现方式。因为借鉴了圆形分段一段段画的思想，最开始想到的也是一段段画圆角矩形，需要把整个圆角矩形划分成 9 个区域（四个四分之一圆弧，四条直线，顶部直线需要分成两块），还要对圆角和直线部分的边界处理，涉及到大量的计算。我刚开始要这么干的时候，觉得这么做有点笨，肯定有更简单的方案。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CAShapeLayer&lt;/code&gt; 的 &lt;code&gt;lineDashPattern&lt;/code&gt; 和 &lt;code&gt;lineDashPhase&lt;/code&gt; 属性就可以实现这个需求了，之前一直被旧代码的方案限制了思路。真是退一步海阔天空啊。原本跟产品说这有 5 天工作量，结果半个小时就写出个 demo，哈哈。然后用剩下的时间继续完善打磨，做成通用组件。&lt;/p&gt;
&lt;h2 id=&quot;技术实现&quot;&gt;&lt;a href=&quot;#技术实现&quot; class=&quot;headerlink&quot; title=&quot;技术实现&quot;&gt;&lt;/a&gt;技术实现&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;先用贝塞尔曲线画一个圆角矩形(就叫 &lt;code&gt;path&lt;/code&gt; 吧)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;path.CGPath&lt;/code&gt; 赋值给 &lt;code&gt;CAShapeLayer&lt;/code&gt; 实例（就叫 &lt;code&gt;maskLayer&lt;/code&gt; 吧）&lt;/li&gt;
&lt;li&gt;根据线宽、分段间隙、&lt;code&gt;path&lt;/code&gt; 周长、总分段数、要展示的分段 index，可计算出 &lt;code&gt;lineDashPattern&lt;/code&gt; 和 &lt;code&gt;lineDashPhase&lt;/code&gt; 的值，刷新 &lt;code&gt;maskLayer&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将 &lt;code&gt;maskLayer&lt;/code&gt; 赋值给 &lt;code&gt;CAGradientLayer&lt;/code&gt; 实例的 &lt;code&gt;mask&lt;/code&gt;。调整 &lt;code&gt;colors&lt;/code&gt; 等属性即可实现一个彩色渐变分段圆角矩形外圈。&lt;/li&gt;
&lt;li&gt;将多个这样的 &lt;code&gt;CAGradientLayer&lt;/code&gt; 实例重叠在一起，即可实现个别分段『高亮』效果。比如一个 layer 当做底色，另一个放上面当做灰色进度条。（PS：本文最开始的 gif 就是这样）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里面踩坑最多的就是前 3 个步骤，计算时需要考虑到一些边界条件。&lt;/p&gt;
&lt;h3 id=&quot;画圆角矩形的坑&quot;&gt;&lt;a href=&quot;#画圆角矩形的坑&quot; class=&quot;headerlink&quot; title=&quot;画圆角矩形的坑&quot;&gt;&lt;/a&gt;画圆角矩形的坑&lt;/h3&gt;&lt;p&gt;&lt;code&gt;+ bezierPathWithRoundedRect:cornerRadius:&lt;/code&gt; 方法是可以直接画出一个圆角矩形的，但是路径的起始点并没确定。表面上看上去是从顶部直线左端开始顺时针画，然而会有向右的一些偏差。这样就无法精确计算出 &lt;code&gt;lineDashPhase&lt;/code&gt; 的值，导致画出来的效果不对称了。&lt;/p&gt;
&lt;p&gt;于是我这里干脆自己画个圆角矩形，代码也很简单。由于要考虑到线宽，所以需要计算下真正的圆角半径和外接矩形尺寸，顺时针画四段直线四段四分之一圆弧即可。下面的代码是写在 &lt;code&gt;CAShapeLayer&lt;/code&gt; 子类里的：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UIBezierPath&lt;/span&gt; *path = [&lt;span class=&quot;built_in&quot;&gt;UIBezierPath&lt;/span&gt; bezierPath];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.dashRect = &lt;span class=&quot;built_in&quot;&gt;CGRectInset&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.bounds, &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.dashWidth / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.dashWidth / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt; width = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.dashRect.size.width;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt; height = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.dashRect.size.height;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius = MIN(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.dashCornerRadius - &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.dashWidth / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, width / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius = MAX(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CGPoint&lt;/span&gt; center = &lt;span class=&quot;built_in&quot;&gt;CGPointMake&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.frame.size.width / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.frame.size.height / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[path moveToPoint:&lt;span class=&quot;built_in&quot;&gt;CGPointMake&lt;/span&gt;(center.x - width / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius, center.y - height / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[path addLineToPoint:&lt;span class=&quot;built_in&quot;&gt;CGPointMake&lt;/span&gt;(center.x + width / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; - &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius, center.y - height / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[path addArcWithCenter:&lt;span class=&quot;built_in&quot;&gt;CGPointMake&lt;/span&gt;(center.x + width / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; - &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius, center.y - height / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius) radius:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius startAngle:M_PI_2 * &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; endAngle:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; clockwise:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[path addLineToPoint:&lt;span class=&quot;built_in&quot;&gt;CGPointMake&lt;/span&gt;(center.x + width / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, center.y + height / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; - &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[path addArcWithCenter:&lt;span class=&quot;built_in&quot;&gt;CGPointMake&lt;/span&gt;(center.x + width / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; - &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius, center.y + height / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; - &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius) radius:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius startAngle:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; endAngle:M_PI_2 clockwise:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[path addLineToPoint:&lt;span class=&quot;built_in&quot;&gt;CGPointMake&lt;/span&gt;(center.x - width / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius, center.y + height / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[path addArcWithCenter:&lt;span class=&quot;built_in&quot;&gt;CGPointMake&lt;/span&gt;(center.x - width / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius, center.y + height / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; - &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius) radius:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius startAngle:M_PI_2 endAngle:M_PI clockwise:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[path addLineToPoint:&lt;span class=&quot;built_in&quot;&gt;CGPointMake&lt;/span&gt;(center.x - width / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, center.y - height / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[path addArcWithCenter:&lt;span class=&quot;built_in&quot;&gt;CGPointMake&lt;/span&gt;(center.x - width / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius, center.y - height / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius) radius:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius startAngle:M_PI endAngle:M_PI_2 * &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; clockwise:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.totalLength = (width + height) * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; - &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius * &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt; + M_PI * &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.lineWidth = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.dashWidth;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.path = path.CGPath;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的代码也计算出了周长，用于下一步的分段长度计算。&lt;/p&gt;
&lt;h3 id=&quot;处理边界值&quot;&gt;&lt;a href=&quot;#处理边界值&quot; class=&quot;headerlink&quot; title=&quot;处理边界值&quot;&gt;&lt;/a&gt;处理边界值&lt;/h3&gt;&lt;p&gt;圆角矩形的周长已经算出来了，外部提供了 &lt;code&gt;dashGap&lt;/code&gt;，但是绘制时真正的分段间隙是需要考虑到线宽和分段总数的。因为线的边缘会有个半圆，半径为二分之一线宽。当只有一个分段的时候画一个完整的圆角矩形，不需要有间隙了。如果分段总数过多导致计算的分段长度 &lt;code&gt;pieceLength&lt;/code&gt; 小于 0，需要计算能展示出来分段数的最大值 &lt;code&gt;realTotalCount&lt;/code&gt;，并重新计算分段长度 &lt;code&gt;pieceLength&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt; realDashGap = (&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.totalCount == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) ? &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; : &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.dashGap + &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.dashWidth;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSUInteger&lt;/span&gt; realTotalCount = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.totalCount;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt; pieceLength = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.totalLength / &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.totalCount - realDashGap;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (pieceLength &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   pieceLength = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   realTotalCount = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.totalLength / realDashGap;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   pieceLength = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.totalLength / realTotalCount - realDashGap;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;Can&#39;t show! Reduce total count or dash gap! Real Total Count: %lu, Real Dash Gap:%ff&quot;&lt;/span&gt;, (&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt;)realTotalCount, realDashGap);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Dash-策略&quot;&gt;&lt;a href=&quot;#Dash-策略&quot; class=&quot;headerlink&quot; title=&quot;Dash 策略&quot;&gt;&lt;/a&gt;Dash 策略&lt;/h3&gt;&lt;p&gt;&lt;code&gt;lineDashPhase&lt;/code&gt; 可以理解为 dash 距离 path 起始点的距离，想让 dash 从顶部中间开始，需要设置初始值：二分之一外接矩形宽度的减去圆角半径，再加上二分之一 &lt;code&gt;realDashGap&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight armasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;self.lineDashPhase &lt;/span&gt;= - (&lt;span class=&quot;keyword&quot;&gt;self.dashRect.size.width &lt;/span&gt;/ &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; - &lt;span class=&quot;keyword&quot;&gt;self.realDashCornerRadius &lt;/span&gt;+ realDashGap / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后就是顺时针画需要展示的分段。输入是一个 &lt;code&gt;showIndexes&lt;/code&gt; 数组，比如一共有 10 个分段，想展示的是前两个和最后一个分段，那么 &lt;code&gt;showIndexes&lt;/code&gt; 的内容就是 &lt;code&gt;@[@0, @1, @9]&lt;/code&gt;。此时 &lt;code&gt;lineDashPattern&lt;/code&gt; 的值就应该是（&lt;code&gt;pieceLength&lt;/code&gt; 就是每个分段的长度）：&lt;/p&gt;
&lt;figure class=&quot;highlight gherkin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@[&lt;/span&gt;&lt;span class=&quot;meta&quot;&gt;@pieceLength,&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@realDashGap,&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@pieceLength,&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@(realDashGap&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;*&lt;/span&gt; 8 + pieceLength &lt;span class=&quot;symbol&quot;&gt;*&lt;/span&gt; 7), &lt;span class=&quot;meta&quot;&gt;@pieceLength,&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@realDashGap]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果 &lt;code&gt;showIndexes&lt;/code&gt; 的内容是 &lt;code&gt;@[@1, @2, @9]&lt;/code&gt;，可不可以让 &lt;code&gt;lineDashPattern&lt;/code&gt; 数组前面填 &lt;code&gt;@0&lt;/code&gt; 呢？&lt;/p&gt;
&lt;figure class=&quot;highlight gherkin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@[&lt;/span&gt;&lt;span class=&quot;meta&quot;&gt;@0,&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@(pieceLength&lt;/span&gt; + realDashGap), &lt;span class=&quot;meta&quot;&gt;@pieceLength,&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@realDashGap,&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@pieceLength,&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@(realDashGap&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;*&lt;/span&gt; 7 + pieceLength &lt;span class=&quot;symbol&quot;&gt;*&lt;/span&gt; 6), &lt;span class=&quot;meta&quot;&gt;@pieceLength,&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@realDashGap]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;因为把 &lt;code&gt;lineCap&lt;/code&gt; 设为了 &lt;code&gt;kCALineCapRound&lt;/code&gt;，即便长度为 0 路径也会展示成为一个圆点，半径就是线宽。然而安卓系统对应的 API 在这种情况就不会绘制出圆点。为此 iOS 更麻烦一点，需要再次调整&lt;code&gt;lineDashPhase&lt;/code&gt; 的值来『越过』前面几个分段。具体的实现代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;NSMutableArray&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;NSNumber&lt;/span&gt; *&amp;gt; *dashPattern = [&lt;span class=&quot;type&quot;&gt;NSMutableArray&lt;/span&gt; arrayWithCapacity:&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; * realTotalCount];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;NSInteger&lt;/span&gt; needsMovePhaseCount = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (int i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; realTotalCount; i ++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.showIndexes containsObject:@(i)]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       [dashPattern addObject:@(pieceLength)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       [dashPattern addObject:@(realDashGap)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (dashPattern.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt; &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           dashPattern[dashPattern.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt; - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = @(dashPattern[dashPattern.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt; - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;].doubleValue + pieceLength + realDashGap);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.lineDashPhase -= (pieceLength + realDashGap);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           needsMovePhaseCount ++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (needsMovePhaseCount &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; dashPattern.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt; &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   dashPattern[dashPattern.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt; - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = @(dashPattern[dashPattern.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt; - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;].doubleValue + (pieceLength + realDashGap) * needsMovePhaseCount);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.showIndexes.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt; &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.lineDashPattern = dashPattern;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;一开始做这种需求我是拒绝的，交互有点复杂啊，用户看不懂啊，说白了还是不知道咋实现心里没底啊！然而要是没有这种需求，也就没有这篇月末大水文了。&lt;/p&gt;
&lt;p&gt;我真是越来越水了，只会写 UI 了，还是搞底层的逆向大佬们牛逼啊！Hank 老师教教我！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;产品经理要求做个能展示进度的分段彩色外环，大概长这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yulingtianxia/YXYDashLayer/blob/master/Assets/YXYDashLayer.gif?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;花了两天左右来实现和优化，记录下踩坑经历。&lt;/p&gt;
&lt;p&gt;组件已经开源，取个名字叫 &lt;code&gt;YXYDashLayer&lt;/code&gt; 吧：&lt;a href=&quot;https://github.com/yulingtianxia/YXYDashLayer&quot;&gt;https://github.com/yulingtianxia/YXYDashLayer&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yulingtianxia.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>追踪 Objective-C 方法中的 Block 参数对象</title>
    <link href="http://yulingtianxia.com/blog/2018/03/31/Track-Block-Arguments-of-Objective-C-Method/"/>
    <id>http://yulingtianxia.com/blog/2018/03/31/Track-Block-Arguments-of-Objective-C-Method/</id>
    <published>2018-03-31T15:44:39.000Z</published>
    <updated>2018-09-15T08:28:13.796Z</updated>
    
    <content type="html">&lt;p&gt;很多方法最后一个参数是类似于 &lt;code&gt;completionBlock&lt;/code&gt; 这种回调，然而有些 API 实现一些异常逻辑时会忘记调用传入的 Block 参数（当然这肯定是 bug 啦），或者存在多次调用。在调试的时候可能会碰到这种大坑，需要追踪下 Block 参数何时调用了，甚至是否调用过。如果不方便直接在 Block 实现中加代码，或者没有源码的情况下，就需要无侵入式地追踪 Block 参数对象。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/yulingtianxia/BlockTracker&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BlockTracker&lt;/a&gt; 可以追踪方法调用时传入的 Block 类型的参数的执行和销毁。基于 &lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BlockHook&lt;/a&gt; 实现。本文讲述了它的使用方法和实现原理。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;使用方法&quot;&gt;&lt;a href=&quot;#使用方法&quot; class=&quot;headerlink&quot; title=&quot;使用方法&quot;&gt;&lt;/a&gt;使用方法&lt;/h2&gt;&lt;p&gt;只需要调用 &lt;code&gt;bt_trackBlockArgOfSelector:callback:&lt;/code&gt; 方法，就能在对应方法执行传入的 block 参数被调用和销毁的时候得到回调。回调中的内容包含了 &lt;code&gt;block&lt;/code&gt; 对象，回调类型，&lt;code&gt;block&lt;/code&gt; 已经执行的次数，执行 &lt;code&gt;block&lt;/code&gt; 的参数、返回值，堆栈信息。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;BTTracker *tracker = [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; bt_trackBlockArgOfSelector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(performBlock:) callback:^(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;  _Nullable block, BlockTrackerCallbackType type, &lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt; invokeCount, &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; * _Nullable * _Null_unspecified args, &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; * _Nullable result, &lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *&amp;gt; * _Nonnull callStackSymbols) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@ invoke count = %ld&quot;&lt;/span&gt;, BlockTrackerCallbackTypeInvoke == type ? &lt;span class=&quot;string&quot;&gt;@&quot;BlockTrackerCallBackTypeInvoke&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;@&quot;BlockTrackerCallBackTypeDead&quot;&lt;/span&gt;, (&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt;)invokeCount);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当你不想追踪这个方法执行时传入的 block 参数时，也可以停止追踪：&lt;/p&gt;
&lt;figure class=&quot;highlight ini&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;[tracker stop]&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;举个栗子，现在有个方法叫 &lt;code&gt;performBlock:&lt;/code&gt;，只是简单地调用了 &lt;code&gt;block&lt;/code&gt; 参数：&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;void&lt;/span&gt;)performBlock:(&lt;span class=&quot;built_in&quot;&gt;void&lt;/span&gt;(^)(&lt;span class=&quot;built_in&quot;&gt;void&lt;/span&gt;))&lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;调用两次这个方法，每次都传入不同的 block 实现：&lt;/p&gt;
&lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__block NSString *word = @&lt;span class=&quot;string&quot;&gt;&quot;I&#39;m a block&quot;&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self performBlock:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   NSLog(@&lt;span class=&quot;string&quot;&gt;&quot;add &#39;!!!&#39; to word&quot;&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   word = [word stringByAppendingString:@&lt;span class=&quot;string&quot;&gt;&quot;!!!&quot;&lt;/span&gt;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self performBlock:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   NSLog(@&lt;span class=&quot;string&quot;&gt;&quot;%@&quot;&lt;/span&gt;, word)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;因为执行两次方法传入的是两个不同的 block 对象，所以会追踪两个 block 对象的执行和销毁，打印的 log 如下：&lt;/p&gt;
&lt;figure class=&quot;highlight smali&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;add &#39;!!!&#39; to word&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BlockTrackerCallBackTypeInvoke&lt;span class=&quot;built_in&quot;&gt; invoke &lt;/span&gt;count = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;I&#39;m a block!!!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BlockTrackerCallBackTypeInvoke&lt;span class=&quot;built_in&quot;&gt; invoke &lt;/span&gt;count = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BlockTrackerCallBackTypeDead&lt;span class=&quot;built_in&quot;&gt; invoke &lt;/span&gt;count = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BlockTrackerCallBackTypeDead&lt;span class=&quot;built_in&quot;&gt; invoke &lt;/span&gt;count = 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 block 对象销毁的时候&lt;br&gt;你可以尝试着把 &lt;code&gt;performBlock:&lt;/code&gt; 的实现改成这样试试：&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;void&lt;/span&gt;)performBlock:(&lt;span class=&quot;built_in&quot;&gt;void&lt;/span&gt;(^)(&lt;span class=&quot;built_in&quot;&gt;void&lt;/span&gt;))&lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;实现原理&quot;&gt;&lt;a href=&quot;#实现原理&quot; class=&quot;headerlink&quot; title=&quot;实现原理&quot;&gt;&lt;/a&gt;实现原理&lt;/h2&gt;&lt;p&gt;原理很简单，就是 Hook 方法后再 Hook 下 Block，流程大致如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;利用 Objective-C Runtime 机制 Hook 某个方法，参考 &lt;a href=&quot;https://github.com/yulingtianxia/MessageThrottle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MessageThrottle&lt;/a&gt; 的实现原理。&lt;/li&gt;
&lt;li&gt;在方法真正执行前，使用 &lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BlockHook&lt;/a&gt; 先 Hook 所有 Block 类型的参数。Hook 模式为 &lt;code&gt;BlockHookModeAfter&lt;/code&gt; 和 &lt;code&gt;BlockHookModeDead&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在 Block 执行后更新执行次数，并将相关信息回调给 Tracker。销毁后也会回调给 Tracker。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;流程大概很简单，复用以前代码。这里主要讲下 Track 的逻辑。&lt;/p&gt;
&lt;h3 id=&quot;过滤方法的-Block-参数&quot;&gt;&lt;a href=&quot;#过滤方法的-Block-参数&quot; class=&quot;headerlink&quot; title=&quot;过滤方法的 Block 参数&quot;&gt;&lt;/a&gt;过滤方法的 Block 参数&lt;/h3&gt;&lt;p&gt;在 &lt;code&gt;bt_trackBlockArgOfSelector:callback:&lt;/code&gt; 里获取方法的 Type Encoding 后判断是否含有 Block 类型的参数，并将 Block 参数的 Index 保存到 &lt;code&gt;BTTracker&lt;/code&gt; 的 &lt;code&gt;blockArgIndex&lt;/code&gt; 属性。&lt;/p&gt;
&lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (nullable &lt;span class=&quot;keyword&quot;&gt;BTTracker &lt;/span&gt;*)&lt;span class=&quot;keyword&quot;&gt;bt_trackBlockArgOfSelector:(SEL)selector &lt;/span&gt;callback:(&lt;span class=&quot;keyword&quot;&gt;BlockTrackerCallbackBlock)callback&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class cls = &lt;span class=&quot;keyword&quot;&gt;bt_classOfTarget(self);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Method &lt;span class=&quot;keyword&quot;&gt;originMethod &lt;/span&gt;= class_getInstanceMethod(cls, selector)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (!&lt;span class=&quot;keyword&quot;&gt;originMethod) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return nil&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    const char *&lt;span class=&quot;keyword&quot;&gt;originType &lt;/span&gt;= (char *)method_getTypeEncoding(&lt;span class=&quot;keyword&quot;&gt;originMethod);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;    if (![[NSString stringWithUTF8String:&lt;span class=&quot;keyword&quot;&gt;originType] &lt;/span&gt;containsString:@&lt;span class=&quot;string&quot;&gt;&quot;@?&quot;&lt;/span&gt;]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return nil&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSMutableArray *&lt;span class=&quot;keyword&quot;&gt;blockArgIndex &lt;/span&gt;= [NSMutableArray array]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int argIndex = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;; // return type is the first one&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while(&lt;span class=&quot;keyword&quot;&gt;originType &lt;/span&gt;&amp;amp;&amp;amp; *&lt;span class=&quot;keyword&quot;&gt;originType)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;originType &lt;/span&gt;= &lt;span class=&quot;keyword&quot;&gt;BHSizeAndAlignment(originType, &lt;/span&gt;NULL, NULL, NULL)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if ([[NSString stringWithUTF8String:&lt;span class=&quot;keyword&quot;&gt;originType] &lt;/span&gt;hasPrefix:@&lt;span class=&quot;string&quot;&gt;&quot;@?&quot;&lt;/span&gt;]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [&lt;span class=&quot;keyword&quot;&gt;blockArgIndex &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;addObject:@(argIndex)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        argIndex++&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;BTTracker &lt;/span&gt;*tracker = &lt;span class=&quot;keyword&quot;&gt;BTEngine.defaultEngine.trackers[bt_methodDescription(self, &lt;/span&gt;selector)]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (!tracker) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        tracker = [[&lt;span class=&quot;keyword&quot;&gt;BTTracker &lt;/span&gt;alloc] initWithTarget:self selector:selector]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        tracker.callback = callback&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        tracker.&lt;span class=&quot;keyword&quot;&gt;blockArgIndex &lt;/span&gt;= [&lt;span class=&quot;keyword&quot;&gt;blockArgIndex &lt;/span&gt;copy]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return [tracker apply] ? tracker : nil&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;bt_trackBlockArgOfSelector:callback:&lt;/code&gt; 方法返回的 &lt;code&gt;BTTracker&lt;/code&gt; 对象也保存了 &lt;code&gt;callback&lt;/code&gt; 回调。&lt;/p&gt;
&lt;h3 id=&quot;执行-Callback&quot;&gt;&lt;a href=&quot;#执行-Callback&quot; class=&quot;headerlink&quot; title=&quot;执行 Callback&quot;&gt;&lt;/a&gt;执行 Callback&lt;/h3&gt;&lt;p&gt;遍历之前保存的 Block 参数 Index 列表 &lt;code&gt;blockArgIndex&lt;/code&gt;，从 &lt;code&gt;NSInvocation&lt;/code&gt; 中取到 Block 参数后，就可以 Hook 了。Block 的执行次数保存到了 &lt;code&gt;BHToken&lt;/code&gt; 上，每次执行都会累加。在 Block 执行或销毁后都会调用 &lt;code&gt;callback&lt;/code&gt;，只是传的参数稍有不同。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;NSNumber&lt;/span&gt; *index &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; tracker.blockArgIndex) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (index.integerValue &amp;lt; invocation.methodSignature.numberOfArguments) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       __unsafe_unretained &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; block;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       [invocation getArgument:&amp;amp;block atIndex:index.integerValue];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       __&lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt;(block) weakBlock = block;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       __&lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt;(tracker) weakTracker = tracker;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       BHToken *tokenAfter = [block block_hookWithMode:BlockHookModeAfter usingBlock:^(BHToken *token) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           __&lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt;(weakBlock) strongBlock = weakBlock;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           __&lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt;(weakTracker) strongTracker = weakTracker;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;built_in&quot;&gt;NSNumber&lt;/span&gt; *invokeCount = objc_getAssociatedObject(token, &lt;span class=&quot;built_in&quot;&gt;NSSelectorFromString&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;invokeCount&quot;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!invokeCount) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               invokeCount = @(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               invokeCount = [&lt;span class=&quot;built_in&quot;&gt;NSNumber&lt;/span&gt; numberWithInt:invokeCount.intValue + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           objc_setAssociatedObject(token, &lt;span class=&quot;built_in&quot;&gt;NSSelectorFromString&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;invokeCount&quot;&lt;/span&gt;), invokeCount, OBJC_ASSO&lt;span class=&quot;built_in&quot;&gt;CIATION_RETAIN&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (strongTracker.callback) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               strongTracker.callback(strongBlock, BlockTrackerCallbackTypeInvoke, invokeCount.intValue, token.args, token.retValue, [&lt;span class=&quot;built_in&quot;&gt;NSThread&lt;/span&gt; callStackSymbols]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       [block block_hookWithMode:BlockHookModeDead usingBlock:^(BHToken *token) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           __&lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt;(weakTracker) strongTracker = weakTracker;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;built_in&quot;&gt;NSNumber&lt;/span&gt; *invokeCount = objc_getAssociatedObject(tokenAfter, &lt;span class=&quot;built_in&quot;&gt;NSSelectorFromString&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;invokeCount&quot;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (strongTracker.callback) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               strongTracker.callback(&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;, BlockTrackerCallbackTypeDead, invokeCount.intValue, &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;, [&lt;span class=&quot;built_in&quot;&gt;NSThread&lt;/span&gt; callStackSymbols]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;对-NSInvocation-的一点探索&quot;&gt;&lt;a href=&quot;#对-NSInvocation-的一点探索&quot; class=&quot;headerlink&quot; title=&quot;对 NSInvocation 的一点探索&quot;&gt;&lt;/a&gt;对 NSInvocation 的一点探索&lt;/h3&gt;&lt;p&gt;在从 &lt;code&gt;NSInvocation&lt;/code&gt; 对象获取参数时，需要先调用 &lt;code&gt;retainArguments&lt;/code&gt; 方法让 &lt;code&gt;NSInvocation&lt;/code&gt; 将 Block 参数 &lt;code&gt;copy&lt;/code&gt;。因为有些 Block 参数类型是 &lt;code&gt;__NSStackBlock__&lt;/code&gt;，需要拷贝到堆上，否则从 &lt;code&gt;NSInvocation&lt;/code&gt; 获取的 Block 不会销毁。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getArgument:atIndex:&lt;/code&gt; 方法只是将第 &lt;code&gt;index&lt;/code&gt; 个参数指针的值拷贝到 &lt;code&gt;buffer&lt;/code&gt; 中，而 &lt;code&gt;retainArguments&lt;/code&gt; 才是真的对 C 字符串和 Block 拷贝。&lt;/p&gt;
&lt;p&gt;我还为此做了个小实验。一个类外部声明并调用了 &lt;code&gt;test:&lt;/code&gt; 方法，但其实内部实现的是 &lt;code&gt;foo:&lt;/code&gt; 方法。通过实现 &lt;code&gt;methodSignatureForSelector:&lt;/code&gt; 让消息转发流程走到 &lt;code&gt;forwardInvocation:&lt;/code&gt; 方法中。然后向 Block 参数关联 &lt;code&gt;BTDealloc&lt;/code&gt; 对象，在 &lt;code&gt;test:&lt;/code&gt; 方法执行后，&lt;code&gt;BTDealloc&lt;/code&gt; 类的 &lt;code&gt;dealloc&lt;/code&gt; 方法并没有执行。也就是说通过 &lt;code&gt;NSInvocation&lt;/code&gt; 获取的 Block 参数没销毁；如果先调用了 &lt;code&gt;retainArguments&lt;/code&gt; 就会销毁。&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;test:&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;(^)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;))block;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;foo:&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;(^)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)) block &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    block();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (NSMethodSignature *)&lt;span class=&quot;string&quot;&gt;methodSignatureForSelector:&lt;/span&gt;(SEL)aSelector&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [NSMethodSignature &lt;span class=&quot;string&quot;&gt;signatureWithObjCTypes:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;v@:@?&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;forwardInvocation:&lt;/span&gt;(NSInvocation *)anInvocation&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//    [anInvocation retainArguments];&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; **invocationFrame = ((__bridge struct BTInvocaton *)anInvocation)-&amp;gt;frame;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *blockFromFrame = invocationFrame[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *block;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [anInvocation &lt;span class=&quot;string&quot;&gt;getArgument:&lt;/span&gt;&amp;amp;block &lt;span class=&quot;string&quot;&gt;atIndex:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    BTDealloc *btDealloc = [BTDealloc &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    objc_setAssociatedObject((__bridge id)block, &lt;span class=&quot;meta&quot;&gt;@selector&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;foo:&lt;/span&gt;), btDealloc, OBJC_ASSOCIATION_RETAIN);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    anInvocation.selector = &lt;span class=&quot;meta&quot;&gt;@selector&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;foo:&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [anInvocation invoke];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过对 &lt;code&gt;NSInvocation&lt;/code&gt; 对象的解析，我发现 &lt;code&gt;NSInvocation&lt;/code&gt; 的参数存储于一个私有成员变量 &lt;code&gt;_frame&lt;/code&gt; 中，试着将其强转为二级指针，也就是指针数组。拿到对应 index 的值 &lt;code&gt;blockFromFrame&lt;/code&gt; 跟 &lt;code&gt;block&lt;/code&gt; 作比较，发现是一样的。这里获取 &lt;code&gt;_frame&lt;/code&gt; 需要强转下，&lt;code&gt;NSInvocation&lt;/code&gt; 的内存模型如下：&lt;/p&gt;
&lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;struct &lt;span class=&quot;keyword&quot;&gt;BTInvocaton &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void *isa&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void *frame&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void *retdata&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void *signature&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void *container&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    uint8_t retainedArgs&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    uint8_t reserved[&lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;由于 Hook Method 的逻辑是在消息转发流程搞事情，所以跟 Aspects 一样不能同时 Hook 父类和子类类相同方法。因为如果子类调用父类的实现，就会死循环。如果 Hook 方法这部分使用 &lt;a href=&quot;http://yulingtianxia.com/blog/2017/04/17/Objective-C-Method-Swizzling/&quot;&gt;Method Swizzling&lt;/a&gt; 等交换 IMP 的方式实现，也会有着严重依赖 Hook 顺序导致调用错乱的问题。还是基于桥的 Hook 牛逼，汇编跳板，我这辈子是看不懂了。&lt;/p&gt;
&lt;p&gt;老子终于在这个月最后一天快结束的时候憋出来一篇大水文！搬砖累死了没时间研究技术，你们尽管喷！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;很多方法最后一个参数是类似于 &lt;code&gt;completionBlock&lt;/code&gt; 这种回调，然而有些 API 实现一些异常逻辑时会忘记调用传入的 Block 参数（当然这肯定是 bug 啦），或者存在多次调用。在调试的时候可能会碰到这种大坑，需要追踪下 Block 参数何时调用了，甚至是否调用过。如果不方便直接在 Block 实现中加代码，或者没有源码的情况下，就需要无侵入式地追踪 Block 参数对象。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/yulingtianxia/BlockTracker&quot;&gt;BlockTracker&lt;/a&gt; 可以追踪方法调用时传入的 Block 类型的参数的执行和销毁。基于 &lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot;&gt;BlockHook&lt;/a&gt; 实现。本文讲述了它的使用方法和实现原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yulingtianxia.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Hook Objective-C Block with Libffi</title>
    <link href="http://yulingtianxia.com/blog/2018/02/28/Hook-Objective-C-Block-with-Libffi/"/>
    <id>http://yulingtianxia.com/blog/2018/02/28/Hook-Objective-C-Block-with-Libffi/</id>
    <published>2018-02-28T11:05:24.000Z</published>
    <updated>2018-09-15T08:28:13.567Z</updated>
    
    <content type="html">&lt;p&gt;本文通过参照 &lt;code&gt;MABlockClosure&lt;/code&gt; 的实现和 &lt;code&gt;Aspects&lt;/code&gt; 的 API 设计，基于 libffi 实现了对 Objective-C Block 的 hook。GitHub 地址：&lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/yulingtianxia/BlockHook&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;什么场景下需要 hook block 呢？在有源码的情况下，大部分程序员会选择直接在 block 中插代码。假如方法 A 的入参是个 block 对象，方法 A 将 block 传给方法 B,C…等。如果只有方法 A 的源码，上层传入的 block 和下层方法实现都是黑盒的话，想追踪 block 调用的时机，打印些 log，就得 hook 这个 block 对象了。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;如何使用&quot;&gt;&lt;a href=&quot;#如何使用&quot; class=&quot;headerlink&quot; title=&quot;如何使用&quot;&gt;&lt;/a&gt;如何使用&lt;/h2&gt;&lt;p&gt;虽然 Github 上已经给了例子，用过 Aspects 的人一看就懂，但为了凑篇幅，还是多 BB 几句吧。&lt;/p&gt;
&lt;p&gt;API 虽然清奇，但是需要在 block 对象上用哦，在其他类型的对象上用是无效的！&lt;/p&gt;
&lt;figure class=&quot;highlight erlang&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- &lt;span class=&quot;params&quot;&gt;(BHToken *)&lt;/span&gt;block_hookWithMode:&lt;span class=&quot;params&quot;&gt;(BlockHookMode)&lt;/span&gt;mode&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     usingBlock:&lt;span class=&quot;params&quot;&gt;(id)&lt;/span&gt;block&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;四种 hook 模式任你选择，可以对同一个 block 对象 hook 多次，但是要注意自己控制好顺序问题！hook 后会返回一个 &lt;code&gt;BHToken&lt;/code&gt; 对象，可以调用它的 &lt;code&gt;remove&lt;/code&gt; 方法来让 hook 失效。切记 &lt;code&gt;remove&lt;/code&gt; 的时候要按照 hook 时的逆序！（以后可以搞个栈优化下用户体验，暂时懒的弄）&lt;/p&gt;
&lt;figure class=&quot;highlight scheme&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;name&quot;&gt;super&lt;/span&gt; viewDidLoad]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Do any additional setup after loading the view, typically from a nib.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSObject *z = NSObject.new&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int (&lt;span class=&quot;name&quot;&gt;^block&lt;/span&gt;)(&lt;span class=&quot;name&quot;&gt;int&lt;/span&gt;, int) = ^(&lt;span class=&quot;name&quot;&gt;int&lt;/span&gt; x, int y) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   int result = x + y&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   NSLog(&lt;span class=&quot;name&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;%d + %d = %d, z is a NSObject: %p&quot;&lt;/span&gt;, x, y, result, z)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   return result&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BHToken *tokenInstead = [&lt;span class=&quot;name&quot;&gt;block&lt;/span&gt; block_hookWithMode:BlockHookModeInstead usingBlock:^(&lt;span class=&quot;name&quot;&gt;BHToken&lt;/span&gt; *token, int x, int y)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   [&lt;span class=&quot;name&quot;&gt;token&lt;/span&gt; invokeOriginalBlock]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   NSLog(&lt;span class=&quot;name&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;let me see original result: %d&quot;&lt;/span&gt;, *(&lt;span class=&quot;name&quot;&gt;int&lt;/span&gt; *)(&lt;span class=&quot;name&quot;&gt;token.retValue&lt;/span&gt;))&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   // change the block imp and result&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   *(&lt;span class=&quot;name&quot;&gt;int&lt;/span&gt; *)(&lt;span class=&quot;name&quot;&gt;token.retValue&lt;/span&gt;) = x * y&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   NSLog(&lt;span class=&quot;name&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;hook instead: &#39;+&#39; -&amp;gt; &#39;*&#39;&quot;&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BHToken *tokenAfter = [&lt;span class=&quot;name&quot;&gt;block&lt;/span&gt; block_hookWithMode:BlockHookModeAfter usingBlock:^(&lt;span class=&quot;name&quot;&gt;BHToken&lt;/span&gt; *token, int x, int y)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   // print args and result&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   NSLog(&lt;span class=&quot;name&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;hook after block! %d * %d = %d&quot;&lt;/span&gt;, x, y, *(&lt;span class=&quot;name&quot;&gt;int&lt;/span&gt; *)(&lt;span class=&quot;name&quot;&gt;token.retValue&lt;/span&gt;))&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BHToken *tokenBefore = [&lt;span class=&quot;name&quot;&gt;block&lt;/span&gt; block_hookWithMode:BlockHookModeBefore usingBlock:^(&lt;span class=&quot;name&quot;&gt;id&lt;/span&gt; token)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   // BHToken has to be the first arg.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   NSLog(&lt;span class=&quot;name&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;hook before block! token:%@&quot;&lt;/span&gt;, token)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BHToken *tokenDead = [&lt;span class=&quot;name&quot;&gt;block&lt;/span&gt; block_hookWithMode:BlockHookModeDead usingBlock:^(&lt;span class=&quot;name&quot;&gt;id&lt;/span&gt; token)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   // BHToken is the only arg.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   NSLog(&lt;span class=&quot;name&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;block dead! token:%@&quot;&lt;/span&gt;, token)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_async(&lt;span class=&quot;name&quot;&gt;dispatch_get_global_queue&lt;/span&gt;(&lt;span class=&quot;name&quot;&gt;DISPATCH_QUEUE_PRIORITY_DEFAULT&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   NSLog(&lt;span class=&quot;name&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;hooked block&quot;&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   int ret = block(&lt;span class=&quot;name&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   NSLog(&lt;span class=&quot;name&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;hooked result:%d&quot;&lt;/span&gt;, ret)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   // remove all tokens when you don&lt;span class=&quot;symbol&quot;&gt;&#39;t&lt;/span&gt; need.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   // reversed order of hook.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   [&lt;span class=&quot;name&quot;&gt;tokenBefore&lt;/span&gt; remove]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   [&lt;span class=&quot;name&quot;&gt;tokenAfter&lt;/span&gt; remove]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   [&lt;span class=&quot;name&quot;&gt;tokenInstead&lt;/span&gt; remove]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   NSLog(&lt;span class=&quot;name&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;remove tokens, original block&quot;&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   ret = block(&lt;span class=&quot;name&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   NSLog(&lt;span class=&quot;name&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;original result:%d&quot;&lt;/span&gt;, ret)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        [&lt;span class=&quot;name&quot;&gt;tokenDead&lt;/span&gt; remove]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以通过设置 &lt;code&gt;BHToken&lt;/code&gt; 的 &lt;code&gt;retValue&lt;/code&gt; 属性来修改 block 的返回值。&lt;code&gt;usingBlock:&lt;/code&gt; 的参数内容是自定义的，跟 Aspects 一样，用户自己填上对应的参数列表。完整参数列表的内容就是 &lt;code&gt;BHToken&lt;/code&gt;（第一个参数）+ 原始 block 参数列表。看上面的例子应该很容易看懂。可以在 hook 的 block 中获取参数和修改返回值，打log，做些有(wei)趣(suo)的事情。&lt;/p&gt;
&lt;p&gt;上面代码执行后的 log 结果如下：&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hooked block&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hook before block! &lt;span class=&quot;string&quot;&gt;token:&lt;/span&gt;&amp;lt;&lt;span class=&quot;string&quot;&gt;BHToken:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0x1d00f0d80&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, z is a &lt;span class=&quot;string&quot;&gt;NSObject:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0x1d00172b0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let me see original &lt;span class=&quot;string&quot;&gt;result:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hook &lt;span class=&quot;string&quot;&gt;instead:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;+&#39;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;string&quot;&gt;&#39;*&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hook after block! &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hooked &lt;span class=&quot;string&quot;&gt;result:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remove tokens, original block&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, z is a &lt;span class=&quot;string&quot;&gt;NSObject:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0x1d00172b0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;original &lt;span class=&quot;string&quot;&gt;result:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block dead! &lt;span class=&quot;string&quot;&gt;token:&lt;/span&gt;&amp;lt;&lt;span class=&quot;string&quot;&gt;BHToken:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0x1d00f9900&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;老铁稳。&lt;/p&gt;
&lt;p&gt;因为需要动态定义和运行函数，用到了 libffi，所以还需要引入对应架构的静态库，自己去官网下个编译好，在工程中引入 libffi.a 和包含头文件的 include 文件夹就行。示例程序 BlockHookSample 使用的是 arm64 架构。具体做法是在 Build Settings 中的 Other Link Flags 加入 libffi.a 的路径，在 Header Search Paths 加入 include 文件夹路径。&lt;/p&gt;
&lt;h2 id=&quot;实现原理&quot;&gt;&lt;a href=&quot;#实现原理&quot; class=&quot;headerlink&quot; title=&quot;实现原理&quot;&gt;&lt;/a&gt;实现原理&lt;/h2&gt;&lt;p&gt;先说下大致思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据 block 对象的签名，使用 &lt;code&gt;ffi_prep_cif&lt;/code&gt; 构建 block-&amp;gt;invoke 函数的模板 &lt;code&gt;cif&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;ffi_closure&lt;/code&gt;，根据 cif 动态定义函数 &lt;code&gt;replacementInvoke&lt;/code&gt;，并指定通用的实现函数为 &lt;code&gt;ClosureFunc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将 block-&amp;gt;invoke 替换为 &lt;code&gt;replacementInvoke&lt;/code&gt;，原始的 block-&amp;gt;invoke 存放在 &lt;code&gt;originInvoke&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;ClosureFunc&lt;/code&gt; 中动态调用 &lt;code&gt;originInvoke&lt;/code&gt; 函数和执行 hook 的逻辑。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对 libffi 的介绍和用法有很多文章可以参考，这里不再赘述。&lt;/p&gt;
&lt;p&gt;再整理下代码设计思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BHToken&lt;/code&gt;: 它实现了 hook 的逻辑，存储了相关的上下文。是最主要的类。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NSObject (BlockHook)&lt;/code&gt;: 提供 hook 的接口，每次 hook block 对象都会创建一个 &lt;code&gt;BHToken&lt;/code&gt;，并将其返回给用户。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BHCenter&lt;/code&gt; 管理 &lt;code&gt;BHToken&lt;/code&gt; 对象的中心，以后可以拓展更多玩法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面列举下 &lt;code&gt;BHToken&lt;/code&gt; 中几个比较重要的逻辑。&lt;/p&gt;
&lt;h3 id=&quot;通过-Block-创建函数模板&quot;&gt;&lt;a href=&quot;#通过-Block-创建函数模板&quot; class=&quot;headerlink&quot; title=&quot;通过 Block 创建函数模板&quot;&gt;&lt;/a&gt;通过 Block 创建函数模板&lt;/h3&gt;&lt;p&gt;有关 Objective-C Block 内存模型这里不再赘述，Block ABI 可以在 &lt;a href=&quot;https://clang.llvm.org/docs/Block-ABI-Apple.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Clang 文档&lt;/a&gt; 查到。根据 block 的 flag 位掩码计算偏移拿到 Type Encoding 签名 signature。&lt;code&gt;BHBlockTypeEncodeString()&lt;/code&gt; 函数实现了这些逻辑，代码不贴了。一个 block 的签名格式是：[返回值类型和偏移][@?0][参数0类型和偏移][参数1类型和偏移]…，比如 arm64 下 &lt;code&gt;int (^block)(int, int)&lt;/code&gt; 的签名是 &lt;code&gt;i16@?0i8i12&lt;/code&gt;。block 指针占 8 字节，参数和返回值 &lt;code&gt;int&lt;/code&gt; 都是 4 字节。&lt;/p&gt;
&lt;p&gt;然后需要把 signature 字符串处理分拆成参数类型列表，在 libffi 中使用 &lt;code&gt;ffi_type&lt;/code&gt; 表示各种类型。&lt;code&gt;_argsWithEncodeString:getCount:&lt;/code&gt; 方法会根据 Type Encoding 规则，将 signature 逐个字符处理，可以获取 &lt;code&gt;ffi_type *&lt;/code&gt; 参数（返回值）数组和参数个数。&lt;code&gt;_ffiArgForEncode:&lt;/code&gt; 方法负责将 Type Encoding 字符映射到对应的 &lt;code&gt;ffi_type&lt;/code&gt; 上，这是个很长的方法。&lt;/p&gt;
&lt;p&gt;有了参数类型列表，返回值类型，参数个数后，就可以调用 &lt;code&gt;ffi_prep_cif()&lt;/code&gt; 函数创建 &lt;code&gt;ffi_cif&lt;/code&gt; 了，也就是函数模板。&lt;code&gt;_prepCIF:withEncodeString:&lt;/code&gt; 方法实现了这个逻辑。&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;_prepCIF:&lt;/span&gt;(ffi_cif *)cif &lt;span class=&quot;string&quot;&gt;withEncodeString:&lt;/span&gt;(const &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *)str&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argCount;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ffi_type **argTypes = [self &lt;span class=&quot;string&quot;&gt;_argsWithEncodeString:&lt;/span&gt;str &lt;span class=&quot;string&quot;&gt;getCount:&lt;/span&gt;&amp;amp;argCount];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ffi_status status = ffi_prep_cif(cif, FFI_DEFAULT_ABI, argCount, [self &lt;span class=&quot;string&quot;&gt;_ffiArgForEncode:&lt;/span&gt; str], argTypes);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(status != FFI_OK)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@&lt;span class=&quot;string&quot;&gt;&quot;Got result %ld from ffi_prep_cif&quot;&lt;/span&gt;, (&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt;)status);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        abort();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; argCount;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;创建闭包，替换-Block-的-invoke&quot;&gt;&lt;a href=&quot;#创建闭包，替换-Block-的-invoke&quot; class=&quot;headerlink&quot; title=&quot;创建闭包，替换 Block 的 invoke&quot;&gt;&lt;/a&gt;创建闭包，替换 Block 的 &lt;code&gt;invoke&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;可以使用函数模板（&lt;code&gt;ffi_cif&lt;/code&gt;）和一个函数指针（&lt;code&gt;replacementInvoke&lt;/code&gt;）创建闭包(&lt;code&gt;ffi_closure&lt;/code&gt;)。&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;_closure = ffi_closure_alloc(&lt;span class=&quot;name&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;name&quot;&gt;ffi_closure&lt;/span&gt;), &lt;span class=&quot;symbol&quot;&gt;&amp;amp;_replacementInvoke&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当 &lt;code&gt;replacementInvoke()&lt;/code&gt; 函数被调用时，绑定到闭包上的函数 &lt;code&gt;void BHFFIClosureFunc(ffi_cif *cif, void *ret, void **args, void *userdata)&lt;/code&gt; 会被调用。传给 &lt;code&gt;replacementInvoke()&lt;/code&gt; 的参数及其返回值都会被传给 &lt;code&gt;BHFFIClosureFunc()&lt;/code&gt;。&lt;code&gt;ffi_prep_closure_loc&lt;/code&gt; 函数的倒数第二个参数是 &lt;code&gt;user_data&lt;/code&gt;，也会被传给 &lt;code&gt;BHFFIClosureFunc()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)_prepClosure&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ffi_status status = ffi_prep_closure_loc(_closure, &amp;amp;_cif, BHFFIClosureFunc, (__bridge void *)(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;), _replacementInvoke);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(status != FFI_OK)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@&lt;span class=&quot;string&quot;&gt;&quot;ffi_prep_closure returned %d&quot;&lt;/span&gt;, (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)status);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        abort();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// exchange invoke func imp&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _originInvoke = ((__bridge &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;_BHBlock&lt;/span&gt;&lt;/span&gt; *)&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.block)-&amp;gt;invoke;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ((__bridge &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;_BHBlock&lt;/span&gt;&lt;/span&gt; *)&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.block)-&amp;gt;invoke = _replacementInvoke;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;将函数指针 &lt;code&gt;_replacementInvoke&lt;/code&gt; 和函数模板 &lt;code&gt;_cif&lt;/code&gt; 绑定函数闭包之后，需要将 block 的 &lt;code&gt;invoke&lt;/code&gt; 替换成 &lt;code&gt;_replacementInvoke&lt;/code&gt;，并把原始的实现存到 &lt;code&gt;_originInvoke&lt;/code&gt;。&lt;code&gt;invoke&lt;/code&gt; 函数的模板跟 block 的签名内容是一致的。&lt;/p&gt;
&lt;p&gt;这样当 block 调用时，实际上会调用 &lt;code&gt;_replacementInvoke&lt;/code&gt; 函数，进而调用 &lt;code&gt;BHFFIClosureFunc&lt;/code&gt; 通用函数。在这里面会实现 hook 的逻辑。&lt;/p&gt;
&lt;p&gt;还原 Hook 的 &lt;code&gt;remove&lt;/code&gt; 逻辑也很简单，将 &lt;code&gt;_originInvoke&lt;/code&gt; 恢复到 &lt;code&gt;invoke&lt;/code&gt; 即可：&lt;/p&gt;
&lt;figure class=&quot;highlight livescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;((__bridge struct _BHBlock *)self.block)&lt;/span&gt;-&amp;gt;&lt;/span&gt;invoke = _originInvoke;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;实现通用-Hook-函数&quot;&gt;&lt;a href=&quot;#实现通用-Hook-函数&quot; class=&quot;headerlink&quot; title=&quot;实现通用 Hook 函数&quot;&gt;&lt;/a&gt;实现通用 Hook 函数&lt;/h3&gt;&lt;p&gt;所有被 hook 的 block 调用时都会走到 &lt;code&gt;BHFFIClosureFunc&lt;/code&gt; 这里，可以拿到 block-&amp;gt;invoke 的函数模板，返回值指针，参数列表。还有自定义的 &lt;code&gt;userdata&lt;/code&gt;，传入的是 &lt;code&gt;BHToken&lt;/code&gt; 对象。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;ffi_call()&lt;/code&gt; 动态调用 block 的原始实现 &lt;code&gt;_originInvoke&lt;/code&gt;，并将参数列表和返回值指针传入。还需要传入函数模板，满足 Calling Convention。&lt;/p&gt;
&lt;figure class=&quot;highlight stata&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static void BHFFIClosureFunc(ffi_cif *cif, void *&lt;span class=&quot;keyword&quot;&gt;ret&lt;/span&gt;, void **&lt;span class=&quot;keyword&quot;&gt;args&lt;/span&gt;, void *userdata)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    BHToken *&lt;span class=&quot;keyword&quot;&gt;token&lt;/span&gt; = (__bridge BHToken *)(userdata);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;token&lt;/span&gt;.retValue = &lt;span class=&quot;keyword&quot;&gt;ret&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (BlockHookModeBefore == &lt;span class=&quot;keyword&quot;&gt;token&lt;/span&gt;.mode) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;keyword&quot;&gt;token&lt;/span&gt; invokeHookBlockWithArgs:&lt;span class=&quot;keyword&quot;&gt;args&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!(BlockHookModeInstead == &lt;span class=&quot;keyword&quot;&gt;token&lt;/span&gt;.mode &amp;amp;&amp;amp; [&lt;span class=&quot;keyword&quot;&gt;token&lt;/span&gt; invokeHookBlockWithArgs:&lt;span class=&quot;keyword&quot;&gt;args&lt;/span&gt;])) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ffi_call(&amp;amp;&lt;span class=&quot;keyword&quot;&gt;token&lt;/span&gt;-&amp;gt;_cif, &lt;span class=&quot;keyword&quot;&gt;token&lt;/span&gt;-&amp;gt;_originInvoke, &lt;span class=&quot;keyword&quot;&gt;ret&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;args&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (BlockHookModeAfter == &lt;span class=&quot;keyword&quot;&gt;token&lt;/span&gt;.mode) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;keyword&quot;&gt;token&lt;/span&gt; invokeHookBlockWithArgs:&lt;span class=&quot;keyword&quot;&gt;args&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;根据 Hook mode，会在不同的时机调用 &lt;code&gt;invokeHookBlockWithArgs:&lt;/code&gt; 方法执行 hook 的逻辑。&lt;/p&gt;
&lt;h3 id=&quot;组装-NSInvocation-执行-Hook-逻辑&quot;&gt;&lt;a href=&quot;#组装-NSInvocation-执行-Hook-逻辑&quot; class=&quot;headerlink&quot; title=&quot;组装 NSInvocation 执行 Hook 逻辑&quot;&gt;&lt;/a&gt;组装 &lt;code&gt;NSInvocation&lt;/code&gt; 执行 Hook 逻辑&lt;/h3&gt;&lt;p&gt;Hook 逻辑实现在 &lt;code&gt;self.hookBlock&lt;/code&gt; 中，被 Hook 的 block 是 &lt;code&gt;self.block&lt;/code&gt;，分别获取两者的签名，并拷贝后者的参数传给前者构造的 &lt;code&gt;blockInvocation&lt;/code&gt;。这里要注意 &lt;code&gt;self.hookBlock&lt;/code&gt; 的参数比 &lt;code&gt;self.block&lt;/code&gt; 多一个 &lt;code&gt;token&lt;/code&gt;，所以在二者参数比对和传递时需要特殊处理下。最后执行 &lt;code&gt;blockInvocation&lt;/code&gt;，即调用了 &lt;code&gt;usingBlock:&lt;/code&gt; 的参数。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)invokeHookBlockWithArgs:(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; **)args&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.block || !&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.hookBlock) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSMethodSignature&lt;/span&gt; *hookBlockSignature = [&lt;span class=&quot;built_in&quot;&gt;NSMethodSignature&lt;/span&gt; signatureWithObjCTypes:BHBlockTypeEncodeString(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.hookBlock)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSMethodSignature&lt;/span&gt; *originalBlockSignature = [&lt;span class=&quot;built_in&quot;&gt;NSMethodSignature&lt;/span&gt; signatureWithObjCTypes:BHBlockTypeEncodeString(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.block)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSInvocation&lt;/span&gt; *blockInvocation = [&lt;span class=&quot;built_in&quot;&gt;NSInvocation&lt;/span&gt; invocationWithMethodSignature:hookBlockSignature];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// origin block invoke func arguments: block(self), ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// hook block signature arguments: block(self), token, ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (hookBlockSignature.numberOfArguments &amp;gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.numberOfArguments + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;Block has too many arguments. Not calling %@&quot;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (hookBlockSignature.numberOfArguments &amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [blockInvocation setArgument:(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *)&amp;amp;&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; atIndex:&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *argBuf = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;NSUInteger&lt;/span&gt; idx = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; idx &amp;lt; hookBlockSignature.numberOfArguments; idx++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *type = [originalBlockSignature getArgumentTypeAtIndex:idx - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSUInteger&lt;/span&gt; argSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSGetSizeAndAlignment&lt;/span&gt;(type, &amp;amp;argSize, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!(argBuf = reallocf(argBuf, argSize))) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;Failed to allocate memory for block invocation.&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        memcpy(argBuf, args[idx - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;], argSize);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [blockInvocation setArgument:argBuf atIndex:idx];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [blockInvocation invokeWithTarget:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.hookBlock];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (argBuf != &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        free(argBuf);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;因为用户传入的 &lt;code&gt;hookBlock&lt;/code&gt; 签名是不确定的，所以需要针对参数数量判断临界条件。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;又是大水文一篇，总算是在月末憋出来了。因为只花了一天时间写代码，实在太仓促，肯定还有一堆 bug。目前不建议用到生产环境上，辅助 debug 还是可以的，以后会慢慢优化。也欢迎各位老铁们提 PR：&lt;a href=&quot;https://github.com/yulingtianxia/BlockHook/pulls&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/yulingtianxia/BlockHook/pulls&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码大量参考了 &lt;a href=&quot;https://github.com/mikeash/MABlockClosure&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MABlockClosure&lt;/a&gt; 的一些工具函数，API 设计上致敬 &lt;a href=&quot;https://github.com/steipete/Aspects&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Aspects&lt;/a&gt;。技术上如有疏漏，还请各位大佬们多多指教。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文通过参照 &lt;code&gt;MABlockClosure&lt;/code&gt; 的实现和 &lt;code&gt;Aspects&lt;/code&gt; 的 API 设计，基于 libffi 实现了对 Objective-C Block 的 hook。GitHub 地址：&lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot;&gt;https://github.com/yulingtianxia/BlockHook&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;什么场景下需要 hook block 呢？在有源码的情况下，大部分程序员会选择直接在 block 中插代码。假如方法 A 的入参是个 block 对象，方法 A 将 block 传给方法 B,C…等。如果只有方法 A 的源码，上层传入的 block 和下层方法实现都是黑盒的话，想追踪 block 调用的时机，打印些 log，就得 hook 这个 block 对象了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yulingtianxia.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>How to make a Pebble watchface</title>
    <link href="http://yulingtianxia.com/blog/2018/01/15/How-to-make-a-Pebble-watchface/"/>
    <id>http://yulingtianxia.com/blog/2018/01/15/How-to-make-a-Pebble-watchface/</id>
    <published>2018-01-14T16:00:17.000Z</published>
    <updated>2018-09-15T08:28:13.892Z</updated>
    
    <content type="html">&lt;p&gt;之前的 leader 送了我一块 Pebble 智能手表，俗话说『穷玩车，富玩表』，希望自己能在 2018 年里『变有钱』，那就多玩玩表吧！&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;首先简单介绍下 pebble。这个系列的智能手表虽然没有触屏，甚至有的型号是黑白背光屏，但提供了四个硕大的按钮用于上滚、下滚，进入和退出操作。它的数据传输需要依赖于手机的蓝牙连接，相当于一块副屏。但能在手表上独立运行 app，不像 watchOS 1 那样必须依赖手机上的 host app。其优势是续航性和性价比。pebble 曾一度跟安卓和 iOS 系统有三分天下之势，国外很多 geek 都喜欢搞搞 pebble。它甚至提供了云端编程环境，开发者很容易上手，查文档也十分便捷。经历一些固件升级后，开发语言也从 C 语言拓展到了 JS。 发布 app 的流程也很简单，geek 们可以在上面搞些有趣的事情了。&lt;/p&gt;
&lt;p&gt;你可以在 pebble 上安装各种 app，比如查看 evernote，玩一些小游戏。用户输入只有四个按钮，以及重力感应传感器、健康相关传感器等。功能上略差，但能续航一周。它也解决了大部分关于时间的刚需，比如定制表盘，接收通知，计时器等。&lt;/p&gt;
&lt;p&gt;出于对 pebble 的好奇以及感叹时间从自己身边流逝，时刻提醒自己把握当下珍惜每一秒，我做了一个简单有趣的 watchface。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yulingtianxia/Pebble-MoHa/blob/master/watchface.gif?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;戴着黑框眼镜的程序员哥哥在手表中仿佛看到了自己，并时刻提醒着我们珍惜每一秒的光阴。pebble 以超长续航能力著称，于是我索性将电池电量一直显示满格，满足一切强迫症患者！同样以『超长待机』著称的英国女王伊丽莎白二世出生于 1926 年，有了来自女王的 buff 加持，你的 pebble 将会更持久更耐用！&lt;/p&gt;
&lt;p&gt;为了展现上面 GIF 的效果，我设置了个定时器每秒回调下面的函数：&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; void update_time() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 获取当地时间戳&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  time_t temp = time(NULL);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;tm&lt;/span&gt;&lt;/span&gt; *tick_time = localtime(&amp;amp;temp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 时间戳转字符串：时，分，显示到 label 上&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; s_hour_buffer[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  strftime(s_hour_buffer, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(s_hour_buffer), clock_is_24h_style() ?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                          &lt;span class=&quot;string&quot;&gt;&quot;%H&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;&quot;%I&quot;&lt;/span&gt;, tick_time);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  text_layer_set_text(s_left_time_layer, s_hour_buffer);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; s_minute_buffer[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  strftime(s_minute_buffer, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(s_minute_buffer), &lt;span class=&quot;string&quot;&gt;&quot;%M&quot;&lt;/span&gt;, tick_time);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  text_layer_set_text(s_right_time_layer, s_minute_buffer);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 每隔一秒切换下显示状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (tick_time-&amp;gt;tm_sec % &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    layer_set_hidden((Layer *)s_eye_layer, &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    layer_set_hidden((Layer *)s_left_time_layer, &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    layer_set_hidden((Layer *)s_right_time_layer, &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bitmap_layer_set_bitmap(s_nose_layer, s_nose_empty_bitmap);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    layer_set_hidden((Layer *)s_eye_layer, &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    layer_set_hidden((Layer *)s_left_time_layer, &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    layer_set_hidden((Layer *)s_right_time_layer, &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bitmap_layer_set_bitmap(s_nose_layer, s_nose_bitmap);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 显示每日金句&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *s_words[] = &amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;You Naive!&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;I&#39;m angry!&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;2 young 2 simple&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Wearing 3 watch&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Apply for Professor&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Excited!&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Sometimes naive!&quot;&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  text_layer_set_text(s_word_layer, s_words[tick_time-&amp;gt;tm_wday]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最终实现的代码只有一百多行，GitHub 地址： &lt;a href=&quot;https://github.com/yulingtianxia/Pebble-MoHa&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/yulingtianxia/Pebble-MoHa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里说几个开发时需要注意的地方：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;显示带 alpha 通道的 png 图片时需要参照下&lt;a href=&quot;https://developer.pebble.com/blog/2015/05/13/tips-and-tricks-transparent-images/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇指引&lt;/a&gt;，我 P 图的时候干脆搞成不透明的了。&lt;/li&gt;
&lt;li&gt;位图无法缩放，但可以设置其在 &lt;code&gt;BitmapLayer&lt;/code&gt; 中的对齐策略。&lt;/li&gt;
&lt;li&gt;加载资源时需要加上 &lt;code&gt;RESOURCE_ID_&lt;/code&gt; 前缀。&lt;/li&gt;
&lt;li&gt;系统自带的字体并不是所有字号都有的，种类很有限。&lt;/li&gt;
&lt;li&gt;圆形手表的 &lt;code&gt;Window&lt;/code&gt; 的 &lt;code&gt;bounds.size&lt;/code&gt; 是外接矩形，有内建方法判断是否是圆形手表。&lt;/li&gt;
&lt;li&gt;真机调试需要打开手机上 Pebble 官方 App，打开开发者模式，开启开发者连接，保持蓝牙连接，让电脑与手机在同一个子网内。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我选择使用云端开发工具 &lt;a href=&quot;https://cloudpebble.net/ide/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CloudPebble&lt;/a&gt; 而不是本地 sdk，主要是因为 CloudPebble 集成了一套创建和管理工程、托管代码和资源、在真机或模拟器编译运行、持续集成以及支持同步 GitHub 的开发环境。很适合初学者快速上手，敏捷开发。&lt;/p&gt;
&lt;p&gt;开发语言选择 C 语言，并不是为了装逼，也不是因为我不会 JS，而是因为 leader 送我的手表所支持固件最新版本目前为 v3.12.3，而使用 JS 开发需要依赖 Rocky.js，要求固件版本 v4.x。&lt;/p&gt;
&lt;p&gt;强烈建议看这篇&lt;a href=&quot;https://developer.pebble.com/tutorials/watchface-tutorial/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方开发者教程&lt;/a&gt;来快速入门。不得不说 pebble 的开发者博客里无论是文档还是教程都很赞，就是有些 demo 的 github 连接失效了。不过按照教程一步步去做终归还是很容易搞定的。&lt;/p&gt;
&lt;p&gt;使用 &lt;a href=&quot;https://developer.pebble.com/docs/c/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Pebble C SDK&lt;/a&gt; 的 API 时会用到各种功能的函数，监听回调也都是传入自定义函数指针。跟 UI 相关的 API 跟移动开发很类似，也会提供 &lt;code&gt;Window&lt;/code&gt;，&lt;code&gt;Layer&lt;/code&gt;，&lt;code&gt;GBitmap&lt;/code&gt; 等类型。因为不涉及到 UI 的点击，所以会简单很多。但要注意的是对象的生命周期，每次调用 xxx_create 方法一定要对应调用 xxx_destroy 方法。&lt;code&gt;Layer&lt;/code&gt; 有很多子类，比如 &lt;code&gt;TextLayer&lt;/code&gt;,&lt;code&gt;BitmapLayer&lt;/code&gt; 等。这些子类可以很方便地显示文字和图片等内容。对于这次我做的 watchface 来说，图片和文字已经够用了。构建 &lt;code&gt;Layer&lt;/code&gt; 的层级关系也很简单，比如用 &lt;code&gt;layer_add_child()&lt;/code&gt; 就能往一个 &lt;code&gt;Layer&lt;/code&gt; 上添加其他 &lt;code&gt;Layer&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;目前 pebble 项目所支持的图片资源种类很少，且对二进制和资源大小均有限制。毕竟手表上能发挥的空间有限，所以将大部分逻辑放在手机上。通过蓝牙将数据传输给手表，手表上只负责展示一些比较及时的数据，做一些简单的操作同步数据给手机。所以 pebble 也提供了 iOS 和 Android 对应的 sdk。&lt;/p&gt;
&lt;p&gt;pebble 推出了好几款手表，所以一个项目对应的 target 也有五种之多。所幸的是 CloudPebble 的模拟器提供了这五种 target 的模拟器，在网页中编程也有较好的编程体验，支持高亮和查看文档。管理资源更是简单，每种 target 都提供预览。项目配置也都是可视化操作，十分容易上手。&lt;/p&gt;
&lt;p&gt;以上内容就是开发一款 pebble watchface 的基本法则，喜欢的话可以去主页点个赞：&lt;a href=&quot;https://apps.getpebble.com/applications/5a4b9bfc0dfc329496001b60&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://apps.getpebble.com/applications/5a4b9bfc0dfc329496001b60&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;之前的 leader 送了我一块 Pebble 智能手表，俗话说『穷玩车，富玩表』，希望自己能在 2018 年里『变有钱』，那就多玩玩表吧！&lt;/p&gt;
    
    </summary>
    
    
      <category term="瞎折腾" scheme="http://yulingtianxia.com/tags/%E7%9E%8E%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>Associated Object 与 Dealloc</title>
    <link href="http://yulingtianxia.com/blog/2017/12/15/Associated-Object-and-Dealloc/"/>
    <id>http://yulingtianxia.com/blog/2017/12/15/Associated-Object-and-Dealloc/</id>
    <published>2017-12-14T16:19:21.000Z</published>
    <updated>2018-09-15T08:28:13.669Z</updated>
    
    <content type="html">&lt;p&gt;我的 Objective-C 消息节流防抖库 &lt;a href=&quot;https://github.com/yulingtianxia/MessageThrottle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MessageThrottle&lt;/a&gt; 需要实现一个特性：当 &lt;code&gt;MTRule&lt;/code&gt; 的 &lt;code&gt;target&lt;/code&gt; 释放后，自动调用 &lt;code&gt;MTRule&lt;/code&gt; 的 &lt;code&gt;discard&lt;/code&gt; 方法。后来使用了业界很早就已有的方案：Associated Object，在这里整理下相关的知识点。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;问题的由来&quot;&gt;&lt;a href=&quot;#问题的由来&quot; class=&quot;headerlink&quot; title=&quot;问题的由来&quot;&gt;&lt;/a&gt;问题的由来&lt;/h2&gt;&lt;p&gt;起初的思路是考虑到 &lt;code&gt;MTRule&lt;/code&gt; 的 &lt;code&gt;target&lt;/code&gt; 属性是 &lt;code&gt;weak&lt;/code&gt; 的，想在其释放之前，也就是 &lt;code&gt;target&lt;/code&gt; 变成 &lt;code&gt;nil&lt;/code&gt; 之前调用 &lt;code&gt;MTRule&lt;/code&gt; 对象的 &lt;code&gt;discard&lt;/code&gt;  方法。然而 &lt;code&gt;target&lt;/code&gt; 被释放赋值为 &lt;code&gt;nil&lt;/code&gt; 的操作并不能通过 KVO 之类来监听，因为其并不是在外部通过 set 方法，这涉及到 &lt;code&gt;weak&lt;/code&gt; 的实现原理（PS: 可以查看源码中 &lt;code&gt;weak_clear_no_lock()&lt;/code&gt; 函数的实现）。于是问题转而变成了『在对象销毁前得到通知』。&lt;/p&gt;
&lt;p&gt;接着我在 MacRumors 上找到了一篇 2005 年的&lt;a href=&quot;https://forums.macrumors.com/threads/getting-notified-when-an-object-instance-is-deallocated.976309/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;贴子&lt;/a&gt;。大概内容就是讲通过 KVO 监听 &lt;code&gt;retainCount&lt;/code&gt; 属性纯属失了智，众所周知 &lt;code&gt;retainCount&lt;/code&gt; 不能真实反映对象内存管理的情况，即便 &lt;code&gt;retainCount&lt;/code&gt; 为 &lt;code&gt;1&lt;/code&gt; 的时候收到了 &lt;code&gt;release&lt;/code&gt; 消息，也会直接 &lt;code&gt;dealloc&lt;/code&gt; 掉，并不会变成 &lt;code&gt;0&lt;/code&gt;。接着又有人说干脆 hook 下 &lt;code&gt;dealloc&lt;/code&gt; 方法，然后抛通知，但是这样不安全。直到 2008 年 DenNukem 回帖说他直到咋办啦，用 Associated Object！&lt;/p&gt;
&lt;h2 id=&quot;实现原理&quot;&gt;&lt;a href=&quot;#实现原理&quot; class=&quot;headerlink&quot; title=&quot;实现原理&quot;&gt;&lt;/a&gt;实现原理&lt;/h2&gt;&lt;p&gt;当一个对象（Host）释放后，其关联的对象（Associated Object）也会被解除。可以在 Host 对象上添加 Associated Object，策略用 &lt;code&gt;OBJC_ASSOCIATION_RETAIN&lt;/code&gt;。由于只有 Host 持有了这个 Associated Object，当 Host 释放后 Associated Object 也会被释放。在 Associated Object 的 &lt;code&gt;dealloc&lt;/code&gt; 方法中告知外界其 Host 对象已经释放。Perfect！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;dealloc&lt;/code&gt; 方法的调用顺序是从子类到父类直至 &lt;code&gt;NSObject&lt;/code&gt; 的，&lt;code&gt;NSObject&lt;/code&gt; 的 &lt;code&gt;dealloc&lt;/code&gt; 会调用 &lt;code&gt;object_dispose()&lt;/code&gt; 函数，进而移除 Associated Object。&lt;/strong&gt;具体的实现如下:&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;object_dispose(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!obj) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 销毁对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    objc_destructInstance(obj);    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 释放内存&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    free(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *objc_destructInstance(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (obj) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Read all of the flags at once for performance.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; cxx = obj-&amp;gt;hasCxxDtor();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; assoc = obj-&amp;gt;hasAssociatedObjects();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// This order is important.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// C++ 析构&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (cxx) object_cxxDestruct(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 移除 Associated Object&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (assoc) _object_remove_assocations(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// ARC 下调用实例变量的 release 方法，移除 weak 引用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        obj-&amp;gt;clearDeallocating();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; obj;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;也就是说 Associated Object 的 &lt;code&gt;dealloc&lt;/code&gt; 调用时 Host 已经释放了，无法拿到关于 Host 对象的任何信息了。但这其实对于大部分场景已经足够了，给外界一个 block/delegate callback，甚至是抛通知都 OK 的。&lt;/strong&gt;实现起来很简单，代码很少，网上也可以找到一些 &lt;a href=&quot;https://blog.slaunchaman.com/2011/04/11/fun-with-the-objective-c-runtime-run-code-at-deallocation-of-any-object/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MRC&lt;/a&gt; 或 &lt;a href=&quot;https://github.com/ChenYilong/CYLDeallocBlockExecutor&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ARC&lt;/a&gt; 下实现的示例代码。&lt;/p&gt;
&lt;p&gt;虽说 Runtime 帮我们自动移除了 Associated Object，但对我这种平常几乎一直写 MRC 代码的人来说还真有点不适应，毕竟脑子里时刻警惕着：每一次 &lt;code&gt;retain&lt;/code&gt; 都要配套来一次 &lt;code&gt;release&lt;/code&gt; 或 &lt;code&gt;autorelease&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;MessageThrottle-的特殊定制&quot;&gt;&lt;a href=&quot;#MessageThrottle-的特殊定制&quot; class=&quot;headerlink&quot; title=&quot;MessageThrottle 的特殊定制&quot;&gt;&lt;/a&gt;MessageThrottle 的特殊定制&lt;/h2&gt;&lt;p&gt;好，又回归到文章最开头的问题。现在解决了『&lt;code&gt;MTRule&lt;/code&gt; 的 &lt;code&gt;target&lt;/code&gt; 释放后，自动调用 &lt;code&gt;MTRule&lt;/code&gt; 的 &lt;code&gt;discard&lt;/code&gt; 方法』的问题。但是，要注意到此时 &lt;code&gt;target&lt;/code&gt; 属性都释放了，于是就无法提供 &lt;code&gt;discard&lt;/code&gt; 方法正确执行做需要的信息。所以需要在 Associated Object 中加入一些属性来保存一些执行 &lt;code&gt;discard&lt;/code&gt; 时所需必要的信息。&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;MTDealloc &lt;/span&gt;: NSObject&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 这三个属性就是 discardRule:whenTargetDealloc: 方法将要用到的信息。这个方法会把 rule 从 MTEngine 列表中移除，并按需要还原之前的 hook 操作。这些细节不是重点，重点就是调用 discard 需要这仨属性。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@property&lt;/span&gt; (nonatomic, weak) MTRule *rule;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@property&lt;/span&gt; (nonatomic, copy) NSString *methodDescription;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@property&lt;/span&gt; (nonatomic) Class cls;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@implementation&lt;/span&gt; MTDealloc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)dealloc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 我只是觉得这样写代码就没警告了，而且还骚&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SEL selector = NSSelectorFromString(@&quot;&lt;span class=&quot;attribute&quot;&gt;discardRule&lt;/span&gt;:&lt;span class=&quot;attribute&quot;&gt;whenTargetDealloc&lt;/span&gt;:&quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ((void (*)(id, SEL, MTRule *, MTDealloc *))&lt;span class=&quot;selector-attr&quot;&gt;[MTEngine.defaultEngine methodForSelector:selector]&lt;/span&gt;)(MTEngine.defaultEngine, selector, self.rule, self);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后只需要在 &lt;code&gt;applyRule&lt;/code&gt; 的时候初始化和配置好 &lt;code&gt;MTDealloc&lt;/code&gt; 对象，并将其关联到 &lt;code&gt;target&lt;/code&gt; 上即可：&lt;/p&gt;
&lt;figure class=&quot;highlight puppet&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// applyRule 时调用这个方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static void mt_configureTargetDealloc(MTRule *rule)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (mt_object_isClass(rule.target)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Class cls = object_getClass(&lt;span class=&quot;literal&quot;&gt;rule&lt;/span&gt;.&lt;span class=&quot;literal&quot;&gt;target&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        MTDealloc *mtDealloc = objc_getAssociatedObject(&lt;span class=&quot;literal&quot;&gt;rule&lt;/span&gt;.&lt;span class=&quot;literal&quot;&gt;target&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;rule&lt;/span&gt;.selector);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!mtDealloc) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mtDealloc = [MTDealloc new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mtDealloc.&lt;span class=&quot;literal&quot;&gt;rule&lt;/span&gt; = &lt;span class=&quot;literal&quot;&gt;rule&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mtDealloc.methodDescription = mt_methodDescription(&lt;span class=&quot;literal&quot;&gt;rule&lt;/span&gt;.&lt;span class=&quot;literal&quot;&gt;target&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;rule&lt;/span&gt;.selector);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mtDealloc.cls = cls;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            objc_setAssociatedObject(&lt;span class=&quot;literal&quot;&gt;rule&lt;/span&gt;.&lt;span class=&quot;literal&quot;&gt;target&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;rule&lt;/span&gt;.selector, mtDealloc, OBJC_ASSOCIATION_RETAIN);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用 &lt;code&gt;rule.selector&lt;/code&gt; 作为 Key 的目的就是让 &lt;code&gt;target&lt;/code&gt; 对象上的每一个方法都对应一个关联对象，不会搞混。&lt;/p&gt;
&lt;p&gt;感兴趣的可以查看 &lt;a href=&quot;https://github.com/yulingtianxia/MessageThrottle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MessageThrottle&lt;/a&gt; 的源码，或者阅读我的上一篇文章 &lt;a href=&quot;http://yulingtianxia.com/blog/2017/11/05/Objective-C-Message-Throttle-and-Debounce/&quot;&gt;Objective-C Message Throttle and Debounce&lt;/a&gt;，更详细地讲述了 Objective-C 消息节流防抖的实现原理。这里只是对其实现自动 &lt;code&gt;discard&lt;/code&gt; 原理的补充。&lt;/p&gt;
&lt;h2 id=&quot;Reference&quot;&gt;&lt;a href=&quot;#Reference&quot; class=&quot;headerlink&quot; title=&quot;Reference&quot;&gt;&lt;/a&gt;Reference&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://forums.macrumors.com/threads/getting-notified-when-an-object-instance-is-deallocated.976309/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Getting notified when an object instance is deallocated&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.slaunchaman.com/2011/04/11/fun-with-the-objective-c-runtime-run-code-at-deallocation-of-any-object/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Fun With the Objective-C Runtime: Run Code at Deallocation of Any Object&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/10842829/will-an-associated-object-be-released-automatically/10843510#10843510&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Will An Associated Object Be Released Automatically?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ChenYilong/CYLDeallocBlockExecutor&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CYLDeallocBlockExecutor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://opensource.apple.com/source/objc4/objc4-723/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;objc4-723&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;我的 Objective-C 消息节流防抖库 &lt;a href=&quot;https://github.com/yulingtianxia/MessageThrottle&quot;&gt;MessageThrottle&lt;/a&gt; 需要实现一个特性：当 &lt;code&gt;MTRule&lt;/code&gt; 的 &lt;code&gt;target&lt;/code&gt; 释放后，自动调用 &lt;code&gt;MTRule&lt;/code&gt; 的 &lt;code&gt;discard&lt;/code&gt; 方法。后来使用了业界很早就已有的方案：Associated Object，在这里整理下相关的知识点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yulingtianxia.com/tags/Objective-C/"/>
    
      <category term="Runtime" scheme="http://yulingtianxia.com/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Message Throttle and Debounce</title>
    <link href="http://yulingtianxia.com/blog/2017/11/05/Objective-C-Message-Throttle-and-Debounce/"/>
    <id>http://yulingtianxia.com/blog/2017/11/05/Objective-C-Message-Throttle-and-Debounce/</id>
    <published>2017-11-04T16:39:44.000Z</published>
    <updated>2018-09-15T08:28:13.802Z</updated>
    
    <content type="html">&lt;p&gt;在实际项目中经常会遇到因方法调用频繁而导致的 UI 闪动问题和性能问题，这时用某种策略需要控制调用频率，以达到节流和防抖的效果。&lt;a href=&quot;https://github.com/yulingtianxia/MessageThrottle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MessageThrottle&lt;/a&gt; 是我实现的一个 Objective-C 消息节流和防抖的轻量级工具库，使用便捷且业务无关。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;读懂本文的前提是对 &lt;a href=&quot;http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/&quot;&gt;Objective-C Runtime&lt;/a&gt; 和 &lt;a href=&quot;http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/&quot;&gt;Objective-C 消息发送与转发机制原理&lt;/a&gt;有一定了解。&lt;/p&gt;
&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;函数节流（throttle）是一个很基础的概念，常常跟函数防抖（debounce）作比较。在处理连续事件时比较常用，可以通过&lt;a href=&quot;http://demo.nimius.net/debounce_throttle/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这个 Demo&lt;/a&gt; 感受下二者区别。在 JS 中有较多的实现和应用案例，可以查看&lt;a href=&quot;https://blog.coding.net/blog/the-difference-between-throttle-and-debounce-in-underscorejs&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇文章&lt;/a&gt; 更直接地了解下。&lt;/p&gt;
&lt;p&gt;虽然在开发 iOS 和 macOS 的时候不用过多关心连续事件的采样问题，但有时也需要避免某个方法被频繁调用。比如一个很复杂的页面可能会频繁请求网络，每次回包都需更新界面，这时就需要防抖，控制刷新频率。&lt;/p&gt;
&lt;p&gt;在 Objective-C 中，方法调用其实就是消息发送，所以我改了个名字，叫消息节流和防抖。&lt;/p&gt;
&lt;h2 id=&quot;使用姿势&quot;&gt;&lt;a href=&quot;#使用姿势&quot; class=&quot;headerlink&quot; title=&quot;使用姿势&quot;&gt;&lt;/a&gt;使用姿势&lt;/h2&gt;&lt;p&gt;假如我创建了一个 &lt;code&gt;Stub&lt;/code&gt; 类的实例 &lt;code&gt;s&lt;/code&gt;，我想限制它调用 &lt;code&gt;foo:&lt;/code&gt; 方法的频率。先要创建并配置一个 &lt;code&gt;MTRule&lt;/code&gt;，并将规则应用到 &lt;code&gt;MTEngine&lt;/code&gt; 单例中：&lt;/p&gt;
&lt;figure class=&quot;highlight coffeescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Stub *s = [Stub &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MTRule *rule = [MTRule &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rule.target = s; &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt; You can also assign `&lt;span class=&quot;javascript&quot;&gt;Stub.class&lt;/span&gt;` &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; `&lt;span class=&quot;javascript&quot;&gt;mt_metaClass(Stub.class)&lt;/span&gt;`&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rule.selector = @selector(foo:);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rule.durationThreshold = &lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[MTEngine.defaultEngine applyRule:rule]; &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; use `&lt;span class=&quot;javascript&quot;&gt;[rule apply]&lt;/span&gt;`&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;target&lt;/code&gt; 可以是一个实例对象，也可以是一个类或元类。这样可以更灵活地控制限制策略，既可以只控制某个对象的消息发送频率，也可以控制某个类的实例方法和类方法的频率。当然，规则的 &lt;code&gt;target&lt;/code&gt; 为实例对象的优先级比类更高，也不会发生冲突。&lt;/p&gt;
&lt;p&gt;当然还有更简单的用法，跟上面那段代码作用相同：&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[s &lt;span class=&quot;string&quot;&gt;limitSelector:&lt;/span&gt;&lt;span class=&quot;meta&quot;&gt;@selector&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;foo:&lt;/span&gt;) &lt;span class=&quot;string&quot;&gt;oncePerDuration:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;]; &lt;span class=&quot;comment&quot;&gt;// returns MTRule instance&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;无论是节流还是防抖，都需要设定一个时间 &lt;code&gt;durationThreshold&lt;/code&gt; 阈值来限制频率，都意味着方法在最后会延迟调用。&lt;code&gt;MTRule&lt;/code&gt; 默认的模式是 &lt;code&gt;MTPerformModeDebounce&lt;/code&gt;，也就是防抖模式，需要等消息不再连续频繁发送后才执行。&lt;code&gt;MTPerformModeLast&lt;/code&gt; 和 &lt;code&gt;MTPerformModeFirstly&lt;/code&gt; 对应着节流模式，也就是控制一定时间内只执行一次。区别在于前者执行的是这段时间内最后发送的消息，后者执行第一次发送的消息。&lt;/p&gt;
&lt;p&gt;比如我想要控制界面上某个 Label 内容的更新频率，给用户更好的体验，这时候很适合使用 &lt;code&gt;MTPerformModeLast&lt;/code&gt; 模式：&lt;/p&gt;
&lt;figure class=&quot;highlight crmsh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.mode = MTPerformModeLast;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当然所有规则都是可以动态调整的，也就是在应用规则以后，依然可以改变 &lt;code&gt;MTRule&lt;/code&gt; 对象中各项配置，并会在下次消息发送时生效。如果调皮地将 &lt;code&gt;durationThreshold&lt;/code&gt; 改成非正数，那么等同于立即执行方法，不会限制频率。&lt;/p&gt;
&lt;p&gt;当使用 &lt;code&gt;MTPerformModeDebounce&lt;/code&gt; 和 &lt;code&gt;MTPerformModeLast&lt;/code&gt; 模式的时候，因为执行消息会有延迟，可以指定执行消息的队列 &lt;code&gt;messageQueue&lt;/code&gt;，默认为主队列。&lt;/p&gt;
&lt;p&gt;当想要废除某条规则时，使用一行代码即可：&lt;/p&gt;
&lt;figure class=&quot;highlight crmsh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[MTEngine.defaultEngine discardRule:&lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;]; // &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; use `[&lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt; discard]`&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;应用和废除规则都是线程安全的。&lt;/p&gt;
&lt;h2 id=&quot;实现原理&quot;&gt;&lt;a href=&quot;#实现原理&quot; class=&quot;headerlink&quot; title=&quot;实现原理&quot;&gt;&lt;/a&gt;实现原理&lt;/h2&gt;&lt;p&gt;参照 &lt;a href=&quot;https://github.com/steipete/Aspects&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Aspects&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/bang590/JSPatch&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JSPatch&lt;/a&gt; 中 Hook 的原理，将限制频率逻辑嵌入消息转发流程中：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;给类添加一个新的方法 &lt;code&gt;fixed_selector&lt;/code&gt;，对应实现为 &lt;code&gt;rule.selector&lt;/code&gt; 的 &lt;code&gt;IMP&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;利用 &lt;a href=&quot;http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/&quot;&gt;Objective-C runtime 消息转发机制&lt;/a&gt;，将 &lt;code&gt;rule.selector&lt;/code&gt; 对应的 &lt;code&gt;IMP&lt;/code&gt; 改成 &lt;code&gt;_objc_msgForward&lt;/code&gt; 从而触发调用 &lt;code&gt;forwardInvocation:&lt;/code&gt; 方法。&lt;/li&gt;
&lt;li&gt;将 &lt;code&gt;forwardInvocation:&lt;/code&gt; 的实现替换为自己实现的 &lt;code&gt;IMP&lt;/code&gt;，并在自己实现的逻辑中将 &lt;code&gt;invocation.selector&lt;/code&gt; 设为 &lt;code&gt;fixed_selector&lt;/code&gt;。并限制 &lt;code&gt;[invocation invoke]&lt;/code&gt; 的调用频率。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这种做法的缺陷是如果同时 hook 了基类和子类的同一个方法，且子类调用了基类的方法，就会导致循环调用。因为调用 &lt;code&gt;super&lt;/code&gt; 方法时，传入的 &lt;code&gt;target&lt;/code&gt; 还是 &lt;code&gt;self&lt;/code&gt; 对象，导致调用了子类的方法。好在这里并不允许同时 hook 一条继承链上的两个类，因为子类和基类限制频率的规则会相互干扰，导致不易发现的 bug。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/yulingtianxia/MessageThrottle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MessageThrottle&lt;/a&gt; 从设计上使用 &lt;code&gt;MTEngine&lt;/code&gt; 单例这种中心化的的方式来管理所有规则。Aspects 是将 hook 的上下文插入到对应的 &lt;code&gt;target&lt;/code&gt; 中，这样的好处是需要暴露的接口较少。而 &lt;a href=&quot;https://github.com/yulingtianxia/MessageThrottle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MessageThrottle&lt;/a&gt; 需要提供当前所有的规则给使用方。因为方法调用频率的限制会影响其上游代码和下游代码的运行频率，所以中心化管理的做法很有必要。&lt;/p&gt;
&lt;p&gt;由于配置规则的内容较多，如果使用逐个传参的方式，方法名会很长。所以这里用 &lt;code&gt;MTRule&lt;/code&gt; 类封装了规则的上下文，并使用 &lt;code&gt;applyRule:&lt;/code&gt; 和 &lt;code&gt;discardRule:&lt;/code&gt; 方法应用和废除规则。&lt;/p&gt;
&lt;h3 id=&quot;管理-MTRule&quot;&gt;&lt;a href=&quot;#管理-MTRule&quot; class=&quot;headerlink&quot; title=&quot;管理 MTRule&quot;&gt;&lt;/a&gt;管理 &lt;code&gt;MTRule&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;MTEngine&lt;/code&gt; 内部使用键值对存取 &lt;code&gt;MTRule&lt;/code&gt;，这里使用 &lt;code&gt;target&lt;/code&gt; 和 &lt;code&gt;selector&lt;/code&gt; 的组合值作为 key。这里只要保证唯一性即可区分不同的规则，格式不固定：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; * mt_methodDescription(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; target, SEL selector)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *selectorName = &lt;span class=&quot;built_in&quot;&gt;NSStringFromSelector&lt;/span&gt;(selector);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (object_isClass(target)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *className = &lt;span class=&quot;built_in&quot;&gt;NSStringFromClass&lt;/span&gt;(target);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; stringWithFormat:&lt;span class=&quot;string&quot;&gt;@&quot;%@ [%@ %@]&quot;&lt;/span&gt;, class_isMetaClass(target) ? &lt;span class=&quot;string&quot;&gt;@&quot;+&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;@&quot;-&quot;&lt;/span&gt;, className, selectorName];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; stringWithFormat:&lt;span class=&quot;string&quot;&gt;@&quot;[%p %@]&quot;&lt;/span&gt;, target, selectorName];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在应用和废除规则的时候，需要检查规则合法性。这里只是简单检查下库中涉及的类和方法，一些内存管理和runtime 的方法并没有做限制，毕竟用户想作死我也管不着：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; mt_checkRuleValid(MTRule *rule)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (rule.target &amp;amp;&amp;amp; rule.selector &amp;amp;&amp;amp; rule.durationThreshold &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *selectorName = &lt;span class=&quot;built_in&quot;&gt;NSStringFromSelector&lt;/span&gt;(rule.selector);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([selectorName isEqualToString:&lt;span class=&quot;string&quot;&gt;@&quot;forwardInvocation:&quot;&lt;/span&gt;]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Class cls;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (object_isClass(rule.target)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            cls = rule.target;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            cls = object_getClass(rule.target);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *className = &lt;span class=&quot;built_in&quot;&gt;NSStringFromClass&lt;/span&gt;(cls);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([className isEqualToString:&lt;span class=&quot;string&quot;&gt;@&quot;MTRule&quot;&lt;/span&gt;] || [className isEqualToString:&lt;span class=&quot;string&quot;&gt;@&quot;MTEngine&quot;&lt;/span&gt;]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;处理-NSInvocation&quot;&gt;&lt;a href=&quot;#处理-NSInvocation&quot; class=&quot;headerlink&quot; title=&quot;处理 NSInvocation&quot;&gt;&lt;/a&gt;处理 &lt;code&gt;NSInvocation&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;在进入到消息转发流程调用 &lt;code&gt;forwardInvocation:&lt;/code&gt; 方法时会进入到自定义的处理逻辑中，然后决定是否执行 &lt;code&gt;[invocation invoke]&lt;/code&gt;。之前已经将原始 &lt;code&gt;selector&lt;/code&gt; 的 IMP 替换成了 &lt;code&gt;fixedSelector&lt;/code&gt;，所以调用 &lt;code&gt;[invocation invoke]&lt;/code&gt; 之前需要调用 &lt;code&gt;invocation.selector = fixedSelector&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;下面的函数就是处理 &lt;code&gt;NSInvocation&lt;/code&gt; 对象的逻辑。先用 &lt;code&gt;target&lt;/code&gt; 和 &lt;code&gt;selector&lt;/code&gt; 获取 &lt;code&gt;MTRule&lt;/code&gt; 对象，进而根据不同的 &lt;code&gt;mode&lt;/code&gt; 采取不同的策略。如果 &lt;code&gt;durationThreshold&lt;/code&gt; 非正数就立即执行方法。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; mt_handleInvocation(&lt;span class=&quot;built_in&quot;&gt;NSInvocation&lt;/span&gt; *invocation, SEL fixedSelector)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *methodDescriptionForInstance = mt_methodDescription(invocation.target, invocation.selector);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *methodDescriptionForClass = mt_methodDescription(object_getClass(invocation.target), invocation.selector);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MTRule *rule = MTEngine.defaultEngine.rules[methodDescriptionForInstance];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!rule) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        rule = MTEngine.defaultEngine.rules[methodDescriptionForClass];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (rule.durationThreshold &amp;lt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [invocation setSelector:fixedSelector];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [invocation invoke];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSTimeInterval&lt;/span&gt; now = [[&lt;span class=&quot;built_in&quot;&gt;NSDate&lt;/span&gt; date] timeIntervalSince1970];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; (rule.mode) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; MTPerformModeFirstly:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; MTPerformModeLast:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; MTPerformModeDebounce:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码省略了不同 &lt;code&gt;mode&lt;/code&gt; 的处理逻辑，下面会逐个讲解。&lt;/p&gt;
&lt;h4 id=&quot;MTPerformModeFirstly&quot;&gt;&lt;a href=&quot;#MTPerformModeFirstly&quot; class=&quot;headerlink&quot; title=&quot;MTPerformModeFirstly&quot;&gt;&lt;/a&gt;&lt;code&gt;MTPerformModeFirstly&lt;/code&gt;&lt;/h4&gt;&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;MTModePerformFirstly&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;start                                                                end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|                           durationThreshold                          |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@-------------------------&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;@----------&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;@---------------&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;@----------------&lt;/span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|                         |          |               |          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;perform immediately       ignore     ignore          ignore&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最简单粗暴的实现方式，忽略第一次发送消息之后 &lt;code&gt;durationThreshold&lt;/code&gt; 时间段内的所有消息。&lt;/p&gt;
&lt;figure class=&quot;highlight inform7&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if (now - &lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.lastTimeRequest &amp;gt; &lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.durationThreshold) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.lastTimeRequest = now;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	invocation.selector = fixedSelector;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;[invocation invoke]&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.lastInvocation = nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;MTPerformModeLast&quot;&gt;&lt;a href=&quot;#MTPerformModeLast&quot; class=&quot;headerlink&quot; title=&quot;MTPerformModeLast&quot;&gt;&lt;/a&gt;&lt;code&gt;MTPerformModeLast&lt;/code&gt;&lt;/h4&gt;&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;MTModePerformLast&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;start                                                                end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|                           durationThreshold                          |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@-------------------------&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;@----------&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;@---------------&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;@----------------&lt;/span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|                         |          |               |          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ignore                    ignore     ignore          will perform at end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 &lt;code&gt;durationThreshold&lt;/code&gt; 时间内不断更新 &lt;code&gt;lastInvocation&lt;/code&gt; 的值，并在达到阈值 &lt;code&gt;durationThreshold&lt;/code&gt; 后执行 &lt;code&gt;[lastInvocation invoke]&lt;/code&gt;。这样保证了执行的是最后一次发送的消息。需要注意的是，&lt;code&gt;NSInvocation&lt;/code&gt; 对象默认不会持有参数，在异步延迟执行 &lt;code&gt;invoke&lt;/code&gt; 的时候参数可能已经被释放了，进而野指针 crash。所以需要调用 &lt;code&gt;retainArguments&lt;/code&gt; 方法提前持有参数，防止之后被释放掉。如果实际传入的参数与参数类型不符，可能导致 &lt;code&gt;retainArguments&lt;/code&gt; 方法 crash。我曾想过将参数列表保存到一个 &lt;code&gt;NSArray&lt;/code&gt; 里，然后放到 &lt;code&gt;MTRule&lt;/code&gt; 中，这样可以对参数类型做判断，避免 crash，也顺便持有了参数列表。但发现需要覆盖的类型太多，工作量和风险更多。我把这个半成品代码放在了 GitHubGist 上: &lt;a href=&quot;https://gist.github.com/yulingtianxia/1518fc7604ed65aa4ca98abdeee974e1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ConvertInvocationArguments.m&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight crmsh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if (now - &lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.lastTimeRequest &amp;gt; &lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.durationThreshold) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.lastTimeRequest = now;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(&lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.durationThreshold * NSEC_PER_SEC)), &lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.messageQueue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		[&lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.lastInvocation invoke];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.lastInvocation = nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	invocation.selector = fixedSelector;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.lastInvocation = invocation;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	[&lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.lastInvocation retainArguments];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;MTPerformModeDebounce&quot;&gt;&lt;a href=&quot;#MTPerformModeDebounce&quot; class=&quot;headerlink&quot; title=&quot;MTPerformModeDebounce&quot;&gt;&lt;/a&gt;&lt;code&gt;MTPerformModeDebounce&lt;/code&gt;&lt;/h4&gt;&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;MTModePerformDebounce&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;start                                        end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|           durationThreshold(old)             |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@----------------------&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;@----------------------&lt;/span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|                      |                 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ignore                 will perform at end of new duration&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                       |---------------------------------------------&amp;gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                       |           durationThreshold(new)             |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                       start                                        end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;虽然流程看上去复杂但其实实现起来也很简单。每次发送消息完再过 &lt;code&gt;durationThreshold&lt;/code&gt; 时间后，检查下 &lt;code&gt;lastInvocation&lt;/code&gt; 有没有变化。如果无变化，则说明这段时间内没有新的消息发送，则可以执行 &lt;code&gt;lastInvocation&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight crmsh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;invocation.selector = fixedSelector;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.lastInvocation = invocation;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.lastInvocation retainArguments];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(&lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.durationThreshold * NSEC_PER_SEC)), &lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.messageQueue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if (&lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.lastInvocation == invocation) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		[&lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.lastInvocation invoke];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.lastInvocation = nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;规则的应用与废除&quot;&gt;&lt;a href=&quot;#规则的应用与废除&quot; class=&quot;headerlink&quot; title=&quot;规则的应用与废除&quot;&gt;&lt;/a&gt;规则的应用与废除&lt;/h3&gt;&lt;p&gt;在真正应用规则之前，需要检查下规则合法性，然后检查继承链上是否已经应用过规则了。如果有，则需要输出错误信息；否则应用规则。这里使用 POSIX 的互斥锁保证线程安全。&lt;code&gt;mt_overrideMethod()&lt;/code&gt; 函数所作的事情就是开始提到的利用消息转发流程 hook 的三个步骤。&lt;/p&gt;
&lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;BOOL)applyRule:(MTRule &lt;/span&gt;*)rule&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_mutex_lock(&amp;amp;mutex)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __block &lt;span class=&quot;keyword&quot;&gt;BOOL &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;shouldApply &lt;/span&gt;= YES&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (mt_checkRuleValid(rule)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [self.rules enumerateKeysAndObjectsUsingBlock:^(NSString * _Nonnull key, MTRule * _Nonnull obj, &lt;span class=&quot;keyword&quot;&gt;BOOL &lt;/span&gt;* _Nonnull stop) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if (rule.selector == obj.selector&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;amp;&amp;amp; object_isClass(rule.target)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;amp;&amp;amp; object_isClass(obj.target)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Class clsA = rule.target&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Class clsB = obj.target&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;shouldApply &lt;/span&gt;= !([clsA isSubclassOfClass:clsB] &lt;span class=&quot;title&quot;&gt;||&lt;/span&gt; [clsB isSubclassOfClass:clsA])&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                *stop = &lt;span class=&quot;keyword&quot;&gt;shouldApply;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;                NSString *errorDescription = [NSString stringWithFormat:@&lt;span class=&quot;string&quot;&gt;&quot;Error: %@ already apply rule in %@. A message can only have one throttle per class hierarchy.&quot;&lt;/span&gt;, NSStringFromSelector(obj.selector), NSStringFromClass(clsB)]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                NSLog(@&lt;span class=&quot;string&quot;&gt;&quot;%@&quot;&lt;/span&gt;, errorDescription)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (&lt;span class=&quot;keyword&quot;&gt;shouldApply) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self.rules[mt_methodDescription(rule.target, rule.selector)] = rule&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mt_overrideMethod(rule.target, rule.selector)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_mutex_unlock(&amp;amp;mutex)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return &lt;span class=&quot;keyword&quot;&gt;shouldApply;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;废除规则是执行相反的操作。如果 &lt;code&gt;target&lt;/code&gt; 是个实例对象，&lt;code&gt;mt_recoverMethod()&lt;/code&gt; 函数会判断是否有相同 &lt;code&gt;selector&lt;/code&gt; 且 &lt;code&gt;target&lt;/code&gt; 为这个实例对象的类的其他规则。如果有，那将不会移除 hook。&lt;/p&gt;
&lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;BOOL)discardRule:(MTRule &lt;/span&gt;*)rule&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_mutex_lock(&amp;amp;mutex)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;BOOL &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;shouldDiscard &lt;/span&gt;= NO&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (mt_checkRuleValid(rule)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSString *description = mt_methodDescription(rule.target, rule.selector)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;shouldDiscard &lt;/span&gt;= self.rules[description] != nil&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (&lt;span class=&quot;keyword&quot;&gt;shouldDiscard) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self.rules[description] = nil&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mt_recoverMethod(rule.target, rule.selector)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_mutex_unlock(&amp;amp;mutex)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return &lt;span class=&quot;keyword&quot;&gt;shouldDiscard;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;后记&quot;&gt;&lt;a href=&quot;#后记&quot; class=&quot;headerlink&quot; title=&quot;后记&quot;&gt;&lt;/a&gt;后记&lt;/h2&gt;&lt;p&gt;其实在开发过程中遇到需要限制方法调用频率的场景并不多，只是最近恰巧连续碰到几个刷新 UI 过频繁的问题，才想到应该去造个轮子。因为时间仓促，肯定还有考虑不周和一些 bug，待投入使用后慢慢完善和修复。&lt;/p&gt;
&lt;p&gt;其实想在某个特定函数做节流很简单，但每次都需要做重复劳动，写脏代码，还不如抽象出一个工具类出来。尽量造与业务无关的轮子，锻炼技术，也受益整个业务发展。&lt;/p&gt;
&lt;p&gt;好，装逼到此为止。Github : &lt;a href=&quot;https://github.com/yulingtianxia/MessageThrottle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/yulingtianxia/MessageThrottle&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在实际项目中经常会遇到因方法调用频繁而导致的 UI 闪动问题和性能问题，这时用某种策略需要控制调用频率，以达到节流和防抖的效果。&lt;a href=&quot;https://github.com/yulingtianxia/MessageThrottle&quot;&gt;MessageThrottle&lt;/a&gt; 是我实现的一个 Objective-C 消息节流和防抖的轻量级工具库，使用便捷且业务无关。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yulingtianxia.com/tags/Objective-C/"/>
    
      <category term="Runtime" scheme="http://yulingtianxia.com/tags/Runtime/"/>
    
      <category term="Message Forwarding" scheme="http://yulingtianxia.com/tags/Message-Forwarding/"/>
    
  </entry>
  
  <entry>
    <title>Threading Programming Guide(3)</title>
    <link href="http://yulingtianxia.com/blog/2017/10/08/Threading-Programming-Guide-3/"/>
    <id>http://yulingtianxia.com/blog/2017/10/08/Threading-Programming-Guide-3/</id>
    <published>2017-10-08T09:03:54.000Z</published>
    <updated>2018-09-15T08:28:13.573Z</updated>
    
    <content type="html">&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Threading Programming Guide&lt;/a&gt; 的学习笔记&amp;amp;翻译，第三部分。关于同步的内容。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2017/08/28/Threading-Programming-Guide-1/&quot;&gt;Threading Programming Guide(1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2017/09/17/Threading-Programming-Guide-2/&quot;&gt;Threading Programming Guide(2)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;同步&quot;&gt;&lt;a href=&quot;#同步&quot; class=&quot;headerlink&quot; title=&quot;同步&quot;&gt;&lt;/a&gt;同步&lt;/h2&gt;&lt;p&gt;两个线程同时修改同一个资源可能会不小心干扰到对方，多线程存取资源带来了潜在的线程安全问题。比如，一个线程可能会覆盖了另一个线程的修改，或者使应用置于未知混乱状态。如果幸运的话，错乱的资源可能会导致明显的性能问题或 crash 这类相对容易复现和解决的 bug；如果不太走运，面临的就是短时间难以重现的 bug 和对代码的全面排查。&lt;/p&gt;
&lt;p&gt;为了线程安全，要尽量避免共享资源并减少线程间交互。即便有必须交互的地方，也需要使用同步工具来确保安全。&lt;/p&gt;
&lt;p&gt;macOS 和 iOS 提供了许多同步工具，范围涵盖互斥操作工具到应用中的序列化事件。下面会介绍这些工具的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;同步工具&quot;&gt;&lt;a href=&quot;#同步工具&quot; class=&quot;headerlink&quot; title=&quot;同步工具&quot;&gt;&lt;/a&gt;同步工具&lt;/h3&gt;&lt;p&gt;完全避免同步问题是理想方案，但并不现实。下面介绍几类基本的同步工具。&lt;/p&gt;
&lt;h4 id=&quot;原子操作&quot;&gt;&lt;a href=&quot;#原子操作&quot; class=&quot;headerlink&quot; title=&quot;原子操作&quot;&gt;&lt;/a&gt;原子操作&lt;/h4&gt;&lt;p&gt;原子操作是对简单数据类型同步的一种简易形式。优点是不会阻塞竞争的线程。对于简单的操作，比如增加计数器变量的值，原子操作比锁拥有更好的性能。&lt;/p&gt;
&lt;p&gt;macOS 和 iOS 包含许多基本的数学和逻辑运算的操作，可以在 32 位和 64 位上执行。其中就有 compare-and-swap, test-and-set 和 test-and-clear 操作的原子版本。 详见 &lt;code&gt;/usr/include/libkern/OSAtomic.h&lt;/code&gt; 头文件，或 &lt;code&gt;atomic&lt;/code&gt; man page。&lt;/p&gt;
&lt;h4 id=&quot;内存屏障和-Volatile-变量&quot;&gt;&lt;a href=&quot;#内存屏障和-Volatile-变量&quot; class=&quot;headerlink&quot; title=&quot;内存屏障和 Volatile 变量&quot;&gt;&lt;/a&gt;内存屏障和 &lt;code&gt;Volatile&lt;/code&gt; 变量&lt;/h4&gt;&lt;p&gt;编译器为了让性能达到最佳，会经常重排序汇编指令，这就有可能导致存取内存的顺序跟着变化，进而产生错误数据，影响到一些看似各自独立的变量。由于编译器优化造成对变量错误的更新顺序，产生了潜在的错误结果。&lt;/p&gt;
&lt;p&gt;内存屏障（Memory Barrier）是一种非阻塞的同步工具，用来确保以正确的顺序操作内存。Memory Barrier 就像栅栏一样，强制处理器在栅栏之前的所有读写操作都执行后才可以开始执行栅栏之后的操作。内存屏障知识详见维基百科 &lt;a href=&quot;https://en.wikipedia.org/wiki/Memory_barrier&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Memory Barrier&lt;/a&gt;。可以在代码中调用 &lt;code&gt;OSMemoryBarrier&lt;/code&gt; 函数添加内存屏障，详见 &lt;code&gt;OSMemoryBarrier&lt;/code&gt; man page。&lt;/p&gt;
&lt;p&gt;Volatile 关键字对单独的变量应用了另一种内存约束。编译器为了优化代码，会将变量的值加载到寄存器中。对于局部变量这没毛病，如果这个变量由别的线程更新了的话，将出现不一致的现象。Volatile 关键字可以用来提醒编译器它后面所定义的变量随时有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。 如果一个变量可能在任何时候被外部资源修改，而编译器可能无法察觉，那么可以将其声明为 &lt;a href=&quot;https://zh.wikipedia.org/wiki/Volatile变量&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;volatile 变量&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;由于内存屏障和 volatile 变量都降低了编译器对代码的优化，除非万不得已，需慎用。&lt;/p&gt;
&lt;h4 id=&quot;锁&quot;&gt;&lt;a href=&quot;#锁&quot; class=&quot;headerlink&quot; title=&quot;锁&quot;&gt;&lt;/a&gt;锁&lt;/h4&gt;&lt;p&gt;锁是最常用的同步工具之一，可以用它保护代码中的临界区域（critical section）。临界区域中的代码只允许同时被一个线程访问。其他线程对这块代码的修改都会被拒绝，因为会影响其正确性。&lt;/p&gt;
&lt;p&gt;下表列出了程序员最常用的一些锁。macOS 和 iOS 提供了大部分锁的实现，那些没实现的锁也会有说明。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;锁&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Mutex&lt;/td&gt;
&lt;td&gt;互斥锁（Mutual exclusion，缩写Mutex）是多线程编程中一种对资源的保护机制，避免多个线程同时访问。如果互斥锁正在使用，其他线程需要等到它被释放后才能获取到。在同一时间只能有一个线程使用互斥锁。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Recursive lock&lt;/td&gt;
&lt;td&gt;也叫重入锁或递归锁，是互斥锁的变种。重入锁允许同一条线程多次获得同一个锁，但也释放锁时也要释放对应的次数。重入锁主要用于递归程序或者多个方法都需要获得锁的场景。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Read-write lock&lt;/td&gt;
&lt;td&gt;读写锁可以认为是一种共享版的互斥锁。如果对一个临界区大部分是读操作而只有少量的写操作，在大规模操作上应用读写锁可以显著降低线程互斥产生的代价。正常操作数据时，可以同时有多个读操作。线程想要做写操作时，需要等到所有的读操作完成并释放锁之后，然后写操作会获取锁并更新数据。在写操作线程阻塞等待锁被释放时，新来的读操作线程在写操作完成前会一直阻塞。系统只支持 POSIX 线程中使用读写锁。关于如何使用这些锁，详见 &lt;code&gt;pthread&lt;/code&gt; man page。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Distributed lock&lt;/td&gt;
&lt;td&gt;提供进程级别的互斥锁，但并不会真的阻塞进程，只是简单地向进程汇报锁正被占用，并让进程自己决定如何处理。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Spin lock&lt;/td&gt;
&lt;td&gt;自旋锁会重复查询锁的条件，直到为 true。因为自旋锁属于在『死等』，它最常用在多核处理器系统上，且锁的等待时间很短，时间短到轮询比阻塞线程的开销还小（因为需要阻塞线程切换上下文和更新线程数据结构）。因为它的轮询性质，系统没有提供自旋锁的任何实现，在特定场景下可以自己实现。内核中实现自旋锁详见 &lt;a href=&quot;https://developer.apple.com/library/content/documentation/Darwin/Conceptual/KernelProgramming/About/About.html#//apple_ref/doc/uid/TP30000905&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Kernel Programming Guide&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Double-checked lock&lt;/td&gt;
&lt;td&gt;双重检查锁试图减少并发系统中竞争和同步的开销。由于双重检查锁潜在地不安全性，系统不提供直接支持，不鼓励使用。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;注意：大部分的锁也会纳入内存屏障来确保进入临界区域前的加载和存储指令已经完成。&lt;/p&gt;
&lt;h4 id=&quot;条件变量&quot;&gt;&lt;a href=&quot;#条件变量&quot; class=&quot;headerlink&quot; title=&quot;条件变量&quot;&gt;&lt;/a&gt;条件变量&lt;/h4&gt;&lt;p&gt;Condition 是信号量的另一种类型，它允许线程在某个条件为 true 的时候，向其他线程发信号（signal）。通常用于标示资源的可用性或确保任务以特定的顺序执行。在进入临界区域时如果检查条件变量不为 true，线程会一直阻塞，直到某个其他线程 signal。与互斥锁的不同点在于 condition 允许被多个线程同时访问，它更像是个用某个特定标准筛查线程的门卫。&lt;/p&gt;
&lt;p&gt;一种使用场景是管理即将发生的事件池。当队列中有事件到来时，使用条件变量对发信号（signal）。于是一个被唤醒的线程就可以从队列中获取并处理事件。如果有两个事件大致同时到达队列，会对 condition 发两次信号唤醒两个线程。&lt;/p&gt;
&lt;p&gt;系统用几种不同的技术对 condition 提供支持。写这块代码需要谨慎，后面会给出示例。&lt;/p&gt;
&lt;h4 id=&quot;Perform-Selector&quot;&gt;&lt;a href=&quot;#Perform-Selector&quot; class=&quot;headerlink&quot; title=&quot;Perform Selector&quot;&gt;&lt;/a&gt;Perform Selector&lt;/h4&gt;&lt;p&gt;Cocoa 提供了向一个活跃线程异步分发消息的便捷方式，也就是 &lt;code&gt;NSObject&lt;/code&gt; 类的 &lt;code&gt;performSelector...&lt;/code&gt; 系列方法。使用这些方法向线程发送的执行 &lt;code&gt;selector&lt;/code&gt; 的请求会被目标线程的 run loop 按接收顺序执行。&lt;/p&gt;
&lt;p&gt;详见 &lt;a href=&quot;http://yulingtianxia.com/blog/2017/09/17/Threading-Programming-Guide-2/#Cocoa-Perform-Selector-Sources&quot;&gt;Cocoa Perform Selector Sources&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;同步开销与性能&quot;&gt;&lt;a href=&quot;#同步开销与性能&quot; class=&quot;headerlink&quot; title=&quot;同步开销与性能&quot;&gt;&lt;/a&gt;同步开销与性能&lt;/h3&gt;&lt;p&gt;同步机制在帮助确保代码正确性的同时也造成了性能代价。即便没有竞争，使用同步工具也会引发延迟。锁和原子操作为了确保充分保护代码，通常会需要使用内存屏障和内核级同步。如果存在对锁的竞争，线程会阻塞，经历甚至更久的延迟。&lt;/p&gt;
&lt;p&gt;下表列出了非竞争场景下互斥锁和原子操作的一些大致开销。这些测量值取自几千个样本的均值。时间开销会随着处理器负荷、计算机速度以及系统程序的可用内存数量产生巨幅波动。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;项目&lt;/th&gt;
&lt;th&gt;大约的开销&lt;/th&gt;
&lt;th&gt;注释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Mutex acquisition time&lt;/td&gt;
&lt;td&gt;大约 0.2 ms&lt;/td&gt;
&lt;td&gt;无竞争场景下获取锁的时间。如果锁已经被其他线程持有，获取锁的耗时还会更长。结果取自对均值和中位数的分析，运行系统为 macOS 10.5，配备基于Intel 2 GHz Core Duo 处理器和 1 GB RAM 的 iMac。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Atomic compare-and-swap&lt;/td&gt;
&lt;td&gt;大约 0.05 ms&lt;/td&gt;
&lt;td&gt;无竞争场景下的 compare-and-swap 时间。运行环境同上。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;设计并发任务的时候，最重要的因素永远是正确性，但是也应该考虑到性能因素。总不能一味追求正确性而导致多线程执行的代码比单线程还慢吧。&lt;/p&gt;
&lt;p&gt;如果是在单线程应用的基础上进行多线程的改装，应该分别测量下关键任务在单线程和多线程下执行的性能，比对结果后再决定是否使用多线程。&lt;/p&gt;
&lt;p&gt;关于性能和指标采集工具详见 &lt;a href=&quot;https://developer.apple.com/library/content/documentation/Performance/Conceptual/PerformanceOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40001410&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Performance Overview&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;线程安全和信号&quot;&gt;&lt;a href=&quot;#线程安全和信号&quot; class=&quot;headerlink&quot; title=&quot;线程安全和信号&quot;&gt;&lt;/a&gt;线程安全和信号&lt;/h3&gt;&lt;p&gt;信号(Signal) 是一种底层 BSD 机制，用于向进程传递信息或以某种方式操作进程。有些程序使用信号来监测某些事件，比如子进程终止。系统使用信号来终止失控的进程和传达其他类型的信息。&lt;/p&gt;
&lt;p&gt;在多线程应用中，信号可能被发送到任何线程。所以实现 signal handler 的首要原则就是不要假定handler 会运行在某个特定线程。也就是说，假如在 A 线程设置 signal handler，信号被发送到 B 线程，A 和 B 不一定相同。&lt;/p&gt;
&lt;p&gt;设置 signal handler 的细节可以查看 &lt;code&gt;signal&lt;/code&gt; 和 &lt;code&gt;sigaction&lt;/code&gt; man page。&lt;/p&gt;
&lt;h3 id=&quot;线程安全设计技巧&quot;&gt;&lt;a href=&quot;#线程安全设计技巧&quot; class=&quot;headerlink&quot; title=&quot;线程安全设计技巧&quot;&gt;&lt;/a&gt;线程安全设计技巧&lt;/h3&gt;&lt;p&gt;同步工具是把双刃剑，能让代码线程安全，但使用过多也会带来性能问题。能平衡好二者利弊靠的是经验，下面会提供一些技巧。&lt;/p&gt;
&lt;h4 id=&quot;完全避免同步&quot;&gt;&lt;a href=&quot;#完全避免同步&quot; class=&quot;headerlink&quot; title=&quot;完全避免同步&quot;&gt;&lt;/a&gt;完全避免同步&lt;/h4&gt;&lt;p&gt;最佳解决方案是从代码和数据结构设计上避免需要同步。同步工具很管用但也影响性能，能从设计根源上避免当然是最好的了。比如实现并发的时候要减少任务之间的相互作用和依赖。如果每个任务都在自己的私有数据集上操作，就不需要使用锁保护数据了。即便在两个任务共享一分公共数据集的情况下，可以考虑分割数据集或为每个任务提供一份数据拷贝。当然拷贝数据集也会有成本，这就需要提前权衡下拷贝成本高还是同步成本高。&lt;/p&gt;
&lt;h4 id=&quot;理解同步的限制&quot;&gt;&lt;a href=&quot;#理解同步的限制&quot; class=&quot;headerlink&quot; title=&quot;理解同步的限制&quot;&gt;&lt;/a&gt;理解同步的限制&lt;/h4&gt;&lt;p&gt;同步工具只有在应用中所有线程都持续使用才能生效。如果创建了互斥锁来限制对某个资源的存取，那么所有线程在试图操作此资源前都必须获得这个的互斥锁。如果做不到这些，互斥锁提供的保护就会失效，这是程序员的错。&lt;/p&gt;
&lt;h4 id=&quot;清楚代码正确性的风险&quot;&gt;&lt;a href=&quot;#清楚代码正确性的风险&quot; class=&quot;headerlink&quot; title=&quot;清楚代码正确性的风险&quot;&gt;&lt;/a&gt;清楚代码正确性的风险&lt;/h4&gt;&lt;p&gt;使用锁和内存屏障时需要认真些，要在代码中加对地方才行。你甚至觉得自己加锁的地方是对的，其实只是错觉。下面一系列例子试图阐述这个问题。表面上看似没毛病的代码，也能挑出瑕疵。基础假设是有一个可变数组，包含了一组不可变的对象。如果想要执行数组中第一个对象的方法，可以用下面代码实现：&lt;/p&gt;
&lt;figure class=&quot;highlight dns&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSLock* arrayLock = GetArrayLock()&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSMutableArray* myArray = GetSharedArray()&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;id anObject&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[arrayLock lock]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;anObject = [myArray objectAtIndex:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[arrayLock unlock]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[anObject doSomething]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;因为数组是可变的，在获取数组第一个元素之前，锁会阻止其他线程修改数组。又因为元素对象本身是不可变的，不用对 &lt;code&gt;doSomething&lt;/code&gt; 方法加锁。&lt;/p&gt;
&lt;p&gt;不过上面的例子存在问题：在锁释放后 &lt;code&gt;doSomething&lt;/code&gt; 执行前，如果另一个线程将数组中所有对象都移除会发生什么呢？&lt;code&gt;anObject&lt;/code&gt; 野指针！解决问题的办法也很简单，重新整理下代码顺序，在 &lt;code&gt;doSomething&lt;/code&gt; 执行后再释放锁：&lt;/p&gt;
&lt;figure class=&quot;highlight dns&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSLock* arrayLock = GetArrayLock()&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSMutableArray* myArray = GetSharedArray()&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;id anObject&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[arrayLock lock]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;anObject = [myArray objectAtIndex:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[anObject doSomething]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[arrayLock unlock]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;把调用 &lt;code&gt;doSomething&lt;/code&gt; 的代码挪到锁里面保证了对象依然有效，但如果 &lt;code&gt;doSomething&lt;/code&gt; 执行时间过长又会导致锁也会被占用很久，造成性能瓶颈。&lt;/p&gt;
&lt;p&gt;代码的毛病不是临界区域不清晰，真正的问题在于其他线程插了一脚触发的内存管理问题。因为其他线程释放了 &lt;code&gt;anObject&lt;/code&gt;，更好的解决方案是在锁释放前 &lt;code&gt;retain&lt;/code&gt; 它。此解决方案不仅对症下药，而且无潜在的性能问题。&lt;/p&gt;
&lt;figure class=&quot;highlight dns&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSLock* arrayLock = GetArrayLock()&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSMutableArray* myArray = GetSharedArray()&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;id anObject&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[arrayLock lock]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;anObject = [myArray objectAtIndex:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[anObject retain]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[arrayLock unlock]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[anObject doSomething]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[anObject release]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;尽管上面的例子非常简单，但抓到重点了。要透过表面看本质。要预先考虑到一些问题，比如内存管理和其他方面的设计可能会受多线程的影响。除此之外，在安全问题上要对编辑器的行为做最坏的打算。小心谨慎方能避灾。&lt;/p&gt;
&lt;h4 id=&quot;提防死锁和活锁&quot;&gt;&lt;a href=&quot;#提防死锁和活锁&quot; class=&quot;headerlink&quot; title=&quot;提防死锁和活锁&quot;&gt;&lt;/a&gt;提防死锁和活锁&lt;/h4&gt;&lt;p&gt;如果线程在同一时刻持有不止一个锁，随时都有发生死锁的可能。当两个不同的线程分别持有一个锁，并且尝试获取对方持有的锁，&lt;a href=&quot;https://zh.wikipedia.org/wiki/死锁&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;死锁&lt;/a&gt;就发生了。因为每个线程永远都获取不到另一个锁，结果就是永久阻塞。&lt;/p&gt;
&lt;p&gt;活锁跟死锁很像，死锁是获取不到另一个锁就死等，而活锁是获取不到就释放已经持有的锁和资源，然后重试。活锁把时间都花在释放锁和尝试获取其他锁上面了，并没啥干活儿。&lt;/p&gt;
&lt;p&gt;避免死锁和活锁的最好方法就是一次只获取一个锁。如果一次必须获取不止一个锁，那就应该确保其他线程别这么做。&lt;/p&gt;
&lt;h4 id=&quot;正确地使用-Volatile-变量&quot;&gt;&lt;a href=&quot;#正确地使用-Volatile-变量&quot; class=&quot;headerlink&quot; title=&quot;正确地使用 Volatile 变量&quot;&gt;&lt;/a&gt;正确地使用 &lt;code&gt;Volatile&lt;/code&gt; 变量&lt;/h4&gt;&lt;p&gt;如果已经对一段代码用互斥锁保护了，就不要自动假定需要对这段代码中的重要变量用 &lt;code&gt;volatile&lt;/code&gt; 关键字再保护一次。互斥锁包含了内存屏障，确保加载和存储操作的顺序正确。添加 &lt;code&gt;volatile&lt;/code&gt; 关键字会强制访问变量时每次都从内存加载。可能在特殊情况下有必要将这两种同步技术混合使用，但也会导致严重降低性能。如果只用互斥锁保护变量就够了，删掉 &lt;code&gt;volatile&lt;/code&gt; 关键字吧。&lt;/p&gt;
&lt;p&gt;不要用 &lt;code&gt;volatile&lt;/code&gt; 变量试图替代使用互斥锁。互斥锁和其他同步机制通常比 &lt;code&gt;volatile&lt;/code&gt; 变量能更好地保护数据结构的完整性。&lt;code&gt;volatile&lt;/code&gt; 关键字只是确保变量从内存加载而不是存在寄存器中。它无法确保代码可以正确地访问变量。&lt;/p&gt;
&lt;h3 id=&quot;使用原子操作&quot;&gt;&lt;a href=&quot;#使用原子操作&quot; class=&quot;headerlink&quot; title=&quot;使用原子操作&quot;&gt;&lt;/a&gt;使用原子操作&lt;/h3&gt;&lt;p&gt;无阻塞同步可以执行一些操作并避免锁的开销。虽然用锁可以有效地同步两个线程，但即便在无竞争情况下获取锁的代价相对较高。相反，许多同步操作花一小部分时间就能完成，而且跟锁一样管用。&lt;/p&gt;
&lt;p&gt;可以用原子操作在 32 位或 64 位数值上做些简单的数学和逻辑操作。为了确保在原子操作完成后才可再次访问受影响的内存，这些操作依赖专门的硬件指令（和可选的内存屏障）。在多线程情况下为确保内存被正确地同步，应该始终使用纳入内存屏障版本的原子操作（带有 &lt;code&gt;Barrier&lt;/code&gt; 后缀）。&lt;/p&gt;
&lt;p&gt;下标列出了可用的数学和逻辑原子操作以及相关函数名。这些函数都声明在 &lt;code&gt;/usr/include/libkern/OSAtomic.h&lt;/code&gt; 头文件中，它包含了完整语法。这些函数的 64 位版本仅在 64 位处理器中可用。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;函数名&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Add&lt;/td&gt;
&lt;td&gt;OSAtomicAdd32 OSAtomicAdd32Barrier OSAtomicAdd64 OSAtomicAdd64Barrier&lt;/td&gt;
&lt;td&gt;将两个整数相加并将结果存在其中一个指定的变量中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Increment&lt;/td&gt;
&lt;td&gt;OSAtomicIncrement32 OSAtomicIncrement32Barrier OSAtomicIncrement64 OSAtomicIncrement64Barrier&lt;/td&gt;
&lt;td&gt;将指定的整数值加一&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Decrement&lt;/td&gt;
&lt;td&gt;OSAtomicDecrement32 OSAtomicDecrement32Barrier OSAtomicDecrement64 OSAtomicDecrement64Barrier&lt;/td&gt;
&lt;td&gt;将指定的整数值减一&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Logical OR&lt;/td&gt;
&lt;td&gt;OSAtomicOr32 OSAtomicOr32Barrier&lt;/td&gt;
&lt;td&gt;在指定的 32 位数值和掩码之间做逻辑或&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Logical AND&lt;/td&gt;
&lt;td&gt;OSAtomicAnd32 OSAtomicAnd32Barrier&lt;/td&gt;
&lt;td&gt;在指定的 32 位数值和掩码之间做逻辑与&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Logical XOR&lt;/td&gt;
&lt;td&gt;OSAtomicXor32 OSAtomicXor32Barrier&lt;/td&gt;
&lt;td&gt;在指定的 32 位数值和掩码之间做逻辑异或&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Compare and swap&lt;/td&gt;
&lt;td&gt;OSAtomicCompareAndSwap32 OSAtomicCompareAndSwap32Barrier OSAtomicCompareAndSwap64 OSAtomicCompareAndSwap64Barrier OSAtomicCompareAndSwapPtr OSAtomicCompareAndSwapPtrBarrier OSAtomicCompareAndSwapInt OSAtomicCompareAndSwapIntBarrier OSAtomicCompareAndSwapLong OSAtomicCompareAndSwapLongBarrier&lt;/td&gt;
&lt;td&gt;函数有三个参数：oldValue, newValue, theValue 指针。如果 oldValue 跟 theValue 指针的内容相等，则把 newValue 赋给 theValue 指针的内容。否则啥都不干。比较和赋值会以一个原子操作完成。返回值表明是否发生了交换。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Test and set&lt;/td&gt;
&lt;td&gt;OSAtomicTestAndSet OSAtomicTestAndSetBarrier&lt;/td&gt;
&lt;td&gt;将指定变量第 n 位设为 1，并将旧值以 bool 形式返回。注意这里会将变量按 8 位分块，每块的内容是逆序的。所以如果想要设置 0 位的值，n 需要传入 7。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Test and clear&lt;/td&gt;
&lt;td&gt;OSAtomicTestAndClear OSAtomicTestAndClearBarrier&lt;/td&gt;
&lt;td&gt;将指定变量第 n 位设为 0，并将旧值以 bool 形式返回。注意这里会将变量按 8 位分块，每块的内容是逆序的。所以如果想要设置 0 位的值，n 需要传入 7。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;大多数原子函数的行为都会是相对简单且能预料到的。下面的示例代码使用了 &lt;code&gt;OSAtomicTestAndSet&lt;/code&gt; 和 &lt;code&gt;OSAtomicCompareAndSwap32&lt;/code&gt; 函数，结果可能跟你预想的不太一样。这些函数在无竞争情况下被调用，且没有其他线程同时操作。&lt;/p&gt;
&lt;figure class=&quot;highlight mizar&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int32_t  theValue = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OSAtomicTestAndSet(0, &amp;amp;theValue);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// theValue &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;now&lt;/span&gt; 128.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;theValue = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OSAtomicTestAndSet(7, &amp;amp;theValue);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// theValue &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;now&lt;/span&gt; 1.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;theValue = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OSAtomicTestAndSet(15, &amp;amp;theValue)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// theValue &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;now&lt;/span&gt; 256.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OSAtomicCompareAndSwap32(256, 512, &amp;amp;theValue);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// theValue &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;now&lt;/span&gt; 512.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OSAtomicCompareAndSwap32(256, 1024, &amp;amp;theValue);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// theValue &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; still 512.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;关于原子操作可以看看 &lt;code&gt;atomic&lt;/code&gt; man page 和 &lt;code&gt;/usr/include/libkern/OSAtomic.h&lt;/code&gt; 头文件。&lt;/p&gt;
&lt;h3 id=&quot;使用锁&quot;&gt;&lt;a href=&quot;#使用锁&quot; class=&quot;headerlink&quot; title=&quot;使用锁&quot;&gt;&lt;/a&gt;使用锁&lt;/h3&gt;&lt;p&gt;锁是多线程编程中的一个基础同步工具，macOS 和 iOS 都提供了基础的互斥锁。Foundation 框架定义了几种用于特别场景的互斥锁作为补充。&lt;/p&gt;
&lt;h4 id=&quot;POSIX-互斥锁&quot;&gt;&lt;a href=&quot;#POSIX-互斥锁&quot; class=&quot;headerlink&quot; title=&quot;POSIX 互斥锁&quot;&gt;&lt;/a&gt;POSIX 互斥锁&lt;/h4&gt;&lt;p&gt;POSIX 互斥锁贼好用。用 &lt;code&gt;pthread_mutex_t&lt;/code&gt; 结构体声明一个互斥锁变量，将其传入 &lt;code&gt;pthread_mutex_init&lt;/code&gt; 函数初始化，然后用 &lt;code&gt;pthread_mutex_lock&lt;/code&gt; 和 &lt;code&gt;pthread_mutex_unlock&lt;/code&gt; 函数获取和释放锁就行了。等到不需要用锁了，调用 &lt;code&gt;pthread_mutex_destroy&lt;/code&gt; 函数析构锁的数据结构。下面是简化后的代码，实际使用时要考虑到错误处理等细节：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;pthread_mutex_t&lt;/span&gt; mutex;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyInitFunction&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_mutex_init(&amp;amp;mutex, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyLockingFunction&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_mutex_lock(&amp;amp;mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Do work.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_mutex_unlock(&amp;amp;mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;NSLock&quot;&gt;&lt;a href=&quot;#NSLock&quot; class=&quot;headerlink&quot; title=&quot;NSLock&quot;&gt;&lt;/a&gt;&lt;code&gt;NSLock&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;&lt;code&gt;NSLock&lt;/code&gt; 实现了 Cocoa 中基本的互斥锁。包括 &lt;code&gt;NSLock&lt;/code&gt; 的所有锁的接口实际上都由 &lt;code&gt;NSLocking&lt;/code&gt; 协议定义，也就是 &lt;code&gt;lock&lt;/code&gt; 和 &lt;code&gt;unlock&lt;/code&gt; 这俩方法，对应功能是获取和释放锁。&lt;/p&gt;
&lt;p&gt;除此之外，&lt;code&gt;NSLock&lt;/code&gt; 类还提供了 &lt;code&gt;tryLock&lt;/code&gt; 和 &lt;code&gt;lockBeforeDate:&lt;/code&gt; 方法。&lt;code&gt;tryLock&lt;/code&gt; 方法尝试获取锁，但如果锁不可用，并不会阻塞，只是返回 &lt;code&gt;NO&lt;/code&gt; 而已。&lt;code&gt;lockBeforeDate:&lt;/code&gt; 方法尝试获取锁，并一直阻塞线程，直到获取到锁（返回 &lt;code&gt;YES&lt;/code&gt;）或达到限定的时间（返回 &lt;code&gt;NO&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;下面的示例代码展示了如何使用 &lt;code&gt;NSLock&lt;/code&gt; 在多个线程计算要被显示的数据时，即便获取不到锁的情况下依然可以继续运算。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; moreToDo = &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSLock&lt;/span&gt; *theLock = [[&lt;span class=&quot;built_in&quot;&gt;NSLock&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (moreToDo) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* Do another increment of calculation */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* until there’s no more to do. */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([theLock tryLock]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* Update display used by all threads. */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [theLock unlock];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;synchronized&quot;&gt;&lt;a href=&quot;#synchronized&quot; class=&quot;headerlink&quot; title=&quot;@synchronized&quot;&gt;&lt;/a&gt;&lt;code&gt;@synchronized&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;可以用 &lt;code&gt;@synchronized&lt;/code&gt; 指令很方便地在 Objective-C 代码中飞快地写个互斥锁。它的作用跟互斥锁一样，但不用创建锁，只需要把一个 Objective-C 对象当做锁的 token 即可：&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;-&lt;/span&gt; (void)&lt;span class=&quot;selector-tag&quot;&gt;myMethod&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:(id)anObj&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;variable&quot;&gt;@synchronized&lt;/span&gt;(anObj)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Everything between the braces is protected by the @synchronized directive.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;传给 &lt;code&gt;@synchronized&lt;/code&gt; 的对象是区分被保护的代码块的唯一标识。如果两个线程都执行上面的 &lt;code&gt;myMethod:&lt;/code&gt; 方法，传入的对象如果不同，则不会有阻塞；传入的对象相同，则一个线程先获取锁，另一个线程在临界区域执行完成之前会一直阻塞。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;@synchronized&lt;/code&gt; 的前提是工程开启了 Objective-C exception handling 选项。因为 &lt;code&gt;@synchronized&lt;/code&gt; 的 block 为了保护代码，预防措施是隐式加入 exception handler。handler 在异常抛出时会自动释放互斥锁。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/&quot;&gt;关于 @synchronized，这儿比你想知道的还要多&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;使用其他-Cocoa-框架的锁&quot;&gt;&lt;a href=&quot;#使用其他-Cocoa-框架的锁&quot; class=&quot;headerlink&quot; title=&quot;使用其他 Cocoa 框架的锁&quot;&gt;&lt;/a&gt;使用其他 Cocoa 框架的锁&lt;/h4&gt;&lt;h5 id=&quot;NSRecursiveLock&quot;&gt;&lt;a href=&quot;#NSRecursiveLock&quot; class=&quot;headerlink&quot; title=&quot;NSRecursiveLock&quot;&gt;&lt;/a&gt;&lt;code&gt;NSRecursiveLock&lt;/code&gt;&lt;/h5&gt;&lt;p&gt;&lt;code&gt;NSRecursiveLock&lt;/code&gt; 类也就是递归锁，可以被同一线程获取多次而不会导致死锁。当然 &lt;code&gt;lock&lt;/code&gt; 多少次，也要相应地 &lt;code&gt;unlock&lt;/code&gt; 多少次，这样锁才会被真正释放，其他线程才能获取锁。&lt;/p&gt;
&lt;p&gt;递归锁通常用于递归函数中来避免死锁线程。也可以用于非递归的场景下。这有个使用 &lt;code&gt;NSRecursiveLock&lt;/code&gt; 的例子：&lt;/p&gt;
&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSRecursiveLock *theLock = [[NSRecursiveLock alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyRecursiveFunction&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [theLock &lt;span class=&quot;keyword&quot;&gt;lock&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt; != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        --&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        MyRecursiveFunction(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [theLock unlock];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MyRecursiveFunction(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意：因为递归锁需要 &lt;code&gt;lock&lt;/code&gt; 和 &lt;code&gt;unlock&lt;/code&gt; 次数相等才能释放，应该小心权衡。可以重写代码来避免递归，或避免使用递归锁，这样可以获取更好的性能。&lt;/p&gt;
&lt;h5 id=&quot;NSConditionLock&quot;&gt;&lt;a href=&quot;#NSConditionLock&quot; class=&quot;headerlink&quot; title=&quot;NSConditionLock&quot;&gt;&lt;/a&gt;&lt;code&gt;NSConditionLock&lt;/code&gt;&lt;/h5&gt;&lt;p&gt;&lt;code&gt;NSConditionLock&lt;/code&gt; 定义了可以用特定值来 &lt;code&gt;lock&lt;/code&gt; 和 &lt;code&gt;unlock&lt;/code&gt; 的互斥锁，但别跟条件变量搞混了。虽然行为差不多但实现很不一样。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NSConditionLock&lt;/code&gt; 一般用于线程需要以特定的顺序执行任务时，例如生产者消费者问题。当生产者执行时，消费者需要使用程序中特定的条件变量来获取锁。所谓的条件变量其实就是个程序员定义的整型数。当生产者完成后，它会 &lt;code&gt;unlock&lt;/code&gt; 并更新条件变量，进而唤醒了消费者线程。消费者线程继续处理数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NSConditionLock&lt;/code&gt; 的加锁和解锁方法可以任意组合使用。比如可以用 &lt;code&gt;lock&lt;/code&gt; 跟 &lt;code&gt;unlockWithCondition:&lt;/code&gt; 搭配，或用 &lt;code&gt;lockWhenCondition:&lt;/code&gt; 跟 &lt;code&gt;unlock&lt;/code&gt; 搭配。当然第二种搭配没有在解锁后设置 &lt;code&gt;condition&lt;/code&gt; 属性的值，其他一些等待特定条件变量的线程可能还会阻塞。&lt;/p&gt;
&lt;p&gt;下面的例子展示了如何使用条件锁处理生产者-消费者问题。摄像应用含有一个数据队列，生产者线程向队列添加数据，消费者线程从队列取数据。生产者不需要等特定的条件，但是必须等锁可用的时候才能安全地向队列添加数据。&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;id condLock = [[NSConditionLock alloc] &lt;span class=&quot;string&quot;&gt;initWithCondition:&lt;/span&gt;NO_DATA];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [condLock lock];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* Add data to the queue. */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [condLock &lt;span class=&quot;string&quot;&gt;unlockWithCondition:&lt;/span&gt;HAS_DATA];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由于锁的初始条件被设置成 &lt;code&gt;NO_DATA&lt;/code&gt;，生产者线程起初会顺利地获取锁。它向队列填充数据并将条件设置为 &lt;code&gt;HAS_DATA&lt;/code&gt;。在接下来的迭代中，不管队列是否为空，生产者线程总能添加新数据。它只有消费者线程从队列中获取数据的时候才会阻塞。&lt;/p&gt;
&lt;p&gt;由于消费者线程必须有数据去处理，它会用一个特定的条件等待着队列。当生产者网队列中放数据时，消费者线程会活跃起来并获取锁。然后它可能从队列获取一些数据并更新队列状态。下面的例子展示了消费者线程循环程序的基本结构。&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;while&lt;/span&gt; (true)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;selector-attr&quot;&gt;[condLock lockWhenCondition:HAS_DATA]&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* Remove data from the queue. */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;selector-attr&quot;&gt;[condLock unlockWithCondition:(isEmpty ? NO_DATA : HAS_DATA)]&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Process the data locally.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h5 id=&quot;NSDistributedLock&quot;&gt;&lt;a href=&quot;#NSDistributedLock&quot; class=&quot;headerlink&quot; title=&quot;NSDistributedLock&quot;&gt;&lt;/a&gt;&lt;code&gt;NSDistributedLock&lt;/code&gt;&lt;/h5&gt;&lt;p&gt;&lt;code&gt;NSDistributedLock&lt;/code&gt; 可以用于多个应用拥有并访问某个共享资源（例如文件）的临界区。它实际上是使用文件系统的文件或目录等实现的互斥锁。所有使用 &lt;code&gt;NSDistributedLock&lt;/code&gt; 对象的应用必须对其可写入。这通常意味着将其放入一个所有运行此应用的计算机都能访问的文件系统。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NSDistributedLock&lt;/code&gt; &lt;strong&gt;不&lt;/strong&gt;像其他锁一样遵从 &lt;code&gt;NSLocking&lt;/code&gt; 协议，没有 &lt;code&gt;lock&lt;/code&gt; 方法。&lt;code&gt;lock&lt;/code&gt; 方法会阻塞进程的执行并需要系统以预定的速率查询锁。与其在代码上强制损耗性能，不如用 &lt;code&gt;NSDistributedLock&lt;/code&gt; 提供的 &lt;code&gt;tryLock&lt;/code&gt; 方法来让程序员决定是否去查询锁。&lt;/p&gt;
&lt;p&gt;由于 &lt;code&gt;NSDistributedLock&lt;/code&gt; 使用文件系统实现，它只有在拥有者显式释放它时才会跟着释放。如果应用 crash 时还持有一个 &lt;code&gt;NSDistributedLock&lt;/code&gt; 对象，其他 client 将不能访问被保护的资源。在这种情况下，可以使用 &lt;code&gt;breakLock&lt;/code&gt; 方法打破已经存在的锁，这样就能获取到它了。通常应该避免打破锁，除非你确信拥有锁的进程挂了，无法释放锁。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NSDistributedLock&lt;/code&gt; 跟其他锁一样，调用 &lt;code&gt;unlock&lt;/code&gt; 方法释放它。&lt;/p&gt;
&lt;h3 id=&quot;使用条件（Condition）&quot;&gt;&lt;a href=&quot;#使用条件（Condition）&quot; class=&quot;headerlink&quot; title=&quot;使用条件（Condition）&quot;&gt;&lt;/a&gt;使用条件（Condition）&lt;/h3&gt;&lt;p&gt;Condition 是一种特殊类型的锁，它可以让操作必须以正确的顺序进行。它跟互斥锁有细微的差别。等待 condition 的线程会保持阻塞，直到 condition 被其他线程显式发信号。&lt;/p&gt;
&lt;p&gt;由于牵扯到操作系统实现的细节，条件锁在即使没被发信号的情况下被允许伪造成功返回。为了避免这种站不住脚的发信号导致的问题，应该总是把断言跟条件锁结合起来使用。断言是一个决定线程是否能安全进行的更具体的方式。在发信号的线程设置断言前，condition 会让你的线程保持睡眠。&lt;/p&gt;
&lt;p&gt;下面展示如何在代码中使用 condition。&lt;/p&gt;
&lt;h4 id=&quot;NSCondition&quot;&gt;&lt;a href=&quot;#NSCondition&quot; class=&quot;headerlink&quot; title=&quot;NSCondition&quot;&gt;&lt;/a&gt;&lt;code&gt;NSCondition&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;&lt;code&gt;NSCondition&lt;/code&gt; 是对 POSIX Condition 语法的封装，而且将锁和 condition 数据结构包含在一个对象里。这使得可以用一个对象既能当做互斥锁 &lt;code&gt;lock&lt;/code&gt;，又能像 Condition 一样继续 &lt;code&gt;wait&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;下面的代码中 &lt;code&gt;cocoaCondition&lt;/code&gt; 变量是一个 &lt;code&gt;NSCondition&lt;/code&gt; 对象，&lt;code&gt;timeToDoWork&lt;/code&gt; 变量是一个整型数，用作断言。其他线程会在向 condition 发信号之前立刻增加 &lt;code&gt;timeToDoWork&lt;/code&gt; 的值。&lt;/p&gt;
&lt;figure class=&quot;highlight scheme&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;name&quot;&gt;cocoaCondition&lt;/span&gt; lock]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;while (&lt;span class=&quot;name&quot;&gt;timeToDoWork&lt;/span&gt; &amp;lt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;name&quot;&gt;cocoaCondition&lt;/span&gt; wait]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;timeToDoWork--&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Do real work here.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;name&quot;&gt;cocoaCondition&lt;/span&gt; unlock]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后就是增加断言的值，并向 condition 发信号。当然这些操作要加锁：&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-attr&quot;&gt;[cocoaCondition lock]&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;timeToDoWork++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-attr&quot;&gt;[cocoaCondition signal]&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-attr&quot;&gt;[cocoaCondition unlock]&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;POSIX-Condition&quot;&gt;&lt;a href=&quot;#POSIX-Condition&quot; class=&quot;headerlink&quot; title=&quot;POSIX Condition&quot;&gt;&lt;/a&gt;POSIX Condition&lt;/h4&gt;&lt;p&gt;POSIX 线程条件锁需要将 condition 数据结构和互斥锁一起使用。尽管两个锁结构是分开的，但是互斥锁在运行时会被紧紧地捆到 condition 结构上。等待发信号的线程应该始终将相同的互斥锁和 condition 结构一起使用。改变配对会导致错误。&lt;/p&gt;
&lt;p&gt;下面的代码展示了 condition 和断言基本的初始化和使用。在初始化 condition 和互斥锁后，线程进入了一个使用 &lt;code&gt;ready_to_go&lt;/code&gt; 变量作为断言的 &lt;code&gt;while&lt;/code&gt; 循环。只有断言设置好并且 condition 接着被发信号后，等待着的线程才会被唤醒，并开始工作。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;pthread_mutex_t&lt;/span&gt; mutex;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;pthread_cond_t&lt;/span&gt; condition;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Boolean     ready_to_go = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyCondInitFunction&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_mutex_init(&amp;amp;mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_cond_init(&amp;amp;condition, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyWaitOnConditionFunction&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Lock the mutex.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_mutex_lock(&amp;amp;mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// If the predicate is already set, then the while loop is bypassed;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// otherwise, the thread sleeps until the predicate is set.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(ready_to_go == &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        pthread_cond_wait(&amp;amp;condition, &amp;amp;mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Do work. (The mutex should stay locked.)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Reset the predicate and release the mutex.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ready_to_go = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_mutex_unlock(&amp;amp;mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;发信号的线程负责设置断言并向条件锁发信号。下面的代码展示了它的实现。为了避免线程之间等待 condition 而发生竞态条件，发信号的操作要在互斥锁里面进行。因为是简化过后的例子，代码中没包含错误处理的代码，只展示基础用法。&lt;/p&gt;
&lt;figure class=&quot;highlight aspectj&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SignalThreadUsingCondition&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// At this point, there should be work for the other thread to do.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_mutex_lock(&amp;amp;mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ready_to_go = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Signal the other thread to begin work.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_cond_signal(&amp;amp;condition);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_mutex_unlock(&amp;amp;mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW1&quot;&gt;Threading Programming Guide&lt;/a&gt; 的学习笔记&amp;amp;翻译，第三部分。关于同步的内容。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2017/08/28/Threading-Programming-Guide-1/&quot;&gt;Threading Programming Guide(1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2017/09/17/Threading-Programming-Guide-2/&quot;&gt;Threading Programming Guide(2)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="http://yulingtianxia.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Threading Programming Guide(2)</title>
    <link href="http://yulingtianxia.com/blog/2017/09/17/Threading-Programming-Guide-2/"/>
    <id>http://yulingtianxia.com/blog/2017/09/17/Threading-Programming-Guide-2/</id>
    <published>2017-09-17T06:07:13.000Z</published>
    <updated>2018-09-15T08:28:13.707Z</updated>
    
    <content type="html">&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Threading Programming Guide&lt;/a&gt; 的学习笔记&amp;amp;翻译，第二部分。关于 Run Loop 的内容。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2017/08/28/Threading-Programming-Guide-1/&quot;&gt;Threading Programming Guide(1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2017/10/08/Threading-Programming-Guide-3/&quot;&gt;Threading Programming Guide(3)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;Run-Loops&quot;&gt;&lt;a href=&quot;#Run-Loops&quot; class=&quot;headerlink&quot; title=&quot;Run Loops&quot;&gt;&lt;/a&gt;Run Loops&lt;/h2&gt;&lt;p&gt;Run Loop 作为线程相关基础设施的一部分，充当着循环处理、调度事件/消息的角色。它使得线程不会执行完单个任务后就立刻结束，而是让线程在没有任务时保持休眠状态，在需要处理消息时被立刻唤醒。&lt;/p&gt;
&lt;p&gt;Run Loop 其实是个对象，但不需要主动去创建它，而且每个线程都有对应的 run loop 对象。Run Loop 的管理机制并不完全是自动的，有时需要设计好 run loop 的运行时间和事件处理回调。次级线程需要开发者手动去配置并运行它的 run loop，在应用启动过程中主线程的 run loop 已经自动配置并运行了。&lt;/p&gt;
&lt;p&gt;Run Loop 作为苹果提供的 &lt;a href=&quot;https://en.wikipedia.org/wiki/Event_loop&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Event Loop&lt;/a&gt; 机制的实现方案，在 Cocoa 和 Core Foundation 有两个对应的类：&lt;a href=&quot;https://developer.apple.com/documentation/foundation/runloop&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;NSRunLoop&lt;/code&gt;&lt;/a&gt; 和 &lt;a href=&quot;https://developer.apple.com/documentation/corefoundation/cfrunloop&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;CFRunLoop&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Run-Loop-剖析&quot;&gt;&lt;a href=&quot;#Run-Loop-剖析&quot; class=&quot;headerlink&quot; title=&quot;Run Loop 剖析&quot;&gt;&lt;/a&gt;Run Loop 剖析&lt;/h3&gt;&lt;p&gt;Run Loop 可能需要开发者自己写 &lt;code&gt;while&lt;/code&gt; 或 &lt;code&gt;for&lt;/code&gt; 循环，并在里面驱动 run loop 对象运行，每轮运行都会处理接收到事件的回调。&lt;/p&gt;
&lt;p&gt;Run Loop 接收的事件来源 (source) 有两种。Input Source 传送来自其他应用或线程的异步事件/消息；Timer Source 传送的是基于定时器的同步事件，可以定时或重复发送。&lt;/p&gt;
&lt;p&gt;下图展示了 run loop 与多种 source 的概念架构。运行 &lt;code&gt;NSRunLoop&lt;/code&gt; 实例的方式有三种，&lt;code&gt;runUntilDate:&lt;/code&gt; 方法是其中的一种，后面会讲。Input Source 发送的异步事件产生的回调会使 &lt;code&gt;runUntilDate:&lt;/code&gt; 退出；Timer Source 则不会。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/Art/runloop.jpg&quot; alt=&quot;Structure of a run loop and its sources&quot;&gt;&lt;/p&gt;
&lt;p&gt;Run Loop 的一些行为会发通知，开发者可以注册成为 run-loop 观察者 (observer)。&lt;/p&gt;
&lt;p&gt;Input Source, Timer Source, Run Loop Observer 统称为 Mode Item，这里的 Mode 指的是 Run Loop Mode。一个 Run Loop 包含若干个 Mode，每个 Mode 又包含若干个 Item。Item 与 Mode 是多对多的关系，没有 Item 的 Model 会立刻退出。&lt;/p&gt;
&lt;p&gt;下面几节会详细讲述上面提到的这些概念。&lt;/p&gt;
&lt;h4 id=&quot;Run-Loop-Modes&quot;&gt;&lt;a href=&quot;#Run-Loop-Modes&quot; class=&quot;headerlink&quot; title=&quot;Run Loop Modes&quot;&gt;&lt;/a&gt;Run Loop Modes&lt;/h4&gt;&lt;p&gt;Run Loop Mode 包含了需要被监听的 input source 和 timer 集合，以及需要接收通知的 observer 集合。Run loop 的每次运行都会处在某个特定模式下，而且只有这个模式所包含的 item 集合才会参与发送事件(被监听)和接收通知。&lt;/p&gt;
&lt;p&gt;开发者使用 run loop mode 时直接指定名字就行，Cocoa 和 Core Foundation 定义了一些默认和常用的 Mode。Run Loop Mode 对应的类是 &lt;code&gt;CFRunLoopModeRef&lt;/code&gt;，但是并没有作为公有 API 开放出来，但可以通过 Core Foundation 源码了解下:&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopMode&lt;/span&gt; *&lt;span class=&quot;built_in&quot;&gt;CFRunLoopModeRef&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopMode&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFRuntimeBase&lt;/span&gt; _base; &lt;span class=&quot;comment&quot;&gt;// CF 的基石，遍地可见&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_mutex_t _lock; &lt;span class=&quot;comment&quot;&gt;// 确保 CF 中的 Run Loop 线程安全&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFStringRef&lt;/span&gt; _name; &lt;span class=&quot;comment&quot;&gt;// Mode 的名字，比如 kCFRunLoopDefaultMode&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Boolean _stopped; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; _padding[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFMutableSetRef&lt;/span&gt; _sources0; &lt;span class=&quot;comment&quot;&gt;// Input Sources 中的 Custom Input Source 集合&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFMutableSetRef&lt;/span&gt; _sources1; &lt;span class=&quot;comment&quot;&gt;// Input Sources 中的 Port-Based Source 集合&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFMutableArrayRef&lt;/span&gt; _observers; &lt;span class=&quot;comment&quot;&gt;// Run Loop Observers 数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFMutableArrayRef&lt;/span&gt; _timers; &lt;span class=&quot;comment&quot;&gt;// Timer Sources 数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFMutableDictionaryRef&lt;/span&gt; _portToV1SourceMap; &lt;span class=&quot;comment&quot;&gt;// 端口(port)与 sources1 的映射表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __&lt;span class=&quot;built_in&quot;&gt;CFPortSet&lt;/span&gt; _portSet; &lt;span class=&quot;comment&quot;&gt;// 端口集合&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;... 省略后面源码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Core Foundation 中所有实例都以 &lt;code&gt;CFRuntimeBase&lt;/code&gt; 开始，仅限于内部使用。通过它的结构可以看出这里面保存了一些基本信息，比如 isa 指针，retainCount 等。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; __CFRuntimeBase &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uintptr_t&lt;/span&gt; _cfisa;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint8_t&lt;/span&gt; _cfinfo[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;if&lt;/span&gt; __LP64__&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt; _rc;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; CFRuntimeBase;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不同 Mode 直接是靠事件的来源 (Source) 区分的，而不是事件的类型。比方说 Mode 不能只搭配鼠标点击事件或键盘事件，但可以让某个 Mode 监听一些端口、暂停 timer、修改 source 和 observer 等。&lt;/p&gt;
&lt;p&gt;下面的表格列出了一些系统定义的 Mode，大多数情况下会使用 Default Mode。&lt;a href=&quot;http://iphonedevwiki.net/index.php/CFRunLoop&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iphonedevwiki&lt;/a&gt; 列出了 Core Foundation 中更多的 Mode，很多是系统私有的。使用不同的 Mode 可以过滤不同 Source 发出的事件，比如在要求时效性操作的场景下使用自定义 Mode 来阻止低优先级 Source 发送事件。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Mode&lt;/th&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Default&lt;/td&gt;
&lt;td&gt;NSDefaultRunLoopMode (Cocoa), kCFRunLoopDefaultMode (Core Foundation)&lt;/td&gt;
&lt;td&gt;大多数操作下最常用的 Mode，运行 Run Loop 和配置 Source 的首选&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Connection&lt;/td&gt;
&lt;td&gt;NSConnectionReplyMode (Cocoa)&lt;/td&gt;
&lt;td&gt;Cocoa 中结合 NSConnection 使用，用于监听回复(Reply)，极少用到。(已弃用)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Modal&lt;/td&gt;
&lt;td&gt;NSModalPanelRunLoopMode (Cocoa)&lt;/td&gt;
&lt;td&gt;Cocoa 中 modal panel 使用它接收与之相关 Source 的事件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Event tracking&lt;/td&gt;
&lt;td&gt;NSEventTrackingRunLoopMode (Cocoa), UITrackingRunLoopMode (Cocoa Touch)&lt;/td&gt;
&lt;td&gt;Cocoa 用它限定鼠标拖拽事件之类的用户交互轨迹&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Common modes&lt;/td&gt;
&lt;td&gt;NSRunLoopCommonModes (Cocoa), kCFRunLoopCommonModes (Core Foundation)&lt;/td&gt;
&lt;td&gt;可配置的通用模式集合，将某个 Input Source 关联到此 Mode 也会将其关联到集合中所有 Mode。Cocoa 框架中的 Common modes 默认包含 Default, Modal, Event tracking 三种 Mode；CF 框架起初只包含 Default，可以使用 &lt;code&gt;CFRunLoopAddCommonMode&lt;/code&gt;函数向集合中添加自定义 Mode。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&quot;Input-Sources&quot;&gt;&lt;a href=&quot;#Input-Sources&quot; class=&quot;headerlink&quot; title=&quot;Input Sources&quot;&gt;&lt;/a&gt;Input Sources&lt;/h4&gt;&lt;p&gt;Input Sources 有两种实现：基于端口(Port-based)和自定义(Custom)，它们都向线程异步分发事件，而唯一的不同就是被发信号（signal）的方式。基于端口的事件源会自动由内核发信号，自定义事件源需要被其他线程手动发信号。&lt;/p&gt;
&lt;p&gt;Input Source 会被添加到一些 Mode 中，如果某个 input source 不在当前的 Mode 中，那么它生成的事件在 run loop 处于正确的 mode 之前会先被 hold 住。&lt;/p&gt;
&lt;h5 id=&quot;Port-Based-Sources-Source1&quot;&gt;&lt;a href=&quot;#Port-Based-Sources-Source1&quot; class=&quot;headerlink&quot; title=&quot;Port-Based Sources(Source1)&quot;&gt;&lt;/a&gt;Port-Based Sources(Source1)&lt;/h5&gt;&lt;p&gt;Cocoa 和 Core Foundation 使用端口相关的对象和函数提供了对创建基于端口的事件源的内建支持。比如在 Cocoa 中，只需创建一个端口对象并使用 &lt;code&gt;NSPort&lt;/code&gt; 的方法来向 run loop 添加端口。端口对象为你处理好了创建和配置 input source 的事情。&lt;/p&gt;
&lt;p&gt;在 Core Foundation 中需要手动创建端口和 run loop source。涉及到的 API 有 &lt;code&gt;CFMachPortRef&lt;/code&gt;, &lt;code&gt;CFMessagePortRef&lt;/code&gt;, &lt;code&gt;CFSocketRef&lt;/code&gt;。&lt;/p&gt;
&lt;h5 id=&quot;Custom-Input-Sources-Source0&quot;&gt;&lt;a href=&quot;#Custom-Input-Sources-Source0&quot; class=&quot;headerlink&quot; title=&quot;Custom Input Sources(Source0)&quot;&gt;&lt;/a&gt;Custom Input Sources(Source0)&lt;/h5&gt;&lt;p&gt;只能使用 Core Foundation 中的 &lt;code&gt;CFRunLoopSourceRef&lt;/code&gt; 相关函数来创建自定义事件源。在处理到来的事件、从 run loop 移除 source 后都会有函数回调，可以通过实现这些回调函数来配置 source。&lt;/p&gt;
&lt;p&gt;除此之外还需定义事件分发机制。source 有一部分是在单独的线程运行的，负责为 input source 提供数据，并在数据准备好后对 source 发信号。事件分发机制取决于开发者，但别弄得太过复杂。&lt;/p&gt;
&lt;h5 id=&quot;Cocoa-Perform-Selector-Sources&quot;&gt;&lt;a href=&quot;#Cocoa-Perform-Selector-Sources&quot; class=&quot;headerlink&quot; title=&quot;Cocoa Perform Selector Sources&quot;&gt;&lt;/a&gt;Cocoa Perform Selector Sources&lt;/h5&gt;&lt;p&gt;Cocoa 定义了一种在任何线程执行 &lt;code&gt;selector&lt;/code&gt; 的 custom input source。与机遇端口的事件源相同之处是在目标线程依次执行 &lt;code&gt;selector&lt;/code&gt;，缓解了一条线程运行多个方法时可能发生的同步问题；不同之处在于 &lt;code&gt;selector&lt;/code&gt; 执行后会将 source 从 run loop 挪走。&lt;/p&gt;
&lt;p&gt;在任意线程 perform selector 的前置条件是线程必须有一个活跃的 run loop。对于自己创建的线程，&lt;code&gt;selector&lt;/code&gt; 直到启动 run loop 之后才会运行；主线程会自动配置并运行 run loop，然而要在应用的 &lt;code&gt;applicationDidFinishLaunching:&lt;/code&gt; delegate 方法调用后才生效。Run Loop 每次循环会处理队列中所有的 &lt;code&gt;selector&lt;/code&gt;，而不是循环一次处理一个。&lt;/p&gt;
&lt;p&gt;下表中列出了 &lt;code&gt;NSObject&lt;/code&gt; 类提供的在任何线程执行 &lt;code&gt;selector&lt;/code&gt; 的 API。在任何线程下，只要能拿到 Objective-C 对象就能使用下面的 API，包括 POSIX 线程。这些方法并不会为了执行 &lt;code&gt;selector&lt;/code&gt; 真的去创建一个新线程。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;performSelectorOnMainThread:withObject:waitUntilDone:&lt;/code&gt;, &lt;code&gt;performSelectorOnMainThread:withObject:waitUntilDone:modes:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;在应用主线程 run loop 的下次循环执行特定的 &lt;code&gt;selector&lt;/code&gt;，并提供了选项可以在执行 &lt;code&gt;selector&lt;/code&gt; 之前阻塞当前线程。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;performSelector:onThread:withObject:waitUntilDone:&lt;/code&gt;, &lt;code&gt;performSelector:onThread:withObject:waitUntilDone:modes:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;在任意 &lt;code&gt;NSThread&lt;/code&gt; 对象执行 &lt;code&gt;selector&lt;/code&gt;，同上。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;performSelector:withObject:afterDelay:&lt;/code&gt;, &lt;code&gt;performSelector:withObject:afterDelay:inModes:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;在当前线程 run loop 的下次循环延迟一段时间执行 &lt;code&gt;selector&lt;/code&gt;。因为需要等到下次 run loop 循环才会依次执行队列中的 &lt;code&gt;selector&lt;/code&gt;，所以本身就会有一点延时。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cancelPreviousPerformRequestsWithTarget:&lt;/code&gt;, &lt;code&gt;cancelPreviousPerformRequestsWithTarget:selector:object:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;取消 &lt;code&gt;performSelector:withObject:afterDelay:&lt;/code&gt; 或 &lt;code&gt;performSelector:withObject:afterDelay:inModes:&lt;/code&gt; 方法向当前线程发送的消息。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&quot;Timer-Sources&quot;&gt;&lt;a href=&quot;#Timer-Sources&quot; class=&quot;headerlink&quot; title=&quot;Timer Sources&quot;&gt;&lt;/a&gt;Timer Sources&lt;/h4&gt;&lt;p&gt;Timer source 会在未来一个预定时间向线程同步分发事件。线程可以用 Timer 来通知自己做一些事情。比如用户在搜索栏输入一连串字符之后的某个时间自动搜索一次结果。正是因为有了个延时，才让用户有机会在自动搜索发生前尽可能打出想要的搜索字符串。&lt;/p&gt;
&lt;p&gt;Timer 并不是实时的，会有误差。如果一个 timer 不在正在运行的 run loop 监控的 mode 中，需要一直等到 run loop 运行在一个支持这个 timer 的 mode 时，timer 才会触发。如果一个 timer 触发的时候恰巧 run loop 正忙于执行某个 handler 程序，这个 timer 的 handler 程序需要等到下次才会通过 run loop 执行。如果 run loop 根本不在运行，timer 永远都不会触发。&lt;/p&gt;
&lt;p&gt;可以配置 timer 只生成一次或重复多次事件。重复的 timer 每次会根据已经编排的触发时间自动重新编排。如果实际的触发时间太过于延迟，甚至是晚了一个或多个周期，那么也只会触发一次，而非连续多次。之后会重新编排下次触发时间。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NSTimer&lt;/code&gt; 和 &lt;code&gt;CFRunLoopTimerRef&lt;/code&gt; 是 toll-free bridged 的，设置好时间和回调函数后加到正在运行的 run loop 中即可。具体信息可以参考这两个类的 API 文档。&lt;/p&gt;
&lt;h4 id=&quot;Run-Loop-Observers&quot;&gt;&lt;a href=&quot;#Run-Loop-Observers&quot; class=&quot;headerlink&quot; title=&quot;Run Loop Observers&quot;&gt;&lt;/a&gt;Run Loop Observers&lt;/h4&gt;&lt;p&gt;不同于 source 在同步或异步事件发生时触发，observer 会在 run loop 运行期间的某些特殊地方触发。这些 run loop 中『特殊』的地方列举如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进入 run loop&lt;/li&gt;
&lt;li&gt;当 run loop 即将处理一个 timer&lt;/li&gt;
&lt;li&gt;当 run loop 即将处理一个 input source&lt;/li&gt;
&lt;li&gt;当 run loop 即将休眠&lt;/li&gt;
&lt;li&gt;当 run loop 已经被唤醒，但在它处理唤醒它的事件之前&lt;/li&gt;
&lt;li&gt;退出 run loop&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以使用 Core Foundation 的 &lt;code&gt;CFRunLoopObserverRef&lt;/code&gt; 类创建 run loop observer。&lt;code&gt;CFRunLoopObserverRef&lt;/code&gt; 记录了回调函数和关注的事件类型（上面 6 种时间的掩码），它跟 timer 一样可以在创建的时候选择只触发一次或重复触发。&lt;/p&gt;
&lt;h4 id=&quot;Run-Loop-事件顺序&quot;&gt;&lt;a href=&quot;#Run-Loop-事件顺序&quot; class=&quot;headerlink&quot; title=&quot;Run Loop 事件顺序&quot;&gt;&lt;/a&gt;Run Loop 事件顺序&lt;/h4&gt;&lt;p&gt;线程的 run loop 每次运行都会处理待决的事件，并为绑定的所有 observer 生成通知。次序如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通知 observer 已经进入 run loop&lt;/li&gt;
&lt;li&gt;通知 observer 有 timer 将要触发&lt;/li&gt;
&lt;li&gt;通知 observer 有非基于端口的 input source 将要触发&lt;/li&gt;
&lt;li&gt;触发所有已就绪的非基于端口的 input source&lt;/li&gt;
&lt;li&gt;如果一个基于端口的 input source 已就绪并等待触发，立即处理事件，并转至&lt;strong&gt;第 9 步&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;通知 observer 线程即将休眠&lt;/li&gt;
&lt;li&gt;让线程休眠，直到被以下条件唤醒：&lt;ul&gt;
&lt;li&gt;有基于端口的 input source 事件到达&lt;/li&gt;
&lt;li&gt;timer 触发&lt;/li&gt;
&lt;li&gt;run loop 设定的超时时间到了&lt;/li&gt;
&lt;li&gt;run loop 被手动唤醒&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通知 observer 线程刚刚被唤醒&lt;/li&gt;
&lt;li&gt;处理待决事件&lt;ul&gt;
&lt;li&gt;如果用户定义的 timer 触发了，处理 timer 事件并重启 run loop，跳回到&lt;strong&gt;第 2 步&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果 input source 触发了，分发事件&lt;/li&gt;
&lt;li&gt;如果 run loop 被唤醒且没有超时，重启 run loop，跳回到&lt;strong&gt;第 2 步&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通知 observer 已经退出 run loop&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于 timer 和 input source 对 observer 的通知是在事件真正发生前就已经发出，所以这之间会有时间间隔。如果对事件时间的掌控很严格，可以使用休眠和唤醒的通知帮你关联实际事件的时机。&lt;/p&gt;
&lt;p&gt;由于 timer 和其他周期性事件是在运行 run loop 的时候发送的，绕过 loop 会打断这些事件的发送。典型的案例就是在实现鼠标追踪程序中写了个不断从应用请求事件的循环逻辑，按理说应该是让应用正常地分发这些事件，而不是主动抓取。这就导致 timer 被开发者写的循环逻辑阻塞而一直无法触发。&lt;/p&gt;
&lt;p&gt;可以使用 run loop 对象将其手动唤醒，其他事件也可能导致 run loop 被唤醒。比如添加另一个非基于端口的 input source 唤醒 run loop，input source 就能立刻被处理，而不是一直等到其他事件发生。&lt;/p&gt;
&lt;h3 id=&quot;该何时使用-Run-Loop？&quot;&gt;&lt;a href=&quot;#该何时使用-Run-Loop？&quot; class=&quot;headerlink&quot; title=&quot;该何时使用 Run Loop？&quot;&gt;&lt;/a&gt;该何时使用 Run Loop？&lt;/h3&gt;&lt;p&gt;需要手动运行 run loop 的场景只有一个，那就是你创建次级线程的时候。应用主线程的 run loop 是基础设施中至关重要的部分。应用框架会把自动运行主线程 run loop 的程序写好，比如 &lt;code&gt;UIApplication&lt;/code&gt; 或 &lt;code&gt;NSApplication&lt;/code&gt; 中的 &lt;code&gt;run&lt;/code&gt;。如果使用 Xcode 带的模板创建工程，千万不要去调用这些方法。&lt;/p&gt;
&lt;p&gt;对于次级线程是否有必要手动开启 run loop，那要看实际情况了。比如使用线程执行一些预先设定好的运行时间较长的任务，可能就不需要开启 run loop 了。Run Loop 是为『想要与线程更多交互』的场景准备的，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 input source 与其他线程通信&lt;/li&gt;
&lt;li&gt;在线程中使用 timer&lt;/li&gt;
&lt;li&gt;在 Cocoa 应用中使用任何 &lt;code&gt;performSelector...&lt;/code&gt; 系列的方法&lt;/li&gt;
&lt;li&gt;让线程执行周期性任务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果选择使用 run loop，配置和启动是很简单的。可是就所有的线程编程来说，应该计划好在合适的场景下退出次级线程，总比强行退出要好。&lt;/p&gt;
&lt;h3 id=&quot;使用-Run-Loop-对象&quot;&gt;&lt;a href=&quot;#使用-Run-Loop-对象&quot; class=&quot;headerlink&quot; title=&quot;使用 Run Loop 对象&quot;&gt;&lt;/a&gt;使用 Run Loop 对象&lt;/h3&gt;&lt;p&gt;Run Loop 对象提供了向 run loop 中添加 input source、timer 和 run-loop observer 的主要接口，并运行起来。每个线程都关联一个单独的 run loop。在 Cocoa 中，Run Loop 对象是个 &lt;code&gt;NSRunLoop&lt;/code&gt; 类的实例，在 Core Foundation 中是 &lt;code&gt;CFRunLoopRef&lt;/code&gt; 指针。但它们不是 toll-free bridge 的。&lt;/p&gt;
&lt;h4 id=&quot;获取-Run-Loop-对象&quot;&gt;&lt;a href=&quot;#获取-Run-Loop-对象&quot; class=&quot;headerlink&quot; title=&quot;获取 Run Loop 对象&quot;&gt;&lt;/a&gt;获取 Run Loop 对象&lt;/h4&gt;&lt;p&gt;获取当前线程的 run loop 对象有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cocoa 框架 &lt;code&gt;NSRunLoop&lt;/code&gt; 的类方法 &lt;code&gt;currentRunLoop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CFRunLoopGetCurrent&lt;/code&gt; 函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以从 &lt;code&gt;NSRunLoop&lt;/code&gt; 对象的 &lt;code&gt;getCFRunLoop&lt;/code&gt; 方法获取到 &lt;code&gt;CFRunLoopRef&lt;/code&gt;，这样就可以传给 Core Foundation 程序使用了。二者都指向同一个 run loop，所以可以混用。&lt;/p&gt;
&lt;h4 id=&quot;配置-Run-Loop&quot;&gt;&lt;a href=&quot;#配置-Run-Loop&quot; class=&quot;headerlink&quot; title=&quot;配置 Run Loop&quot;&gt;&lt;/a&gt;配置 Run Loop&lt;/h4&gt;&lt;p&gt;在次级线程运行 run loop 之前，必须向其添加至少一个 input source 或 timer，否则 run loop 会因没有可监控的 source 而在运行后立刻退出。&lt;/p&gt;
&lt;p&gt;除了用 source 外，还可以用 run loop observer 观察 run loop 的各种运行阶段。做法是创建一个 &lt;code&gt;CFRunLoopObserverRef&lt;/code&gt; 类型的对象并用 &lt;code&gt;CFRunLoopAddObserver&lt;/code&gt; 函数将其添加到 run loop 中。注意的是只能用 Core Foundation 创建 run loop observer，Cocoa 框架无能为力。&lt;/p&gt;
&lt;p&gt;下面的示例代码在线程入口函数中创建了 run loop observer 并将其添加到 run loop 中。observer 监听了 run loop 所有的活动，并省略了回调函数 &lt;code&gt;myRunLoopObserver&lt;/code&gt; 的实现。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)threadMain&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// The application uses garbage collection, so no autorelease pool is needed.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSRunLoop&lt;/span&gt;* myRunLoop = [&lt;span class=&quot;built_in&quot;&gt;NSRunLoop&lt;/span&gt; currentRunLoop];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Create a run loop observer and attach it to the run loop.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFRunLoopObserverContext&lt;/span&gt;  context = &amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFRunLoopObserverRef&lt;/span&gt;    observer = &lt;span class=&quot;built_in&quot;&gt;CFRunLoopObserverCreate&lt;/span&gt;(k&lt;span class=&quot;built_in&quot;&gt;CFAllocatorDefault&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopAllActivities&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &amp;amp;myRunLoopObserver, &amp;amp;context);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (observer)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt;    cfLoop = [myRunLoop get&lt;span class=&quot;built_in&quot;&gt;CFRunLoop&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;CFRunLoopAddObserver&lt;/span&gt;(cfLoop, observer, k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopDefaultMode&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Create and schedule the timer.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;built_in&quot;&gt;NSTimer&lt;/span&gt; scheduledTimerWithTimeInterval:&lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt; target:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                selector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(doFireTimer:) userInfo:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; repeats:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;    loopCount = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Run the run loop 10 times to let the timer fire.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [myRunLoop runUntilDate:[&lt;span class=&quot;built_in&quot;&gt;NSDate&lt;/span&gt; dateWithTimeIntervalSinceNow:&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        loopCount--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (loopCount);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;为了不让 run loop 刚运行就立刻退出，上面的代码向 run loop 添加了一个 timer。因为 timer 一旦触发就无效了，依然会导致 run loop 退出，所以这里 &lt;code&gt;repeats&lt;/code&gt; 参数传入 &lt;code&gt;YES&lt;/code&gt;。但这样会让 run loop 一直运行很久，并需要周期性触发 timer 来唤醒线程，这实际上是轮询的另一种形式罢了。相比之下，input source 等待事件发生后才唤醒线程，在这之前线程保持休眠。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CFRunLoopObserverContext&lt;/code&gt; 结构体定义如下，查文档可知第二个参数 &lt;code&gt;info&lt;/code&gt; 会在回调函数被调用时当做参数传入，这里传入 &lt;code&gt;self&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFIndex&lt;/span&gt;	version;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *	info;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *(*retain)(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;	(*release)(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFStringRef&lt;/span&gt;	(*copyDescription)(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;built_in&quot;&gt;CFRunLoopObserverContext&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;启动-Run-Loop&quot;&gt;&lt;a href=&quot;#启动-Run-Loop&quot; class=&quot;headerlink&quot; title=&quot;启动 Run Loop&quot;&gt;&lt;/a&gt;启动 Run Loop&lt;/h4&gt;&lt;p&gt;只有在应用的次级线程才需要启动 run loop，而且需要有至少一个 input source 或 timer，否则 run loop 启动后会立刻退出。&lt;/p&gt;
&lt;p&gt;启动 run loop 的几种方式包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无条件：&lt;/li&gt;
&lt;li&gt;设定时间限制&lt;/li&gt;
&lt;li&gt;处于特定模式（Mode）&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方式&lt;/th&gt;
&lt;th&gt;方法名(NSRunLoop)&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;无条件&lt;/td&gt;
&lt;td&gt;run&lt;/td&gt;
&lt;td&gt;最简单但也最不可取的方案。会让线程进入无限循环，对 run loop 很难控制。可以添加和移除 input source 和 timer，但只能通过 kill 的方式停止 run loop。也无法在自定义模式下运行 run loop。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;设定时间限制&lt;/td&gt;
&lt;td&gt;runUntilDate:&lt;/td&gt;
&lt;td&gt;run loop 在收到事件或超时前会一直运行。run loop 结束后可以重启，并处理接下来的事情。比上一种方式更好，提供了时间限制。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;处于特定模式&lt;/td&gt;
&lt;td&gt;runMode:beforeDate:&lt;/td&gt;
&lt;td&gt;相比上一种方式，增加了在特定模式下运行 run loop。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;run&lt;/code&gt; 和 &lt;code&gt;runUntilDate:&lt;/code&gt; 方法会使用 &lt;code&gt;NSDefaultRunLoopMode&lt;/code&gt; 参数不断调用 &lt;code&gt;runMode:beforeDate:&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;下面的代码展示了一个线程入口函数的大纲，主要是 run loop 的基本构成。本质上就是配置好 run loop 并运行后，每轮运行后不断检查是否需要退出线程。使用 Core Foundation 可以检查 run loop 每次运行的结果，并决定是否需要退出线程。当然也可以使用上面 &lt;code&gt;NSRunLoop&lt;/code&gt; 提供的 API，而且无需检查每次运行的返回值。后面会有例子。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)skeletonThreadMain&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Set up an autorelease pool here if not using garbage collection.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; done = &lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Add your sources or timers to the run loop and do any other setup.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Start the run loop but return after each source is handled.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        SInt32    result = &lt;span class=&quot;built_in&quot;&gt;CFRunLoopRunInMode&lt;/span&gt;(k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopDefaultMode&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// If a source explicitly stopped the run loop, or if there are no&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// sources or timers, go ahead and exit.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((result == k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopRunStopped&lt;/span&gt;) || (result == k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopRunFinished&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            done = &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Check for any other exit conditions here and set the&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// done variable as needed.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (!done);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Clean up code here. Be sure to release any allocated autorelease pools.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其实上面这段调用 &lt;code&gt;CFRunLoopRunInMode()&lt;/code&gt; 的逻辑跟 &lt;code&gt;CFRunLoopRun()&lt;/code&gt; 差不多。&lt;/p&gt;
&lt;p&gt;可以递归启动 run loop。也就是说可以在 input source 或 timer 的回调处理函数中调用 &lt;code&gt;CFRunLoopRun&lt;/code&gt;, &lt;code&gt;CFRunLoopRunInMode&lt;/code&gt; 或上面提到的 &lt;code&gt;NSRunLoop&lt;/code&gt; 的三个方法，而且嵌套的 run loop 可以在任意 Mode 下运行。&lt;/p&gt;
&lt;h4 id=&quot;退出-Run-Loop&quot;&gt;&lt;a href=&quot;#退出-Run-Loop&quot; class=&quot;headerlink&quot; title=&quot;退出 Run Loop&quot;&gt;&lt;/a&gt;退出 Run Loop&lt;/h4&gt;&lt;p&gt;在 run loop 已经将事件处理之前有两种退出的方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;给 run loop 配置 timeout 值&lt;/li&gt;
&lt;li&gt;告诉 run loop 停止&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;推荐第一种方法，因为它会让 run loop 完成一切正常的处理，包括在退出前向 observer 发通知。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;CFRunLoopStop&lt;/code&gt; 函数停止 run loop 的结果跟第一种方式差不多，run loop 会把剩下的通知发出去，然后退出。不同点在于可以用这个函数停止以无条件方式（&lt;code&gt;run&lt;/code&gt; 方法）启动的 run loop。要注意的是 &lt;code&gt;CFRunLoopStop&lt;/code&gt; 只会停止对 &lt;code&gt;CFRunLoopRun&lt;/code&gt; 和 &lt;code&gt;CFRunLoopRunInMode&lt;/code&gt; 的调用，对于 Cocoa 框架相当于只停止一次 &lt;code&gt;runMode:beforeDate:&lt;/code&gt; 的调用，而不是退出 run loop。stop 一次运行和 exit 整个 run loop 是不一样的。&lt;/p&gt;
&lt;p&gt;虽然移除 run loop 的 input source 和 timer 也会导致其退出，但这种方法不可靠。因为有些系统程序会向 run loop 中添加 input source，开发者根本不知道有这回事，移除的时候就会漏掉，自然就不会导致 run loop 退出。&lt;/p&gt;
&lt;h4 id=&quot;线程安全和-Run-Loop-对象&quot;&gt;&lt;a href=&quot;#线程安全和-Run-Loop-对象&quot; class=&quot;headerlink&quot; title=&quot;线程安全和 Run Loop 对象&quot;&gt;&lt;/a&gt;线程安全和 Run Loop 对象&lt;/h4&gt;&lt;p&gt;使用 Core Foundation 中的函数操作 run loop 对象一般都是线程安全的，可以在任何线程调用。如果要更改 run loop 的配置，尽可能在 run loop 自己的线程操作。&lt;/p&gt;
&lt;p&gt;Cocoa 中对应的 &lt;code&gt;NSRunLoop&lt;/code&gt; 内部并不是线程安全的，必须在 run loop 所在的线程修改它。向其他线程的 run loop 添加 input source 或 timer 都会导致 crash 或异常行为。&lt;/p&gt;
&lt;h3 id=&quot;配置-Run-Loop-Source&quot;&gt;&lt;a href=&quot;#配置-Run-Loop-Source&quot; class=&quot;headerlink&quot; title=&quot;配置 Run Loop Source&quot;&gt;&lt;/a&gt;配置 Run Loop Source&lt;/h3&gt;&lt;p&gt;主要演示使用 Cocoa 和 Core Foundation 设置各种类型的 source。&lt;/p&gt;
&lt;h4 id=&quot;定义-Custom-Input-Source&quot;&gt;&lt;a href=&quot;#定义-Custom-Input-Source&quot; class=&quot;headerlink&quot; title=&quot;定义 Custom Input Source&quot;&gt;&lt;/a&gt;定义 Custom Input Source&lt;/h4&gt;&lt;p&gt;创建 custom input source 需要阐明如下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;想让 input source 处理的信息&lt;/li&gt;
&lt;li&gt;用于让外部 client 获知如何联系 input source 的 scheduler 程序&lt;/li&gt;
&lt;li&gt;执行任何 client 发出请求的 perform 程序&lt;/li&gt;
&lt;li&gt;作废 input source 的 cancellation 程序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Custom Input Source 的配置是很灵活的，scheduler，perform 和 cancellation 这几个程序的实现才是关键。然而 input source 剩余的大部分行为都发生在这些程序的外部，需要开发者自己定义一个机制，用于向 input source 传递数据和暴漏 input source 给其他线程。&lt;/p&gt;
&lt;p&gt;下图展示了一个配置 custom input source 的例子。主线程维护了对 input source 及其 custom command buffer 和 run loop 的引用。当主线程想要把一个任务切换到 worker 线程的时候，会向 command buffer 发送一条命令。这条命令包含了 worker 线程启动任务所需的任何信息。由于主线程和 worker 线程的 input source 都可以存取 command buffer，所以存取操作需要被同步。一旦命令发出，主线程对 input source 发信号，并唤醒 worker 线程的 run loop。Run Loop 一旦收到了唤醒命令，就会调用 input source 的 handler 程序，handler 会处理 command buffer 中的命令。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/Art/custominputsource.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;下面会解释上图中 custom input source 的实现，并展示需要实现的关键代码。&lt;/p&gt;
&lt;h5 id=&quot;定义-Input-Source&quot;&gt;&lt;a href=&quot;#定义-Input-Source&quot; class=&quot;headerlink&quot; title=&quot;定义 Input Source&quot;&gt;&lt;/a&gt;定义 Input Source&lt;/h5&gt;&lt;p&gt;需要用 Core Foundation 配置 run loop source，并将其加到 run loop 中。因为 handler 都是基于 C 的函数，所以需要将其封装成 Objective-C 的接口。下面的代码封装了两个 Objective-C 类：&lt;code&gt;RunLoopSource&lt;/code&gt; 封装了 &lt;code&gt;CFRunLoopSourceRef&lt;/code&gt;，并管理一个 command buffer，并使用 buffer 接收其他线程的消息。&lt;code&gt;RunLoopContext&lt;/code&gt; 封装了 &lt;code&gt;CFRunLoopRef&lt;/code&gt; 和 &lt;code&gt;RunLoopSource&lt;/code&gt; 指针，用于向应用主线程传递 source 对象和 run loop 引用。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;RunLoopSource&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFRunLoopSourceRef&lt;/span&gt; runLoopSource;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt;* commands;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)init;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)addToCurrentRunLoop;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)invalidate;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Handler method&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)sourceFired;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Client interface for registering commands to process&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)addCommand:(&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;)command withData:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)data;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)fireAllCommandsOnRunLoop:(&lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt;)runloop;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// These are the CFRunLoopSourceRef callback functions.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; RunLoopSourceScheduleRoutine (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info, &lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt; rl, &lt;span class=&quot;built_in&quot;&gt;CFStringRef&lt;/span&gt; mode);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; RunLoopSourcePerformRoutine (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; RunLoopSourceCancelRoutine (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info, &lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt; rl, &lt;span class=&quot;built_in&quot;&gt;CFStringRef&lt;/span&gt; mode);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// RunLoopContext is a container object used during registration of the input source.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;RunLoopContext&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt;        runLoop;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    RunLoopSource*        source;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt; runLoop;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) RunLoopSource* source;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)initWithSource:(RunLoopSource*)src andLoop:(&lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt;)loop;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下面会分别列出 scheduler，handler 和 cancellation 三个 C 语言的回调函数的实现。&lt;/p&gt;
&lt;p&gt;第一个被调用的函数是 scheduler，当你把 source 添加到 run loop 中时就会调用。按照之前的实例，我们的 input source 只有一个 client，也就是主线程。这里 scheduler 做的事情就是用 application delegate 的 &lt;code&gt;registerSource:&lt;/code&gt; 方法将 &lt;code&gt;RunLoopContext&lt;/code&gt; 对象中的信息传递过去，以便之后 application delegate 与 input source 通信时使用。&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void RunLoopSourceScheduleRoutine (&lt;span class=&quot;name&quot;&gt;void&lt;/span&gt; *info, CFRunLoopRef rl, CFStringRef mode)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    RunLoopSource* obj = (&lt;span class=&quot;name&quot;&gt;__bridge&lt;/span&gt; RunLoopSource*)info&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    AppDelegate*   del = [AppDelegate sharedAppDelegate]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    RunLoopContext* theContext = [[RunLoopContext alloc] initWithSource&lt;span class=&quot;symbol&quot;&gt;:obj&lt;/span&gt; andLoop&lt;span class=&quot;symbol&quot;&gt;:rl&lt;/span&gt;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [del performSelectorOnMainThread:@selector(&lt;span class=&quot;name&quot;&gt;registerSource&lt;/span&gt;:)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                withObject&lt;span class=&quot;symbol&quot;&gt;:theContext&lt;/span&gt; waitUntilDone&lt;span class=&quot;symbol&quot;&gt;:NO&lt;/span&gt;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当 input source 被发信号（signal）的时候，用于处理数据的 perform 函数会被调用，它是最重要的回调之一。这里很简单地转发给了 &lt;code&gt;RunLoopSource&lt;/code&gt; 的 &lt;code&gt;sourceFired&lt;/code&gt; 方法。后面会列出 &lt;code&gt;sourceFired&lt;/code&gt; 处理 command buffer 的逻辑。&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void RunLoopSourcePerformRoutine (&lt;span class=&quot;name&quot;&gt;void&lt;/span&gt; *info)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    RunLoopSource*  obj = (&lt;span class=&quot;name&quot;&gt;__bridge&lt;/span&gt; RunLoopSource*)info&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [obj sourceFired]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果用调用 &lt;code&gt;CFRunLoopSourceInvalidate&lt;/code&gt; 函数之类的方式将 input source 从它的 run loop 中移除，系统会调用 input source 的 cancellation 程序。可以在这个程序中告诉 client 可以移除对 input source 的引用了，因为它已经失效了。下面的 cancellation 回调函数将传入的 &lt;code&gt;RunLoopSource&lt;/code&gt; 对象和 &lt;code&gt;CFRunLoopRef&lt;/code&gt; 打包成一个 &lt;code&gt;RunLoopContext&lt;/code&gt;，并传给 application delegate。&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void RunLoopSourceCancelRoutine (&lt;span class=&quot;name&quot;&gt;void&lt;/span&gt; *info, CFRunLoopRef rl, CFStringRef mode)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    RunLoopSource* obj = (&lt;span class=&quot;name&quot;&gt;__bridge&lt;/span&gt; RunLoopSource*)info&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    AppDelegate* del = [AppDelegate sharedAppDelegate]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    RunLoopContext* theContext = [[RunLoopContext alloc] initWithSource&lt;span class=&quot;symbol&quot;&gt;:obj&lt;/span&gt; andLoop&lt;span class=&quot;symbol&quot;&gt;:rl&lt;/span&gt;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [del performSelectorOnMainThread:@selector(&lt;span class=&quot;name&quot;&gt;removeSource&lt;/span&gt;:)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                withObject&lt;span class=&quot;symbol&quot;&gt;:theContext&lt;/span&gt; waitUntilDone&lt;span class=&quot;symbol&quot;&gt;:YES&lt;/span&gt;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面这三个回调函数中 application delegate 的 &lt;code&gt;registerSource:&lt;/code&gt; 和 &lt;code&gt;removeSource:&lt;/code&gt; 方法暂时省略，后面会列出。这三个回调函数会在创建 custom input source 的时候当做参数传入。&lt;/p&gt;
&lt;h5 id=&quot;在-Run-Loop-上装载-Input-Source&quot;&gt;&lt;a href=&quot;#在-Run-Loop-上装载-Input-Source&quot; class=&quot;headerlink&quot; title=&quot;在 Run Loop 上装载 Input Source&quot;&gt;&lt;/a&gt;在 Run Loop 上装载 Input Source&lt;/h5&gt;&lt;p&gt;下面代码是 &lt;code&gt;RunLoopSource&lt;/code&gt; 类的 &lt;code&gt;init&lt;/code&gt; 和 &lt;code&gt;addToCurrentRunLoop&lt;/code&gt; 方法。&lt;code&gt;init&lt;/code&gt; 创建了一个 &lt;code&gt;CFRunLoopSourceRef&lt;/code&gt;，这才是真正被添加到 run loop 中的类型。当 worker 线程调用 &lt;code&gt;addToCurrentRunLoop&lt;/code&gt; 方法时，才会将 input source 装载到 run loop 中，并在此时调用 &lt;code&gt;RunLoopSourceScheduleRoutine&lt;/code&gt; 回调函数。之后就可以启动 run loop 了。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)init&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFRunLoopSourceContext&lt;/span&gt;    context = &amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, (__bridge &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *)(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;), &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                        &amp;amp;RunLoopSourceScheduleRoutine,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                        &amp;amp;RunLoopSourceCancelRoutine,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                        &amp;amp;RunLoopSourcePerformRoutine&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    runLoopSource = &lt;span class=&quot;built_in&quot;&gt;CFRunLoopSourceCreate&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &amp;amp;context);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    commands = [[&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)addToCurrentRunLoop&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt; runLoop = &lt;span class=&quot;built_in&quot;&gt;CFRunLoopGetCurrent&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFRunLoopAddSource&lt;/span&gt;(runLoop, runLoopSource, k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopDefaultMode&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;CFRunLoopSourceContext&lt;/code&gt; 结构体描述了 custom input source（source0）的上下文，而 &lt;code&gt;CFRunLoopSourceContext1&lt;/code&gt; 结构体描述了 port-based input source（source1）的上下文。看文档可知，&lt;code&gt;info&lt;/code&gt; 用于向回调函数传入数据，&lt;code&gt;schedule&lt;/code&gt;，&lt;code&gt;cancel&lt;/code&gt; 和 &lt;code&gt;perform&lt;/code&gt; 分别对应上面代码中传入的三个回调函数。将这些信息打包进上下文后，就可以用 &lt;code&gt;CFRunLoopSourceCreate&lt;/code&gt; 函数创建 run loop 对象了。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFIndex&lt;/span&gt;	version;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *	info;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *(*retain)(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;	(*release)(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFStringRef&lt;/span&gt;	(*copyDescription)(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Boolean	(*equal)(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info1, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFHashCode&lt;/span&gt;	(*hash)(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;	(*schedule)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info, &lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt; rl, &lt;span class=&quot;built_in&quot;&gt;CFRunLoopMode&lt;/span&gt; mode);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;	(*cancel)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info, &lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt; rl, &lt;span class=&quot;built_in&quot;&gt;CFRunLoopMode&lt;/span&gt; mode);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;	(*perform)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;built_in&quot;&gt;CFRunLoopSourceContext&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFIndex&lt;/span&gt;	version;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *	info;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *(*retain)(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;	(*release)(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFStringRef&lt;/span&gt;	(*copyDescription)(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Boolean	(*equal)(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info1, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFHashCode&lt;/span&gt;	(*hash)(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#if (TARGET_OS_MAC &amp;amp;&amp;amp; !(TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)) || (TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mach_port_t	(*getPort)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *	(*perform)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *msg, &lt;span class=&quot;built_in&quot;&gt;CFIndex&lt;/span&gt; size, &lt;span class=&quot;built_in&quot;&gt;CFAllocatorRef&lt;/span&gt; allocator, &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *	(*getPort)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;	(*perform)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#endif&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;built_in&quot;&gt;CFRunLoopSourceContext1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;两种 Context 的结构很相似，所以 &lt;code&gt;CFRunLoopSourceRef&lt;/code&gt; 中使用 &lt;code&gt;union&lt;/code&gt; 存储这两个互斥存在的结构体，内存占用上只差一个指针：&lt;/p&gt;
&lt;figure class=&quot;highlight crystal&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__CFRunLoopSource&lt;/span&gt; * &lt;span class=&quot;title&quot;&gt;CFRunLoopSourceRef&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__CFRunLoopSource&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CFRuntimeBase _base;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    uint32_t _bits;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_mutex_t _lock;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CFIndex _order;			&lt;span class=&quot;regexp&quot;&gt;/* immutable */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CFMutableBagRef _runLoops;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;union&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	CFRunLoopSourceContext version0;	&lt;span class=&quot;regexp&quot;&gt;/* immutable, except invalidation */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CFRunLoopSourceContext1 version1;	&lt;span class=&quot;regexp&quot;&gt;/* immutable, except invalidation */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; _context;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h5 id=&quot;Input-Source-与-Client-的协作&quot;&gt;&lt;a href=&quot;#Input-Source-与-Client-的协作&quot; class=&quot;headerlink&quot; title=&quot;Input Source 与 Client 的协作&quot;&gt;&lt;/a&gt;Input Source 与 Client 的协作&lt;/h5&gt;&lt;p&gt;自定义的 input source 需要由其他线程手动发信号。重点是其线程在这之前会一直处于休眠状态，所以一定要让其他线程知道这个 input source，并能与之通信。&lt;/p&gt;
&lt;p&gt;当 input source 第一次装载到 run loop 的时候，可以向 client 发送注册 input source 的请求。可以将一个 input source 直接或间接注册到多个 client 中。下面的代码展示了 application delegate 提供的注册方法 &lt;code&gt;registerSource:&lt;/code&gt;，之前提到过回调函数 &lt;code&gt;RunLoopSourceScheduleRoutine&lt;/code&gt; 的实现会调用 &lt;code&gt;registerSource:&lt;/code&gt;。也就是说执行流程是 install(&lt;code&gt;addToCurrentRunLoop&lt;/code&gt;) -&amp;gt; schedule(&lt;code&gt;RunLoopSourceScheduleRoutine&lt;/code&gt;) -&amp;gt; register(&lt;code&gt;registerSource:&lt;/code&gt;)。对应地，当 input source 从 run loop 中被移除，回调函数 &lt;code&gt;RunLoopSourceCancelRoutine&lt;/code&gt; 中会调用 &lt;code&gt;removeSource:&lt;/code&gt; 方法。&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;registerSource:&lt;/span&gt;(RunLoopContext*)sourceInfo;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [sourcesToPing &lt;span class=&quot;string&quot;&gt;addObject:&lt;/span&gt;sourceInfo];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;removeSource:&lt;/span&gt;(RunLoopContext*)sourceInfo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    id    objToRemove = nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (RunLoopContext* context &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; sourcesToPing)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([context &lt;span class=&quot;string&quot;&gt;isEqual:&lt;/span&gt;sourceInfo])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            objToRemove = context;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (objToRemove)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [sourcesToPing &lt;span class=&quot;string&quot;&gt;removeObject:&lt;/span&gt;objToRemove];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;代码逻辑很简单，就是 application delegate 维护了一个存储 &lt;code&gt;RunLoopContext&lt;/code&gt; 对象的可变数组 &lt;code&gt;sourcesToPing&lt;/code&gt;，并提供了增加和移除数组元素的两个方法。&lt;/p&gt;
&lt;h5 id=&quot;给-Input-Source-发信号-Signal&quot;&gt;&lt;a href=&quot;#给-Input-Source-发信号-Signal&quot; class=&quot;headerlink&quot; title=&quot;给 Input Source 发信号(Signal)&quot;&gt;&lt;/a&gt;给 Input Source 发信号(Signal)&lt;/h5&gt;&lt;p&gt;Client 在将数据传递给 input source 后，还需要给 source 发信号，并唤醒 run loop。发信号的作用是让 run loop 知道 input source 已经做好被处理的准备了。当信号发出时线程可能还在休眠，所以必须唤醒 run loop。否则可能会导致延迟处理 input source。&lt;/p&gt;
&lt;p&gt;下面代码展示了 &lt;code&gt;RunLoopSource&lt;/code&gt; 对象的 &lt;code&gt;fireCommandsOnRunLoop&lt;/code&gt; 方法。当 Client 准备好让 source 处理 command buffer 中的命令时会调用这个方法。&lt;/p&gt;
&lt;figure class=&quot;highlight erlang&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- &lt;span class=&quot;params&quot;&gt;(void)&lt;/span&gt;fireCommandsOnRunLoop:&lt;span class=&quot;params&quot;&gt;(CFRunLoopRef)&lt;/span&gt;runloop&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CFRunLoopSourceSignal&lt;span class=&quot;params&quot;&gt;(runLoopSource)&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CFRunLoopWakeUp&lt;span class=&quot;params&quot;&gt;(runloop)&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;配置-Timer-Source&quot;&gt;&lt;a href=&quot;#配置-Timer-Source&quot; class=&quot;headerlink&quot; title=&quot;配置 Timer Source&quot;&gt;&lt;/a&gt;配置 Timer Source&lt;/h4&gt;&lt;p&gt;使用不同框架创建 timer 对象的方式略有差别：Cocoa 中使用 &lt;code&gt;NSTimer&lt;/code&gt;，Core Foundation 中使用 &lt;code&gt;CFRunLoopTimerRef&lt;/code&gt; 类型。二者是 toll-free bridged 的，但是 &lt;code&gt;NSTimer&lt;/code&gt; 提供的 API 更便捷。比如可以用下面的方法马上创建并安排（schedule）好一个 timer：&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;scheduledTimerWithTimeInterval:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;target:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;selector:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;userInfo:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;repeats:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;scheduledTimerWithTimeInterval:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;invocation:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;repeats:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面这些方法会创建 timer 并添加到当前线程 run loop 的 Default Mode 中。也可以手动创建一个 &lt;code&gt;NSTimer&lt;/code&gt; 对象并用 &lt;code&gt;NSRunLoop&lt;/code&gt; 的 &lt;code&gt;addTimer:forMode:&lt;/code&gt; 方法将其添加到 run loop 的指定 Mode 中。这些方法做的事情都差不多，只是对 timer 配置的掌控程度不同。下面的代码展示了两种添加 timer 的方式：第一个 timer 延迟 1 秒触发并每隔 0.1 秒重复触发，第二个 timer 延迟 0.2 秒触发然后每隔 0.2 秒重复触发。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSRunLoop&lt;/span&gt;* myRunLoop = [&lt;span class=&quot;built_in&quot;&gt;NSRunLoop&lt;/span&gt; currentRunLoop];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Create and schedule the first timer.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSDate&lt;/span&gt;* futureDate = [&lt;span class=&quot;built_in&quot;&gt;NSDate&lt;/span&gt; dateWithTimeIntervalSinceNow:&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSTimer&lt;/span&gt;* myTimer = [[&lt;span class=&quot;built_in&quot;&gt;NSTimer&lt;/span&gt; alloc] initWithFireDate:futureDate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        interval:&lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        target:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        selector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(myDoFireTimer1:)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        userInfo:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        repeats:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[myRunLoop addTimer:myTimer forMode:&lt;span class=&quot;built_in&quot;&gt;NSDefaultRunLoopMode&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Create and schedule the second timer.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;built_in&quot;&gt;NSTimer&lt;/span&gt; scheduledTimerWithTimeInterval:&lt;span class=&quot;number&quot;&gt;0.2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        target:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        selector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(myDoFireTimer2:)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        userInfo:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        repeats:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下面的代码展示了如何使用 Core Foundation 函数配置 timer。虽然这个例子并没有在 &lt;code&gt;context&lt;/code&gt; 结构体中传递任何用户定义的信息，但你可以用这个结构体传送 timer 所需的一切自定义信息。可以查看文档了解下 &lt;code&gt;CFRunLoopTimerRef&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt; runLoop = &lt;span class=&quot;built_in&quot;&gt;CFRunLoopGetCurrent&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CFRunLoopTimerContext&lt;/span&gt; context = &amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CFRunLoopTimerRef&lt;/span&gt; timer = &lt;span class=&quot;built_in&quot;&gt;CFRunLoopTimerCreate&lt;/span&gt;(k&lt;span class=&quot;built_in&quot;&gt;CFAllocatorDefault&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                        &amp;amp;my&lt;span class=&quot;built_in&quot;&gt;CFTimerCallback&lt;/span&gt;, &amp;amp;context);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CFRunLoopAddTimer&lt;/span&gt;(runLoop, timer, k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopCommonModes&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;配置-Port-Based-Input-Source&quot;&gt;&lt;a href=&quot;#配置-Port-Based-Input-Source&quot; class=&quot;headerlink&quot; title=&quot;配置 Port-Based Input Source&quot;&gt;&lt;/a&gt;配置 Port-Based Input Source&lt;/h4&gt;&lt;p&gt;Cocoa 和 Core Foundation 都提供了用于线程间或进程间通讯的基于端口（port-based）的对象。下面展示了如何用几种不同类型的端口来设置端口通信。&lt;/p&gt;
&lt;h5 id=&quot;配置-NSMachPort-对象&quot;&gt;&lt;a href=&quot;#配置-NSMachPort-对象&quot; class=&quot;headerlink&quot; title=&quot;配置 NSMachPort 对象&quot;&gt;&lt;/a&gt;配置 &lt;code&gt;NSMachPort&lt;/code&gt; 对象&lt;/h5&gt;&lt;p&gt;使用 &lt;code&gt;NSMachPort&lt;/code&gt; 对象建立本地连接过程如下：创建 &lt;code&gt;NSMachPort&lt;/code&gt; 对象并添加到主线程的 run loop 中。当启动次级线程时将这个 &lt;code&gt;NSMachPort&lt;/code&gt; 对象传递给次级线程的入口函数。次级线程会用这个 &lt;code&gt;NSMachPort&lt;/code&gt; 对象往主线程发消息。&lt;/p&gt;
&lt;h6 id=&quot;实现主线程代码&quot;&gt;&lt;a href=&quot;#实现主线程代码&quot; class=&quot;headerlink&quot; title=&quot;实现主线程代码&quot;&gt;&lt;/a&gt;实现主线程代码&lt;/h6&gt;&lt;p&gt;下面的代码展示了启动次级 worker 线程的主要代码。使用 Cocoa 框架写出的代码要比 Core Foundation 的少多了，但效果几乎一样。有个不同点是 Cocoa 直接传递 &lt;code&gt;NSPort&lt;/code&gt; 对象，而 Core Foundation 传递端口名字符串。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)launchThread&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSPort&lt;/span&gt;* myPort = [&lt;span class=&quot;built_in&quot;&gt;NSMachPort&lt;/span&gt; port];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (myPort)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// This class handles incoming port messages.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [myPort setDelegate:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Install the port as an input source on the current run loop.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [[&lt;span class=&quot;built_in&quot;&gt;NSRunLoop&lt;/span&gt; currentRunLoop] addPort:myPort forMode:&lt;span class=&quot;built_in&quot;&gt;NSDefaultRunLoopMode&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Detach the thread. Let the worker release the port.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;built_in&quot;&gt;NSThread&lt;/span&gt; detachNewThreadSelector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(LaunchThreadWithPort:)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               toTarget:[MyWorkerClass class] withObject:myPort];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们想要在次级线程启动一切正常后给主线程通过本地端口通信报个平安，下面的 &lt;code&gt;handlePortMessage:&lt;/code&gt; 方法会在线程自己的本地端口收到数据后被调用。&lt;code&gt;NSPortMessage&lt;/code&gt; 持有两个端口对象：发送端口和接收端口。&lt;code&gt;handlePortMessage:&lt;/code&gt; 方法中使用 &lt;code&gt;[portMessage sendPort]&lt;/code&gt; 获取到了发送端口对象，也就是次级线程拥有的本地端口。也就是次级线程启动后会给主线程发消息，告知自己的端口对象，主线程会将其存下来以备日后使用。&lt;code&gt;msgid&lt;/code&gt; 标记了消息的唯一 ID。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#define kCheckinMessage 100&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Handle responses from the worker thread.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)handlePortMessage:(&lt;span class=&quot;built_in&quot;&gt;NSPortMessage&lt;/span&gt; *)portMessage&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; message = [portMessage msgid];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSPort&lt;/span&gt;* distantPort = &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (message == kCheckinMessage)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Get the worker thread’s communications port.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        distantPort = [portMessage sendPort];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Retain and save the worker port for later use.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; storeDistantPort:distantPort];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Handle other messages.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h6 id=&quot;实现次级线程代码&quot;&gt;&lt;a href=&quot;#实现次级线程代码&quot; class=&quot;headerlink&quot; title=&quot;实现次级线程代码&quot;&gt;&lt;/a&gt;实现次级线程代码&lt;/h6&gt;&lt;p&gt;次级线程的入口函数会被传入主线程的端口对象，配置好次级线程后，使用主线程的端口对象来与主线程通信。下面代码中的 &lt;code&gt;MyWorkerClass&lt;/code&gt; 是个辅助类，它的 &lt;code&gt;sendCheckinMessage:&lt;/code&gt; 方法负责创建次级线程的本地端口，并发消息给主线程。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)LaunchThreadWithPort:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)inData&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSAutoreleasePool&lt;/span&gt;*  pool = [[&lt;span class=&quot;built_in&quot;&gt;NSAutoreleasePool&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Set up the connection between this thread and the main thread.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSPort&lt;/span&gt;* distantPort = (&lt;span class=&quot;built_in&quot;&gt;NSPort&lt;/span&gt;*)inData;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MyWorkerClass*  workerObj = [[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [workerObj sendCheckinMessage:distantPort];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [distantPort release];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Let the run loop process things.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [[&lt;span class=&quot;built_in&quot;&gt;NSRunLoop&lt;/span&gt; currentRunLoop] runMode:&lt;span class=&quot;built_in&quot;&gt;NSDefaultRunLoopMode&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            beforeDate:[&lt;span class=&quot;built_in&quot;&gt;NSDate&lt;/span&gt; distantFuture]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (![workerObj shouldExit]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [workerObj release];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [pool release];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;t&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在线程间的单向通信中，同一个 &lt;code&gt;NSMachPort&lt;/code&gt; 对象既可以其所在线程的本地端口，又可以是其他线程的远程端口。也就是线程创建的本地端口对象对于其他现场来说是远程端口。下面的代码展示了 &lt;code&gt;sendCheckinMessage:&lt;/code&gt; 方法的实现。它创建了次级线程的本地端口，并使用主线程从 &lt;code&gt;LaunchThreadWithPort:&lt;/code&gt; 方法传来的端口对象，构建了 &lt;code&gt;NSPortMessage&lt;/code&gt; 消息对象，设置好 &lt;code&gt;msgid&lt;/code&gt; 后，然后立即发送出去。&lt;/p&gt;
&lt;figure class=&quot;highlight smali&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// Worker thread&lt;span class=&quot;built_in&quot;&gt; check-in &lt;/span&gt;method&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)sendCheckinMessage:(NSPort*)outPort&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Retain&lt;span class=&quot;built_in&quot;&gt; and &lt;/span&gt;save the remote port for future use.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self setRemotePort:outPort];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Create&lt;span class=&quot;built_in&quot;&gt; and &lt;/span&gt;configure the worker thread port.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSPort* myPort = [NSMachPort port];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [myPort setDelegate:self];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [[NSRunLoop currentRunLoop] addPort:myPort forMode:NSDefaultRun&lt;span class=&quot;class&quot;&gt;LoopMode];&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Create the&lt;span class=&quot;built_in&quot;&gt; check-in &lt;/span&gt;message.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSPortMessage* messageObj = [[NSPortMessage alloc] initWithSendPort:outPort&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                         receivePort:myPort components:nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt; if &lt;/span&gt;(messageObj)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // Finish configuring the message&lt;span class=&quot;built_in&quot;&gt; and &lt;/span&gt;send it immediately.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [messageObj setMsgid:kCheckinMessage];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [messageObj sendBeforeDate:[NSDate date]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h5 id=&quot;配置-NSMessagePort-对象&quot;&gt;&lt;a href=&quot;#配置-NSMessagePort-对象&quot; class=&quot;headerlink&quot; title=&quot;配置 NSMessagePort 对象&quot;&gt;&lt;/a&gt;配置 &lt;code&gt;NSMessagePort&lt;/code&gt; 对象&lt;/h5&gt;&lt;p&gt;如果用 &lt;code&gt;NSMessagePort&lt;/code&gt; 对象建立本地连接，不能在线程间简单地传递端口对象，而是必须要拿到端口名称。使用一个字符串作为键在 &lt;code&gt;NSMessagePortNameServer&lt;/code&gt; 注册本地端口，并把这个字符串传给另外的线程，这样就能通过这个字符串获取到端口对象，接着用它通信。下面的代码展示了使用创建和注册 &lt;code&gt;NSMessagePort&lt;/code&gt; 的过程。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSPort&lt;/span&gt;* localPort = [[&lt;span class=&quot;built_in&quot;&gt;NSMessagePort&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Configure the object and add it to the current run loop.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[localPort setDelegate:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[&lt;span class=&quot;built_in&quot;&gt;NSRunLoop&lt;/span&gt; currentRunLoop] addPort:localPort forMode:&lt;span class=&quot;built_in&quot;&gt;NSDefaultRunLoopMode&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Register the port using a specific name. The name must be unique.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt;* localPortName = [&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; stringWithFormat:&lt;span class=&quot;string&quot;&gt;@&quot;MyPortName&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[&lt;span class=&quot;built_in&quot;&gt;NSMessagePortNameServer&lt;/span&gt; sharedInstance] registerPort:localPort&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     name:localPortName];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h5 id=&quot;使用-Core-Foundation-配置基于端口的-Input-Source&quot;&gt;&lt;a href=&quot;#使用-Core-Foundation-配置基于端口的-Input-Source&quot; class=&quot;headerlink&quot; title=&quot;使用 Core Foundation 配置基于端口的 Input Source&quot;&gt;&lt;/a&gt;使用 Core Foundation 配置基于端口的 Input Source&lt;/h5&gt;&lt;p&gt;使用 Core Foundation 在主线程和其他线程之间建立一个双向通讯通道需要写更多的代码。&lt;/p&gt;
&lt;p&gt;首先在主线程中发起一个 worker 线程，然后创建端口用于监听其他线程的消息。跟之前使用 Cocoa 不同在于这里是将一个唯一的端口名传给 worker 线程的入口函数，而不是端口对象。&lt;/p&gt;
&lt;p&gt;官方文档中创建 &lt;code&gt;CFMessagePortRef&lt;/code&gt; 的相关方法在 iOS 7 之后已经失效了，而且使用 Cocoa 提供的 API 更加方便，这里不再贴出 Core Foundation 版本的示例代码。&lt;/p&gt;
&lt;p&gt;所以不推荐使用 Core Foundation 建立线程端口通讯，但是 macOS 上建立进程间通讯还是可以尝试的。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1&quot;&gt;Threading Programming Guide&lt;/a&gt; 的学习笔记&amp;amp;翻译，第二部分。关于 Run Loop 的内容。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2017/08/28/Threading-Programming-Guide-1/&quot;&gt;Threading Programming Guide(1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2017/10/08/Threading-Programming-Guide-3/&quot;&gt;Threading Programming Guide(3)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="http://yulingtianxia.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Threading Programming Guide(1)</title>
    <link href="http://yulingtianxia.com/blog/2017/08/28/Threading-Programming-Guide-1/"/>
    <id>http://yulingtianxia.com/blog/2017/08/28/Threading-Programming-Guide-1/</id>
    <published>2017-08-28T01:20:24.000Z</published>
    <updated>2018-09-15T08:28:13.542Z</updated>
    
    <content type="html">&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html#//apple_ref/doc/uid/10000057i-CH1-SW1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Threading Programming Guide&lt;/a&gt; 的学习笔记&amp;amp;翻译，第一部分。&lt;/p&gt;
&lt;p&gt;其实苹果建议使用对线程的高级封装，比如 operation objects and Grand Central Dispatch，它们使用方便更加高效，可以参考 &lt;a href=&quot;https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Concurrency Programming Guide&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;但了解更底层一些的内容其实更有趣，难道不是么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2017/09/17/Threading-Programming-Guide-2/&quot;&gt;Threading Programming Guide(2)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2017/10/08/Threading-Programming-Guide-3/&quot;&gt;Threading Programming Guide(3)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;线程相关概念&quot;&gt;&lt;a href=&quot;#线程相关概念&quot; class=&quot;headerlink&quot; title=&quot;线程相关概念&quot;&gt;&lt;/a&gt;线程相关概念&lt;/h2&gt;&lt;h3 id=&quot;概要和术语&quot;&gt;&lt;a href=&quot;#概要和术语&quot; class=&quot;headerlink&quot; title=&quot;概要和术语&quot;&gt;&lt;/a&gt;概要和术语&lt;/h3&gt;&lt;p&gt;线程的概念在计算机组成原理中学过，在各个系统中的实现和行为也都大同小异。多线程编程有利也有弊：在提升程序运行效率和用户体验的同时也带来了线程间同步的种种问题。现在大多数 CPU 都是多核的，所以很多程序都是并发执行来提升性能。多线程编程的代码更复杂，尤其是在存取同一个数据时更需要注意。这里讲一讲 macOS 和 iOS 提供的有关线程的 API 以及同步机制。&lt;/p&gt;
&lt;p&gt;如果把进程(process)理解为一个运行着多个线程(thread)的程序，线程运算调度一条独立路径的代码。任务(work)可以理解成需要被执行的代码块或函数之类的抽象概念。&lt;/p&gt;
&lt;h3 id=&quot;替代技术&quot;&gt;&lt;a href=&quot;#替代技术&quot; class=&quot;headerlink&quot; title=&quot;替代技术&quot;&gt;&lt;/a&gt;替代技术&lt;/h3&gt;&lt;p&gt;亲自去创建底层意义上的线程很难操作，也很容易出问题。创建一个新的线程会消耗很多 CPU 和内存资源，所以尽可能先考虑下是否真的有必要创建线程。对于直接手动创建线程执行任务来说，可以替代的技术还有很多：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Operation objects: 封装了一套在辅助线程执行任务的 API，只关注提交的任务即可，线程管理的底层工作交给系统。&lt;/li&gt;
&lt;li&gt;Grand Central Dispatch: 也是基于任务的 API，功能更强大，队列的使用更加灵活，强烈推荐。&lt;/li&gt;
&lt;li&gt;Idle-time notifications: 如果一项任务较轻且优先级较低，可以趁着不忙的时候执行。使用通知中心的 &lt;code&gt;postNotification:&lt;/code&gt; 方法可以立即抛通知，这是个同步执行的方法。其实通知会先进入一个先入先出的通知队列中，出列后才会被分发到通知中心。可以使用 &lt;code&gt;NSNotificationQueue&lt;/code&gt; 的 &lt;a href=&quot;https://developer.apple.com/documentation/foundation/notificationqueue/1416340-enqueue&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;enqueueNotification:postingStyle:&lt;/code&gt;&lt;/a&gt; 方法异步发送通知，postingStyle 设为 &lt;a href=&quot;https://developer.apple.com/documentation/foundation/notificationqueue.postingstyle/1418001-whenidle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;NSPostWhenIdle&lt;/code&gt;&lt;/a&gt; 即可在 Runloop 空闲时发送通知。&lt;/li&gt;
&lt;li&gt;Asynchronous functions: 使用系统自带的异步函数，把线程创建和管理的工作交给系统。&lt;/li&gt;
&lt;li&gt;Timers: 使用定时器在主线程做一些微小的周期性任务，而无需手动创建线程。&lt;/li&gt;
&lt;li&gt;Separate processes: 如果任务跟应用关联不紧密、占用大量内存或是需要 root 权限，可以创建进程，而非线程。使用 &lt;code&gt;fork&lt;/code&gt; 函数创建进程后记得调用 &lt;code&gt;exec&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;苹果系统的支持&quot;&gt;&lt;a href=&quot;#苹果系统的支持&quot; class=&quot;headerlink&quot; title=&quot;苹果系统的支持&quot;&gt;&lt;/a&gt;苹果系统的支持&lt;/h3&gt;&lt;p&gt;macOS 和 iOS 提供了几种创建线程的技术，以及对线程之间管理和同步任务的支持。&lt;/p&gt;
&lt;h4 id=&quot;对线程的封装&quot;&gt;&lt;a href=&quot;#对线程的封装&quot; class=&quot;headerlink&quot; title=&quot;对线程的封装&quot;&gt;&lt;/a&gt;对线程的封装&lt;/h4&gt;&lt;p&gt;线程的底层实现是在 Mach 层的，虽然它提供了抢占式多任务处理模型和线程调度能力，但我们常用的还是 POSIX API 及其衍生出来的 API：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Cocoa 线程: &lt;code&gt;NSThread&lt;/code&gt; 类以及 &lt;code&gt;NSObject&lt;/code&gt; 提供的线程 API。&lt;/li&gt;
&lt;li&gt;POSIX 线程: C 语言接口，比如创建线程的函数 &lt;code&gt;pthread_create&lt;/code&gt;。 &lt;code&gt;pthread_t&lt;/code&gt; 为线程句柄。&lt;/li&gt;
&lt;li&gt;Multiprocessing Services: 远古产物，弃用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不同系统中线程的生命周期都差不多，在线程退出之前，会在运行(running)、阻塞(blocked)、准备(ready)状态之间切换。创建线程需要指定其入口函数，入口函数 &lt;code&gt;return&lt;/code&gt; 后会终止线程，线程会被系统回收。创建线程会占内存和 CPU 资源，所以在入口函数里执行比较重的任务才值当。或者可以用 Runloop 做一些循环的任务。&lt;/p&gt;
&lt;h4 id=&quot;Run-Loops&quot;&gt;&lt;a href=&quot;#Run-Loops&quot; class=&quot;headerlink&quot; title=&quot;Run Loops&quot;&gt;&lt;/a&gt;Run Loops&lt;/h4&gt;&lt;p&gt;run loop 管理了线程接收的事件。它监听事件 source，有事件发生时，系统会唤起线程并将事件发送给 run loop，然后调用事件对应的 handler 函数。没有事件发生时会让线程休眠。&lt;/p&gt;
&lt;p&gt;如果没有 run loop，线程的入口函数 &lt;code&gt;return&lt;/code&gt; 后就会终止线程。run loop 可以让线程保活的同时消耗最少的资源。它在没有事件发生时会让线程休眠，而不是让 CPU 空转。run loop 与线程是一对一的关系，线程创建时默认是没有 run loop 的。&lt;/p&gt;
&lt;p&gt;系统的主线程自动配置好了 run loop，可以通过 &lt;code&gt;CFRunLoopGetMain()&lt;/code&gt; 获得。其他线程可以使用 &lt;code&gt;CFRunLoopGetCurrent()&lt;/code&gt; 获得对应的 run loop 对象，在第一次执行 &lt;code&gt;CFRunLoopGetCurrent()&lt;/code&gt; 时，线程才会创建它的 run loop。获得 run loop 对象后，可以配置其事件处理函数，并运行 run loop。&lt;/p&gt;
&lt;p&gt;run loop 对应的 API 有两种：&lt;code&gt;NSRunLoop&lt;/code&gt; 和 &lt;code&gt;CFRunLoop&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NSRunLoop&lt;/code&gt; Cocoa 的 API,非线程安全，必须在当前线程上下文中调用。它是对 &lt;code&gt;CFRunLoop&lt;/code&gt; 的封装。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CFRunLoop&lt;/code&gt; 为 &lt;code&gt;Core Foundation&lt;/code&gt; 框架的 C 语言 API，线程安全。使用 &lt;code&gt;CFRunLoopRef&lt;/code&gt; 引用 run loop 对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;同步工具&quot;&gt;&lt;a href=&quot;#同步工具&quot; class=&quot;headerlink&quot; title=&quot;同步工具&quot;&gt;&lt;/a&gt;同步工具&lt;/h4&gt;&lt;p&gt;多线程操作同一资源时要注意同步的问题，可以使用加锁、条件变量、原子操作等技术进行同步。&lt;/p&gt;
&lt;p&gt;加锁可以确保一段代码在某一时刻只能在一个线程中执行，最基本的是互斥锁(mutex, mutual exclusion)。Cocoa 提供了很多种锁来满足各种场景。&lt;/p&gt;
&lt;p&gt;当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。条件变量通过阻塞线程的方式确保了任务按正确的顺序执行，POSIX 层和 Foundation 框架都有 条件变量对应的 API。此外，Cocoa 提供的 operation objects 也能设置任务执行的顺序。&lt;/p&gt;
&lt;p&gt;原子操作适合同步多线程对标量数据类型的数学和逻辑运算，它跟锁相比，采用硬件指令优化，是一种轻量级同步工具。&lt;/p&gt;
&lt;h4 id=&quot;跨线程通信&quot;&gt;&lt;a href=&quot;#跨线程通信&quot; class=&quot;headerlink&quot; title=&quot;跨线程通信&quot;&gt;&lt;/a&gt;跨线程通信&lt;/h4&gt;&lt;p&gt;因为线程之间共用它们所属进程的相同空间，所以跨线程通信的方法有很多。它们各有优劣，按复杂度从低到高排列如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接发消息: &lt;code&gt;performSelector:onThread:withObject:waitUntilDone:modes:&lt;/code&gt; 等方法。&lt;/li&gt;
&lt;li&gt;全局变量，共用内存和对象: 相比直接发消息更快更容易，但也更脆弱。需要加锁之类的同步机制来确保代码的正确性，否则可能会导致竞态条件、错乱数据和crash。&lt;/li&gt;
&lt;li&gt;条件变量: 之前说过它也是一种线程同步工具，只有当符合某个条件时才让线程执行下去，相当于守门员的作用。&lt;/li&gt;
&lt;li&gt;Run loop sources: run loop input sources 有两种：port-based和 custom。这里说的是使用 custom run loop source 在某个线程上接收应用特定的消息。整个事件分发机制需要自己实现，包括设置 handler 函数，为 custom run loop source 提供数据，并手动给它发信号（signal）。&lt;/li&gt;
&lt;li&gt;端口和套接字: 基于端口的跨线程通信技术更复杂但也更可靠。更重要的是端口和套接字也可以与外部实体通信，比如其他进程和服务。为了高效，端口使用 port-based run loop sources 实现。&lt;/li&gt;
&lt;li&gt;消息队列: 古老的 Multiprocessing Services 定义了一个简单方便的 FIFO 队列来管理数据进出，但没其他跨线程通信技术效率高。&lt;/li&gt;
&lt;li&gt;Cocoa distributed objects: 对端口通信进行高级封装的 Cocoa API，其开销之大更适合跨进程通信。不建议用于跨线程通信，杀鸡用牛刀。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;设计秘籍&quot;&gt;&lt;a href=&quot;#设计秘籍&quot; class=&quot;headerlink&quot; title=&quot;设计秘籍&quot;&gt;&lt;/a&gt;设计秘籍&lt;/h3&gt;&lt;p&gt;这些建议和经验可以帮助开发者确保代码逻辑正确，性能更佳。&lt;/p&gt;
&lt;h4 id=&quot;避免直接创建线程&quot;&gt;&lt;a href=&quot;#避免直接创建线程&quot; class=&quot;headerlink&quot; title=&quot;避免直接创建线程&quot;&gt;&lt;/a&gt;避免直接创建线程&lt;/h4&gt;&lt;p&gt;手动创建线程很蛋疼还容易出错，所以要用其他 API 隐式实现并发，之前也提到了一些替代技术。建议使用 GCD 和 operation objects，可以根据当前系统负载自动调整活跃线程数量。&lt;/p&gt;
&lt;h4 id=&quot;让线程占用率适当&quot;&gt;&lt;a href=&quot;#让线程占用率适当&quot; class=&quot;headerlink&quot; title=&quot;让线程占用率适当&quot;&gt;&lt;/a&gt;让线程占用率适当&lt;/h4&gt;&lt;p&gt;手动创建管理线程时要注意线程消耗宝贵的系统资源，要做到物尽其所用，不能杀鸡用牛刀。更要毫不犹豫地终止大部分时间处于空闲状态的线程。线程占用的大量内存中有一部分是联动(wired)内存，所以释放那些使用率低的线程不仅可以减少应用的内存占用，也会为其他系统进程的运行释放更多物理内存。&lt;/p&gt;
&lt;p&gt;科普下苹果的内存使用相关术语：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Wired(联动): 系统核心占用的，一直存在 RAM 上，永远不会被挪到硬盘中。联动内存占用跟使用的应用有关。&lt;/li&gt;
&lt;li&gt;Active(活跃): 表示这些内存数据正在使用中，或者刚被使用过。&lt;/li&gt;
&lt;li&gt;Inactive(非活跃): 表示这些内存中的数据是有效的，但是最近没有被使用。如果打开一个应用再退出，其所占用内存会变为非活跃内存，再次打开这个应用时如果那块内存没被其他应用使用，那么会那块非活跃内存会变为活跃内存（无需从硬盘加载），使得应用打开速度更快。&lt;/li&gt;
&lt;li&gt;Free(可用空间): RAM 中没被使用的空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在终止线程前需要记录下当前的性能指标，并在终止线程之后再次记录，参照对比下是否真的提升了性能。&lt;/p&gt;
&lt;h4 id=&quot;避免共用数据结构&quot;&gt;&lt;a href=&quot;#避免共用数据结构&quot; class=&quot;headerlink&quot; title=&quot;避免共用数据结构&quot;&gt;&lt;/a&gt;避免共用数据结构&lt;/h4&gt;&lt;p&gt;避免线程相关资源冲突最简单的方法是每个线程都拷贝一份需要用的数据。线程之间通讯越少越好。&lt;/p&gt;
&lt;p&gt;即便对所有多线程场景下的共用数据加锁，就算再怎么仔细，代码可能依然在语义上不安全。比如代码逻辑要求用特定的顺序修改公用的数据结构，否则就会出问题。使用基于事务模型的代码可以弥补这个缺陷，但会进而抵消了多线程的性能优势。将资源竞争消灭在萌芽之中才会让方案更简单，性能更出众。&lt;/p&gt;
&lt;h4 id=&quot;线程与用户界面&quot;&gt;&lt;a href=&quot;#线程与用户界面&quot; class=&quot;headerlink&quot; title=&quot;线程与用户界面&quot;&gt;&lt;/a&gt;线程与用户界面&lt;/h4&gt;&lt;p&gt;建议在接受跟用户相关的事件和更新界面时使用主线程。因为 Cocoa 跟 UI 相关的 API 使用了一些全局变量，如果在其他线程去更新 UI 或者处理用户事件，就会发生一些同步问题。&lt;/p&gt;
&lt;p&gt;当然这个『在主线程更新界面』的规则也有些例外，比如在次级线程进行图像处理可以显著地提升性能。如果拿不准主意，那就干脆全在主线程去做吧。这样代码逻辑简单，易维护。&lt;/p&gt;
&lt;p&gt;Cocoa 图形绘制可以参考 &lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CocoaDrawingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40003290&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Cocoa Drawing Guide&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&quot;退出应用时注意线程的行为&quot;&gt;&lt;a href=&quot;#退出应用时注意线程的行为&quot; class=&quot;headerlink&quot; title=&quot;退出应用时注意线程的行为&quot;&gt;&lt;/a&gt;退出应用时注意线程的行为&lt;/h4&gt;&lt;p&gt;POSIX 线程按照资源释放方式分两种：joinable(non-detached) 和 detached。&lt;/p&gt;
&lt;p&gt;detached 类型的线程结束之后系统会自动回收其资源。假如在 A 线程中使用 &lt;code&gt;pthread_create&lt;/code&gt; 创建线程 B，不传入线程属性的话默认是 joinable 类型的线程。需要在线程 A 调用 &lt;code&gt;pthread_join&lt;/code&gt; 来连接，这样才会在线程 B 结束后回收其资源。&lt;/p&gt;
&lt;p&gt;默认情况下只有主线程是 joinable 的，当所有 joinable 线程都结束了，它们所属的进程也就终止执行了。因为系统会认为 detached 线程做的都是可选的任务，所以当用户退出了一个应用时，通常会立刻结束所有的 detached 线程。&lt;/p&gt;
&lt;p&gt;如果想让线程在后台做一些诸如保存数据到磁盘之类的重要工作，需要使用 joinable 类型的线程，以防止应用退出时数据丢失。但大多数的对线程高层封装的 API 不会默认创建 joinable 线程，所以需要使用 POSIX API 的 &lt;code&gt;pthread_create&lt;/code&gt; 创建 joinable 线程。&lt;/p&gt;
&lt;p&gt;在使用 Cocoa API 时，&lt;code&gt;applicationShouldTerminate:&lt;/code&gt; delegate 方法可以延迟一阵子退出应用或取消退出。如果需要延迟退出程序，还要在所有关键线程完成任务之后调用 &lt;code&gt;replyToApplicationShouldTerminate:&lt;/code&gt; 方法告诉 &lt;code&gt;NSApplication&lt;/code&gt; 对象是否可以真的退出了。&lt;/p&gt;
&lt;h4 id=&quot;处理异常&quot;&gt;&lt;a href=&quot;#处理异常&quot; class=&quot;headerlink&quot; title=&quot;处理异常&quot;&gt;&lt;/a&gt;处理异常&lt;/h4&gt;&lt;p&gt;每个线程都负责捕获和处理其调用栈上抛出的异常，任何线程上没被捕获的异常都能终止其所属进程。不能将没捕获的线程抛给其他线程处理。&lt;/p&gt;
&lt;p&gt;如果想要通知其他线程有异常，应该先捕获异常，然后给其他线程发消息。异常被捕获后可能会继续执行，或者等待命令，或者退出。&lt;/p&gt;
&lt;p&gt;Cocoa 的 &lt;code&gt;NSException&lt;/code&gt; 被捕获后可以在线程之间传递。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@synchronized&lt;/code&gt; 会自动捕获和处理异常。&lt;/p&gt;
&lt;h4 id=&quot;干净利落地终止线程&quot;&gt;&lt;a href=&quot;#干净利落地终止线程&quot; class=&quot;headerlink&quot; title=&quot;干净利落地终止线程&quot;&gt;&lt;/a&gt;干净利落地终止线程&lt;/h4&gt;&lt;p&gt;最好是让线程运行结束后自动退出，如果万不得已非要立刻终止线程，会导致线程没有释放和清理它占用的资源，比如：创建的内存、打开的文件以及获得的其他资源。无法回收这些资源意味着内存泄露和其他潜在的问题。&lt;/p&gt;
&lt;h4 id=&quot;Library-中的线程安全&quot;&gt;&lt;a href=&quot;#Library-中的线程安全&quot; class=&quot;headerlink&quot; title=&quot;Library 中的线程安全&quot;&gt;&lt;/a&gt;Library 中的线程安全&lt;/h4&gt;&lt;p&gt;开发第三方库的时候必须假设调用方随时都会处于多线程环境中，代码中的关键部分一定要加锁。虽然可以监听 &lt;code&gt;NSWillBecomeMultiThreadedNotification&lt;/code&gt; 通知来获知应用处于多线程，但可能 library 被调用之前就已经发过通知了。别指望当调用方处于多线程环境时才创建锁，而是需要在调用初始化 library 的方法中就提前创建好锁对象。但如果在 library 的静态初始化中创建锁会延长 library 的加载时间，影响性能。&lt;/p&gt;
&lt;p&gt;互斥锁的加锁和解锁操作要成对出现，不要指望调用方提供一个线程安全的环境，对数据结构该用锁就用。&lt;/p&gt;
&lt;h2 id=&quot;线程管理&quot;&gt;&lt;a href=&quot;#线程管理&quot; class=&quot;headerlink&quot; title=&quot;线程管理&quot;&gt;&lt;/a&gt;线程管理&lt;/h2&gt;&lt;p&gt;每个进程都至少有一个线程，每个线程代表了一条执行代码的独立路径。应用从一个线程的 &lt;code&gt;main&lt;/code&gt; 函数开始运行，然后产生新的线程。每个线程在进程内部都是独立的实体，具有自己的调用栈，并由内核做时分调度。线程可以与其他线程和进程通信，执行 I/O 操作等。一个应用进程内部的所有现场共享虚拟内存空间，并与进程拥有相同的访问权限。&lt;/p&gt;
&lt;h3 id=&quot;线程成本&quot;&gt;&lt;a href=&quot;#线程成本&quot; class=&quot;headerlink&quot; title=&quot;线程成本&quot;&gt;&lt;/a&gt;线程成本&lt;/h3&gt;&lt;p&gt;使用线程对应用和系统来说都是有成本的，具体体现在内存使用和性能上。每个线程需要占用内核内存空间和程序内存空间。内核会使用联动(wired)内存为线程创建用于管理线程和协调调度的数据结构。线程的栈空间和数据存储在程序的内存空间中。这些数据结构大部分会在创建线程的时候初始化，进程也因与内核有必要的交互而成本变得相对更高。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;成本项&lt;/th&gt;
&lt;th&gt;大致成本&lt;/th&gt;
&lt;th&gt;注释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;内核数据结构&lt;/td&gt;
&lt;td&gt;大约 1 KB&lt;/td&gt;
&lt;td&gt;用于存储线程数据结构和属性的内存，很多都是联动（wired）内存，所以不能在磁盘上分页&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;栈空间&lt;/td&gt;
&lt;td&gt;次级线程：512 KB ; macOS 主线程：8 MB ; iOS 主线程：1 MB&lt;/td&gt;
&lt;td&gt;次级线程的栈空间最小为 16 KB，且必须是 4 KB 的整数倍。创建线程的时候可以设置栈空间的大小，但是只有在需要用它的时候才会创建真的分页内存。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;创建时间&lt;/td&gt;
&lt;td&gt;大约 90 微秒（macOS 10.5，2 GHz Core Duo CPU，1 GB RAM）&lt;/td&gt;
&lt;td&gt;从开始创建线程到线程入口函数开始执行的耗时，是个粗略的估值。处理器负载、计算机速度、系统和程序可用内存都会对创建时间造成较大的影响。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;由于底层内核的支持，operation objects 经常可以更快地创建线程。它使用内核线程池中已经存在的线程来节省创建时间，而不是每次都从零开始创建线程。&lt;/p&gt;
&lt;p&gt;写线程相关代码也是一种生产成本。设计多线程程序又是需要对应用数据结构的组织方式进行彻底的改变。避免使用同步，因为它在设计较差的应用上会严重降低性能。设计数据结构和 debug 线程相关代码都会增加开发成本。&lt;/p&gt;
&lt;h3 id=&quot;创建线程&quot;&gt;&lt;a href=&quot;#创建线程&quot; class=&quot;headerlink&quot; title=&quot;创建线程&quot;&gt;&lt;/a&gt;创建线程&lt;/h3&gt;&lt;p&gt;创建线程需要指定入口主函数，并可设置一些线程的配置项。最后调用运行线程的方法。下面介绍几种创建线程的技术。&lt;/p&gt;
&lt;h4 id=&quot;使用-NSThread&quot;&gt;&lt;a href=&quot;#使用-NSThread&quot; class=&quot;headerlink&quot; title=&quot;使用 NSThread&quot;&gt;&lt;/a&gt;使用 &lt;code&gt;NSThread&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;使用 &lt;code&gt;NSThread&lt;/code&gt; 创建线程有两种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 &lt;code&gt;detachNewThreadSelector:toTarget:withObject:&lt;/code&gt; 类方法产生新的线程&lt;/li&gt;
&lt;li&gt;创建一个新的 &lt;code&gt;NSThread&lt;/code&gt; 对象，并调用它的 &lt;code&gt;start&lt;/code&gt; 方法。仅支持 iOS 和 macOS 10.5 以后的版本。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这两种方法都会创建一个 detached 线程，它退出后系统会自动回收其资源，无需手动 join 操作。&lt;/p&gt;
&lt;p&gt;下面两种创建线程的代码是等效的，但是推荐使用第二种方式。因为它支持在运行线程之前设置各种线程属性，不像第一种方式那样创建线程的时候必须立刻运行。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 方式 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;built_in&quot;&gt;NSThread&lt;/span&gt; detachNewThreadSelector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(myThreadMainMethod:) toTarget:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; withObject:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 方式 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSThread&lt;/span&gt;* myThread = [[&lt;span class=&quot;built_in&quot;&gt;NSThread&lt;/span&gt; alloc] initWithTarget:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                        selector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(myThreadMainMethod:)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                        object:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[myThread start];  &lt;span class=&quot;comment&quot;&gt;// Actually create the thread&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果不想使用 &lt;code&gt;initWithTarget:selector:object:&lt;/code&gt; 方法传入线程的入口函数，也可以继承 &lt;code&gt;NSThread&lt;/code&gt;，并覆写子类的 &lt;code&gt;main&lt;/code&gt; 方法（不用调用 &lt;code&gt;super&lt;/code&gt; 方法）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;performSelector:onThread:withObject:waitUntilDone:&lt;/code&gt; 方法可以在正在运行的线程发送消息，前提是这个线程必须有运行中的 run loop，因为消息会在线程的 run loop 日常处理过程中被执行。注意使用此方法进行跨线程通信时需要有同步机制。此方法并不适合用于实现时间紧要和频繁的跨线程通信。&lt;/p&gt;
&lt;h4 id=&quot;使用-POSIX-线程&quot;&gt;&lt;a href=&quot;#使用-POSIX-线程&quot; class=&quot;headerlink&quot; title=&quot;使用 POSIX 线程&quot;&gt;&lt;/a&gt;使用 POSIX 线程&lt;/h4&gt;&lt;p&gt;iOS 和 macOS 提供了基于 C 语言的 POSIX 线程 API 来创建线程，优点是跨平台。创建线程的函数是 &lt;code&gt;pthread_create&lt;/code&gt;，默认创建的是 joinable 线程，所以需要设置线程属性来将其创建为 detached 线程，这样当线程退出的时候其资源就会立刻被系统回收利用了：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;assert.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;pthread.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 线程入口主程序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;* &lt;span class=&quot;title&quot;&gt;PosixThreadMainRoutine&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;* data)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 在这里加代码.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 创建线程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;LaunchThread&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Create the thread using POSIX routines.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;pthread_attr_t&lt;/span&gt;  attr;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;pthread_t&lt;/span&gt;       posixThreadID;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;             returnVal;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    returnVal = pthread_attr_init(&amp;amp;attr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    assert(!returnVal);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    returnVal = pthread_attr_setdetachstate(&amp;amp;attr, PTHREAD_CREATE_DETACHED);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    assert(!returnVal);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;// 因为 PosixThreadMainRoutine 函数没有参数，所以 pthread_create 最后一个参数传 NULL&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;     threadError = pthread_create(&amp;amp;posixThreadID, &amp;amp;attr, &amp;amp;PosixThreadMainRoutine, NULL);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    returnVal = pthread_attr_destroy(&amp;amp;attr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    assert(!returnVal);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (threadError != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;comment&quot;&gt;// Report an error.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对于 C 语言的应用，可以使用端口、条件变量s 或共用内存来跨线程通信。跨线程通信有便于主线程检查其他线程的状态，在应用退出时做一些操作。&lt;/p&gt;
&lt;p&gt;关于 POSIX 线程函数可以翻阅 pthread man page。&lt;/p&gt;
&lt;h4 id=&quot;使用-NSObject-产生线程&quot;&gt;&lt;a href=&quot;#使用-NSObject-产生线程&quot; class=&quot;headerlink&quot; title=&quot;使用 NSObject 产生线程&quot;&gt;&lt;/a&gt;使用 &lt;code&gt;NSObject&lt;/code&gt; 产生线程&lt;/h4&gt;&lt;p&gt;iOS 和 macOS 10.5 之后 &lt;code&gt;NSObject&lt;/code&gt; 提供了&lt;code&gt;performSelectorInBackground:withObject:&lt;/code&gt; 方法，可以让所有对象都创建 detached 线程，并传入 &lt;code&gt;selector&lt;/code&gt; 作为入口函数。跟它等效的方法是 &lt;code&gt;NSThread&lt;/code&gt; 的 &lt;code&gt;detachNewThreadSelector:toTarget:withObject:&lt;/code&gt;。在 &lt;code&gt;selector&lt;/code&gt; 方法里可以继续配置线程，比如添加 &lt;code&gt;autoreleasepool&lt;/code&gt; 和 run loop。&lt;/p&gt;
&lt;h4 id=&quot;在-Cocoa-应用中使用-POSIX-线程&quot;&gt;&lt;a href=&quot;#在-Cocoa-应用中使用-POSIX-线程&quot; class=&quot;headerlink&quot; title=&quot;在 Cocoa 应用中使用 POSIX 线程&quot;&gt;&lt;/a&gt;在 Cocoa 应用中使用 POSIX 线程&lt;/h4&gt;&lt;p&gt;在 Cocoa 中使用 POSIX 线程需要注意它们之间的交互，并遵守以下原则。&lt;/p&gt;
&lt;h5 id=&quot;保护-Cocoa-框架&quot;&gt;&lt;a href=&quot;#保护-Cocoa-框架&quot; class=&quot;headerlink&quot; title=&quot;保护 Cocoa 框架&quot;&gt;&lt;/a&gt;保护 Cocoa 框架&lt;/h5&gt;&lt;p&gt;Cocoa 框架使用加锁之类的同步机制来确保多线程工作正常，但只有在第一次使用 &lt;code&gt;NSThread&lt;/code&gt; 产生新线程的时候才会真的创建锁。这可以避免单线程情况下加锁会降低性能。但如果只使用 POSIX API 来产生新线程，Cocoa 就不会收到应用转换为多线程的通知，进而导致应用不稳定，甚至 crash。可以用 &lt;code&gt;NSThread&lt;/code&gt; 创建一个新线程，入口函数啥都不做，这样线程就会立刻退出。这样 Cocoa 就知道应用处于多线程了，加锁也会生效。PS：这么抖机灵的做法当然也会产生创建线程的开销，有些违背之前说的不要随意创建线程的原则。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NSThread&lt;/code&gt; 的 &lt;code&gt;isMultiThreaded&lt;/code&gt; 方法可以检查应用是否是多线程。&lt;/p&gt;
&lt;h5 id=&quot;混合使用-POSIX-和-Cocoa-锁&quot;&gt;&lt;a href=&quot;#混合使用-POSIX-和-Cocoa-锁&quot; class=&quot;headerlink&quot; title=&quot;混合使用 POSIX 和 Cocoa 锁&quot;&gt;&lt;/a&gt;混合使用 POSIX 和 Cocoa 锁&lt;/h5&gt;&lt;p&gt;在一个应用中混合使用 POSIX 和 Cocoa 两套 API 的锁是安全的，因为后者实质上只是对前者的封装。但不能用一种 API 的方法操作另一种 API 创建的锁。比如不能使用 &lt;code&gt;NSLock&lt;/code&gt; 对象操作 &lt;code&gt;pthread_mutex_init&lt;/code&gt; 函数创建的互斥锁，反之亦然。&lt;/p&gt;
&lt;h3 id=&quot;配置线程属性&quot;&gt;&lt;a href=&quot;#配置线程属性&quot; class=&quot;headerlink&quot; title=&quot;配置线程属性&quot;&gt;&lt;/a&gt;配置线程属性&lt;/h3&gt;&lt;h4 id=&quot;配置线程的栈尺寸&quot;&gt;&lt;a href=&quot;#配置线程的栈尺寸&quot; class=&quot;headerlink&quot; title=&quot;配置线程的栈尺寸&quot;&gt;&lt;/a&gt;配置线程的栈尺寸&lt;/h4&gt;&lt;p&gt;创建线程后系统会为其创建一块内存作为栈空间，开发者可以在创建线程前配置这块空间的尺寸。所有的线程技术都会提供某种设置栈尺寸的方法，但 &lt;code&gt;NSThread&lt;/code&gt; 只有在 iOS 和 macOS 10.5 之后支持设置栈的尺寸。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;技术&lt;/th&gt;
&lt;th&gt;选项&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Cocoa&lt;/td&gt;
&lt;td&gt;前提是不要使用 &lt;code&gt;detachNewThreadSelector:toTarget:withObject:&lt;/code&gt; 创建线程。创建线程对象后，在调用线程对象的 &lt;code&gt;start&lt;/code&gt; 方法之前，使用 &lt;code&gt;setStackSize:&lt;/code&gt; 方法指定栈的大小。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;POSIX&lt;/td&gt;
&lt;td&gt;创建 &lt;code&gt;pthread_attr_t&lt;/code&gt; 栈属性结构体并使用 &lt;code&gt;pthread_attr_setstacksize&lt;/code&gt; 函数修改默认的栈尺寸。在使用 &lt;code&gt;pthread_create&lt;/code&gt; 函数创建线程时将属性结构体传入。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Multiprocessing Services&lt;/td&gt;
&lt;td&gt;使用 &lt;code&gt;MPCreateTask&lt;/code&gt; 函数创建线程时可以传入栈尺寸。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&quot;配置-TLS-Thread-Local-Storage&quot;&gt;&lt;a href=&quot;#配置-TLS-Thread-Local-Storage&quot; class=&quot;headerlink&quot; title=&quot;配置 TLS(Thread-Local Storage)&quot;&gt;&lt;/a&gt;配置 TLS(Thread-Local Storage)&lt;/h4&gt;&lt;p&gt;每个线程都维护了一个存储键值对的字典，在线程内随处都能存取。可以用它记录一些贯穿于线程执行过程中的信息，比如 run loop 迭代次数。&lt;/p&gt;
&lt;p&gt;Cocoa 与 POSIX 存储线程字典的方式不同，所以两种技术的 API 不能混用。只要你始终用其中一种技术，最后结果都差不多。具体方式如下：&lt;/p&gt;
&lt;p&gt;Cocoa: &lt;code&gt;NSThread&lt;/code&gt; 的 &lt;code&gt;threadDictionary&lt;/code&gt; 方法获取 &lt;code&gt;NSMutableDictionary&lt;/code&gt; 字典对象，然后进行存取。&lt;br&gt;POSIX: 直接用 &lt;code&gt;pthread_setspecific&lt;/code&gt; 和 &lt;code&gt;pthread_getspecific&lt;/code&gt; 函数存取字典。&lt;/p&gt;
&lt;h4 id=&quot;设置线程的-Detached-状态&quot;&gt;&lt;a href=&quot;#设置线程的-Detached-状态&quot; class=&quot;headerlink&quot; title=&quot;设置线程的 Detached 状态&quot;&gt;&lt;/a&gt;设置线程的 Detached 状态&lt;/h4&gt;&lt;p&gt;大部分高级线程技术创建的线程默认都是 detached 状态，这是因为大部分场景下都需要系统在线程执行完成后立刻回收资源。好处是代码干净，是否获取线程执行结果可以自行决定。&lt;/p&gt;
&lt;p&gt;joinable 线程需要其他线程调用 &lt;code&gt;pthread_join&lt;/code&gt; 函数对其进行 join 操作之后才能被系统回收资源。joinable 线程可以向 &lt;code&gt;pthread_exit&lt;/code&gt; 函数传入数据，其他线程可以在调用 &lt;code&gt;pthread_join&lt;/code&gt; 函数的时候获得此数据。参考 &lt;a href=&quot;https://stackoverflow.com/questions/8513894/pthread-join-and-pthread-exit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;pthread_join() and pthread_exit()&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;应用退出时，detached 线程可以立刻结束，但是 joinable 线程必须全都被 join 后进程才能退出。因此 joinable 线程适用于执行不能中断的重要工作，比如向磁盘写入数据。&lt;/p&gt;
&lt;p&gt;只能用 POSIX API 来创建 joinable 线程，如果不设置线程属性，默认就是 joinable 线程。可以在创建线程之前调用 &lt;code&gt;pthread_attr_setdetachstate&lt;/code&gt; 函数修改线程 detached 状态。在线程开始运行之后，可以调用 &lt;code&gt;pthread_detach&lt;/code&gt; 函数将一个 joinable 线程变成 detached 线程。&lt;/p&gt;
&lt;h4 id=&quot;设置线程优先级&quot;&gt;&lt;a href=&quot;#设置线程优先级&quot; class=&quot;headerlink&quot; title=&quot;设置线程优先级&quot;&gt;&lt;/a&gt;设置线程优先级&lt;/h4&gt;&lt;p&gt;任何新创建的线程都有个默认优先级。内核的调度算法在决定运行哪个线程的时候都会考虑到线程优先级，优先级越高越可能先运行。拥有更高优先级的线程并不保证有特定的运行时间，只是在与低优先级线程比较时更容易被调度算法选中罢了。&lt;/p&gt;
&lt;p&gt;最好让你创建的线程保持默认优先级。提升一些线程的优先级也会提升低优先级线程饥饿的可能性。如果高优先级线程和低优先级线程之间有交互，低优先级线程饥饿可能会阻塞其他线程，并造成性能瓶颈。&lt;/p&gt;
&lt;p&gt;设置线程优先级的方式如下：&lt;/p&gt;
&lt;p&gt;Cocoa: &lt;code&gt;NSThread&lt;/code&gt; 的 &lt;code&gt;setThreadPriority:&lt;/code&gt; 类方法可以设置当前线程的优先级。&lt;br&gt;POSIX: &lt;code&gt;pthread_setschedparam&lt;/code&gt; 函数设置优先级。&lt;/p&gt;
&lt;h3 id=&quot;编写线程入口程序&quot;&gt;&lt;a href=&quot;#编写线程入口程序&quot; class=&quot;headerlink&quot; title=&quot;编写线程入口程序&quot;&gt;&lt;/a&gt;编写线程入口程序&lt;/h3&gt;&lt;p&gt;各平台上的线程入口函数结构都差不多，一般都会初始化数据结构，执行一些工作，或者使用 run loop 保活，最后在工作完成后清理占用的资源。这里讲一下编写线程入口程序需要做的一些额外步骤。&lt;/p&gt;
&lt;h4 id=&quot;创建自动释放池&quot;&gt;&lt;a href=&quot;#创建自动释放池&quot; class=&quot;headerlink&quot; title=&quot;创建自动释放池&quot;&gt;&lt;/a&gt;创建自动释放池&lt;/h4&gt;&lt;p&gt;使用 Objective-C 框架的应用必须确保每条线程至少有一个自动释放池。如果开启垃圾回收机制，自动释放池会失效。PS: 垃圾回收很早就被苹果弃用了。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;@autoreleasepool&lt;/code&gt; 创建自动释放池比 &lt;code&gt;NSAutoreleasePool&lt;/code&gt; 更方便。而且 &lt;code&gt;NSAutoreleasePool&lt;/code&gt; 不能在 ARC 下使用。&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;-&lt;/span&gt; (void)&lt;span class=&quot;selector-tag&quot;&gt;myThreadMainRoutine&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;variable&quot;&gt;@autoreleasepool&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    &lt;span class=&quot;comment&quot;&gt;// Do thread work here.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;有时需要创建更多的自动释放池，比如在循环内部使用自动释放池降低内存开销。&lt;/p&gt;
&lt;p&gt;关于自动释放池的使用，不再赘述。&lt;/p&gt;
&lt;h4 id=&quot;设置-Exception-Handler&quot;&gt;&lt;a href=&quot;#设置-Exception-Handler&quot; class=&quot;headerlink&quot; title=&quot;设置 Exception Handler&quot;&gt;&lt;/a&gt;设置 Exception Handler&lt;/h4&gt;&lt;p&gt;没被捕获的异常会导致应用崩溃，虽然最好应该在异常发生的地方进行异常处理，但是在线程的入口函数再加上个 try/catch 比较好。&lt;/p&gt;
&lt;p&gt;更多内容参考 &lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Exceptions/Exceptions.html#//apple_ref/doc/uid/10000012i&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Exception Programming Topics&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&quot;设置-Run-Loop&quot;&gt;&lt;a href=&quot;#设置-Run-Loop&quot; class=&quot;headerlink&quot; title=&quot;设置 Run Loop&quot;&gt;&lt;/a&gt;设置 Run Loop&lt;/h4&gt;&lt;p&gt;编写线程上运行的代码有两种选择：1. 代码简单粗暴，任务执行完线程就退出了；2. 设置线程的 run loop，处理不断到来的请求。&lt;/p&gt;
&lt;p&gt;macOS 和 iOS 内置了 run loop 的实现，应用的主线程自动开启 run loop。开发者创建的次级线程需要手动配置和开启 run loop。&lt;/p&gt;
&lt;h3 id=&quot;终止线程&quot;&gt;&lt;a href=&quot;#终止线程&quot; class=&quot;headerlink&quot; title=&quot;终止线程&quot;&gt;&lt;/a&gt;终止线程&lt;/h3&gt;&lt;p&gt;建议让线程的入口函数正常退出。虽然 Cocoa，POSIX 和 Multiprocessing Services 提供了直接杀线程的方法，但强烈不建议使用。强杀线程会导致无法回收资源，可能导致内存泄露、资源没被正确清理，进而导致后续的隐患。&lt;/p&gt;
&lt;p&gt;如果预料到需要中途结束线程，设计线程之初就应该响应到取消或退出的消息。带有 run loop 这种周期操作的线程可以每次查看是否收到退出的消息。如果需要退出线程，则可以清理线程资源后退出；否则继续处理其他工作。&lt;/p&gt;
&lt;p&gt;run loop 可以使用 input source 接受其他线程发的消息，但需要为 &lt;code&gt;NSRunLoop&lt;/code&gt; 配置 &lt;code&gt;CFRunLoopSourceRef&lt;/code&gt;，假设这部分代码在 &lt;code&gt;myInstallCustomInputSource&lt;/code&gt; 已经实现好了。下面的代码还省略了自动释放池和 &lt;code&gt;while&lt;/code&gt; 主循环中做的实际工作。将标记是否需要退出线程的局部变量 &lt;code&gt;exitNow&lt;/code&gt; 的值放在 TLS 中同步是为了方便 input source 的事件处理函数对 &lt;code&gt;exitNow&lt;/code&gt; 的存取，因为事件处理是在另外一个函数，不能直接存取 &lt;code&gt;exitNow&lt;/code&gt;，需要经过 TLS。当 input source 收到退出消息后，对应的事件处理函数便可以清理线程的资源，准备退出。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)threadMainRoutine&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; moreWorkToDo = &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; exitNow = &lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSRunLoop&lt;/span&gt;* runLoop = [&lt;span class=&quot;built_in&quot;&gt;NSRunLoop&lt;/span&gt; currentRunLoop];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Add the exitNow BOOL to the thread dictionary.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSMutableDictionary&lt;/span&gt;* threadDict = [[&lt;span class=&quot;built_in&quot;&gt;NSThread&lt;/span&gt; currentThread] threadDictionary];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [threadDict setValue:[&lt;span class=&quot;built_in&quot;&gt;NSNumber&lt;/span&gt; numberWithBool:exitNow] forKey:&lt;span class=&quot;string&quot;&gt;@&quot;ThreadShouldExitNow&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Install an input source.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; myInstallCustomInputSource];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (moreWorkToDo &amp;amp;&amp;amp; !exitNow)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Do one chunk of a larger body of work here.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Change the value of the moreWorkToDo Boolean when done.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Run the run loop but timeout immediately if the input source isn&#39;t waiting to fire.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [runLoop runUntilDate:[&lt;span class=&quot;built_in&quot;&gt;NSDate&lt;/span&gt; date]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Check to see if an input source handler changed the exitNow value.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        exitNow = [[threadDict valueForKey:&lt;span class=&quot;string&quot;&gt;@&quot;ThreadShouldExitNow&quot;&lt;/span&gt;] boolValue];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html#//apple_ref/doc/uid/10000057i-CH1-SW1&quot;&gt;Threading Programming Guide&lt;/a&gt; 的学习笔记&amp;amp;翻译，第一部分。&lt;/p&gt;
&lt;p&gt;其实苹果建议使用对线程的高级封装，比如 operation objects and Grand Central Dispatch，它们使用方便更加高效，可以参考 &lt;a href=&quot;https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091&quot;&gt;Concurrency Programming Guide&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;但了解更底层一些的内容其实更有趣，难道不是么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2017/09/17/Threading-Programming-Guide-2/&quot;&gt;Threading Programming Guide(2)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2017/10/08/Threading-Programming-Guide-3/&quot;&gt;Threading Programming Guide(3)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="http://yulingtianxia.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>What&#39;s New in LLVM</title>
    <link href="http://yulingtianxia.com/blog/2017/07/17/What-s-New-in-LLVM-2017/"/>
    <id>http://yulingtianxia.com/blog/2017/07/17/What-s-New-in-LLVM-2017/</id>
    <published>2017-07-16T16:04:37.000Z</published>
    <updated>2018-09-15T08:28:13.597Z</updated>
    
    <content type="html">&lt;p&gt;这&lt;strong&gt;绝不仅仅&lt;/strong&gt;是一篇 WWDC 2017 Session 411 学习笔记。除了有关 LLVM  9.0 的新特性之外，还有关于静态分析器和 Clang 5 Objective-C ARC 的一点看法和经验。&lt;/p&gt;
&lt;p&gt;我觉得 LLVM 9 的亮点如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;支持 Objective-C API 可用性检查&lt;/li&gt;
&lt;li&gt;新增一些对隐患代码的静态分析检查和 warning&lt;/li&gt;
&lt;li&gt;更快的 LTO，使其可以真正使用&lt;/li&gt;
&lt;/ol&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;API-Availability-Checking-for-Objective-C&quot;&gt;&lt;a href=&quot;#API-Availability-Checking-for-Objective-C&quot; class=&quot;headerlink&quot; title=&quot;API Availability Checking for Objective-C&quot;&gt;&lt;/a&gt;API Availability Checking for Objective-C&lt;/h2&gt;&lt;p&gt;在低版本系统上调用高版本 SDK 的 API 会引发 crash，所以在兼容多版本系统时需要谨慎判断系统版本，然后使用对应的 API。这些在运行时才能生效的代码很容易编写出错，而且需要测试人员付出很大工作量来覆盖到各个版本的系统。检查类、实例方法、类方法等是否可用时需要写的代码也不同，很蛋疼呦。&lt;/p&gt;
&lt;p&gt;Swift 3 加入了 &lt;code&gt;#available&lt;/code&gt; 语法来检查 API 是否可用，在编译阶段就可以发现哪里漏掉了 API 可用性检查。如今，Objective-C 也有这项功能啦。&lt;/p&gt;
&lt;h3 id=&quot;Objective-C&quot;&gt;&lt;a href=&quot;#Objective-C&quot; class=&quot;headerlink&quot; title=&quot;Objective-C&quot;&gt;&lt;/a&gt;Objective-C&lt;/h3&gt;&lt;p&gt;假设加入 App 支持的最低版本是 iOS 10，但是直接调用了 iOS 11 的 API，那么编译器会告警，提醒开发者某个 API 只能用于较新版本的系统上。这时需要通过 &lt;code&gt;@available&lt;/code&gt; 语法来判断平台和版本：&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;variable&quot;&gt;@available&lt;/span&gt;(iOS &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;, *)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// iOS 11 以上以及其他所有平台&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;*&lt;/code&gt; 相当于通配符，代表所有其他平台都可用。&lt;/p&gt;
&lt;p&gt;说完了如何检查 API 可用性后，再来谈谈声明 API 可用性的问题：&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;name&quot;&gt;void&lt;/span&gt;)foo API_AVAILABLE(&lt;span class=&quot;name&quot;&gt;ios&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;11.0&lt;/span&gt;))&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的代码声明了调用 &lt;code&gt;foo&lt;/code&gt; 方法需要 iOS 11 以上，而 &lt;code&gt;foo&lt;/code&gt; 方法内部的实现中调用 iOS 11 的 API 时无需再用 &lt;code&gt;@available&lt;/code&gt; 检查。&lt;/p&gt;
&lt;p&gt;声明一个类的可用性也很简单，并且无需给类中的每个方法再次声明可用性，只需要用到 &lt;code&gt;API_AVAILABLE&lt;/code&gt; 宏：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;API_&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;(ios(&lt;span class=&quot;number&quot;&gt;11.0&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyClassForiOS11OrNewer&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)foo;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其实类似的有关 API 兼容版本的宏还有好几个：&lt;/p&gt;
&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;API_DEPRECATED&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;API_UNAVAILABLE&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;API_DEPRECATED_WITH_REPLACEMENT&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;C-amp-C&quot;&gt;&lt;a href=&quot;#C-amp-C&quot; class=&quot;headerlink&quot; title=&quot;C &amp;amp; C++&quot;&gt;&lt;/a&gt;C &amp;amp; C++&lt;/h3&gt;&lt;p&gt;如果是想在 C 或 C++ 中查询 API 的可用性，可以使用 LLVM 新加的 &lt;code&gt;__builtin_available()&lt;/code&gt; 函数：&lt;/p&gt;
&lt;figure class=&quot;highlight gcode&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;(__builtin_available(iOS 11, macOS 10.13, *)&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// iOS 11 以上或 macOS 10.13 以上平台，以及其他所有平台&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 C 或 C++ 中使用 &lt;code&gt;API_AVAILABLE&lt;/code&gt; 宏之前需要引入头文件&lt;/p&gt;
&lt;figure class=&quot;highlight arduino&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;os/availability.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; API_AVAILABLE(ios(&lt;span class=&quot;number&quot;&gt;11.0&lt;/span&gt;)) MyClassForiOS11OrNewer;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;适用范围&quot;&gt;&lt;a href=&quot;#适用范围&quot; class=&quot;headerlink&quot; title=&quot;适用范围&quot;&gt;&lt;/a&gt;适用范围&lt;/h3&gt;&lt;p&gt;对于旧工程，LLVM 只会对新的 API 进行告警(包含 iOS 11,tvOS 11,macOS 10.13,watchOS 4 以上)。旧的 API 不会被编译器告警，所以不用担心旧项目中已有的代码会产生一大片 warning，只需在采用新 API 的时候加上 &lt;code&gt;@available&lt;/code&gt; 或 &lt;code&gt;API_AVAILABLE&lt;/code&gt;。也可以选择在 Build Settings 中设置 &lt;code&gt;Unguarded availability&lt;/code&gt; 为 &lt;code&gt;YES(All Versions)&lt;/code&gt; 来检查所有的 API。Xcode 9 新建工程 &lt;code&gt;Unguarded availability&lt;/code&gt; 项默认为 &lt;code&gt;YES(All Versions)&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;Static-Analyzer-Checks&quot;&gt;&lt;a href=&quot;#Static-Analyzer-Checks&quot; class=&quot;headerlink&quot; title=&quot;Static Analyzer Checks&quot;&gt;&lt;/a&gt;Static Analyzer Checks&lt;/h2&gt;&lt;p&gt;除了在 Xcode-&amp;gt;Product-&amp;gt;Analyze 中开启静态分析检查外，也可以在 Build 过程中进行静态分析检查。只需在编译设置中将 &lt;code&gt;Analyse During &amp;#39;Build&amp;#39;&lt;/code&gt; 设为 &lt;code&gt;YES&lt;/code&gt;。 &lt;/p&gt;
&lt;p&gt;苹果补充了一些检查项，看了下还都是一不留神就容易犯或者根本没注意到的细节。&lt;/p&gt;
&lt;h3 id=&quot;比较-NSNumber&quot;&gt;&lt;a href=&quot;#比较-NSNumber&quot; class=&quot;headerlink&quot; title=&quot;比较 NSNumber&quot;&gt;&lt;/a&gt;比较 NSNumber&lt;/h3&gt;&lt;p&gt;稍有经验的老司机都懂得 NSNumber 不能直接跟 raw value 直接比较，毕竟前者是类的实例对象，后者是基本类型。然而还是有人会弄错：&lt;/p&gt;
&lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSNumber *&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt; = @&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSNumber *check = @YES&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if (&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt; &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  NSLog(@&lt;span class=&quot;string&quot;&gt;&quot;肯定会进到这里，因为 count 不为 nil&quot;&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if (check) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  NSLog(@&lt;span class=&quot;string&quot;&gt;&quot;肯定会进到这里，因为 check 不为 nil&quot;&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在 LLVM 可以检查出这种情况，也可以关闭这项检查：在编译设置中将 &lt;code&gt;Suspicious Conversions of NSNumber and CFNumberRef&lt;/code&gt; 设为 &lt;code&gt;NO&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;dispatch-once&quot;&gt;&lt;a href=&quot;#dispatch-once&quot; class=&quot;headerlink&quot; title=&quot;dispatch_once()&quot;&gt;&lt;/a&gt;&lt;code&gt;dispatch_once()&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;Xcode 的 code snippet 很好用，我觉得正常人不会把 &lt;code&gt;dispatch_once()&lt;/code&gt; 写错吧。&lt;/p&gt;
&lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static &lt;span class=&quot;keyword&quot;&gt;dispatch_once_t &lt;/span&gt;onceToken&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;dispatch_once(&amp;amp;onceToken, &lt;/span&gt;^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   foo()&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;onceToken&lt;/code&gt; 只能是全局变量或静态变量，使得指针地址的唯一性保证了 &lt;code&gt;foo()&lt;/code&gt; 只执行一次。但总有奇葩把 &lt;code&gt;onceToken&lt;/code&gt; 声明成成员变量，使得指针地址可能会重复，无法保证线程安全地只执行一次。而现在 LLVM 可以检查出这种不规范的使用方式。&lt;/p&gt;
&lt;p&gt;当然，想实现线程安全地只执行一次方法，也可以通过加锁和判断标志位的方式来实现。&lt;/p&gt;
&lt;h3 id=&quot;NSMutable-类型的属性使用-copy-内存管理语义&quot;&gt;&lt;a href=&quot;#NSMutable-类型的属性使用-copy-内存管理语义&quot; class=&quot;headerlink&quot; title=&quot;NSMutable 类型的属性使用 copy 内存管理语义&quot;&gt;&lt;/a&gt;&lt;code&gt;NSMutable&lt;/code&gt; 类型的属性使用 &lt;code&gt;copy&lt;/code&gt; 内存管理语义&lt;/h3&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; *array;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;内存管理语义帮开发者自动合成了 &lt;code&gt;set&lt;/code&gt; 方法的实现，但是当 &lt;code&gt;copy&lt;/code&gt; 应用到了 &lt;code&gt;NSMutable&lt;/code&gt; 系列的类上，就会产生问题。因为我们想要的是把新的值 &lt;code&gt;mutableCopy&lt;/code&gt; 后赋值给属性，然而内存管理语义中只有 &lt;code&gt;copy&lt;/code&gt; 却没有 &lt;code&gt;mutableCopy&lt;/code&gt;。而现在 LLVM 可以检查出这种情况。&lt;/p&gt;
&lt;p&gt;重写 &lt;code&gt;set&lt;/code&gt; 方法可以解决此问题:&lt;/p&gt;
&lt;figure class=&quot;highlight arduino&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)setArray:(NSMutableArray *)&lt;span class=&quot;keyword&quot;&gt;array&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _array = [&lt;span class=&quot;keyword&quot;&gt;array&lt;/span&gt; mutableCopy];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;一些建议&quot;&gt;&lt;a href=&quot;#一些建议&quot; class=&quot;headerlink&quot; title=&quot;一些建议&quot;&gt;&lt;/a&gt;一些建议&lt;/h3&gt;&lt;p&gt;静态分析能做到在编译阶段发现一些程序员容易疏忽的地方，它只能检查特定场景下的一些被认为不符合规范的行为。也就是说它维护了一个 List，编译的时候一项一项检查是否合符规范，但是这个 List 之外的行为并不能被检查出来，这也就是为什么 LLVM 每年都在向这个 List 新增内容。这个 List 包含了程序员容易犯的代码问题，并且这些问题暗涵很严重的逻辑错误。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;随着 Check List 的不断膨胀，静态分析耗时会增加，对于大中型项目，我并不建议开启每次编译时都进行静态分析检查。建议在每个版本测试阶段定期做静态分析检查。&lt;/li&gt;
&lt;li&gt;不要过于相信静态分析检查。首先它会漏检，Check List 之外的情况根本检查不出来。如果将一些 API 包含在宏定义中或者封装在 C 函数中调用，导致语法复杂，静态分析甚至还会误报。（我曾经碰见过几次静态分析检查出 MRC 下一些内存泄露，但其实间接调用了 &lt;code&gt;autorelease&lt;/code&gt; 的，根本不会泄露，改为直接调用 &lt;code&gt;autorelease&lt;/code&gt; 就 OK 了）&lt;/li&gt;
&lt;li&gt;程序员自身应该有一份 Check List，在平时变成变成过程中不断约束自己。比如判断 &lt;code&gt;NSString&lt;/code&gt; 是否有内容时直接看 &lt;code&gt;length&lt;/code&gt; 是否大于 0，而不是判断是否为 &lt;code&gt;nil&lt;/code&gt; 或 &lt;code&gt;@&amp;quot;&amp;quot;&lt;/code&gt;。这跟打游戏是否有意识差不多，写代码也要有『意识流』。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;New-Warnings&quot;&gt;&lt;a href=&quot;#New-Warnings&quot; class=&quot;headerlink&quot; title=&quot;New Warnings&quot;&gt;&lt;/a&gt;New Warnings&lt;/h2&gt;&lt;p&gt;Xcode 9 的 LLVM 又新增了一百多个 error 和 warning，然而大多数程序员还不是照样忽视 warning 么？可以在编译设置中将 warning 升级成 error。如果是旧的工程，需要升级工程文件到 Xcode 9，然后才能看到这些新增的 warning 设置项。（点击工程-&amp;gt;Editor-&amp;gt;Validate Settings）&lt;/p&gt;
&lt;h3 id=&quot;ARC-中的-Block-捕获参数&quot;&gt;&lt;a href=&quot;#ARC-中的-Block-捕获参数&quot; class=&quot;headerlink&quot; title=&quot;ARC 中的 Block 捕获参数&quot;&gt;&lt;/a&gt;ARC 中的 Block 捕获参数&lt;/h3&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)validateDictionary:(&lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *, &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *&amp;gt; *)dict error:(&lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; **)error&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [dict enumerateKeysAndObjectsUsingBlock:^(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; * _Nonnull key, &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; * _Nonnull obj, &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; * _Nonnull stop) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (obj.length &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (error) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                *error = [&lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; errorWithDomain:&lt;span class=&quot;string&quot;&gt;@&quot;FishDomain&quot;&lt;/span&gt; code:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; userInfo:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;ARC 会将 &lt;code&gt;(NSError **)error&lt;/code&gt; 这种 “out-parameter” 隐式修饰为 &lt;code&gt;__autoreleasing&lt;/code&gt;，也就是其实会被转化成 &lt;code&gt;(NSError * __autoreleasing *)error&lt;/code&gt;。（PS：相关知识参考 &lt;a href=&quot;http://clang.llvm.org/docs/AutomaticReferenceCounting.html#indirect-parameters&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Indirect parameters&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;给 &lt;code&gt;*error&lt;/code&gt; 赋值时，因为它被 &lt;code&gt;__autoreleasing&lt;/code&gt; 修饰，所以 ARC 下的 Clang 会隐式调用 &lt;code&gt;retain&lt;/code&gt; 和 &lt;code&gt;autorelease&lt;/code&gt;。 PS: 相关知识参考 &lt;a href=&quot;http://clang.llvm.org/docs/AutomaticReferenceCounting.html#semantics&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Semantics&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;而 &lt;code&gt;enumerateKeysAndObjectsUsingBlock:&lt;/code&gt; 方法会在 &lt;code&gt;@autoreleasepool&lt;/code&gt; 里面执行 Block，在迭代逻辑中这样做有助于减少内存峰值。&lt;/p&gt;
&lt;p&gt;于是 &lt;code&gt;*error&lt;/code&gt; 就在 Block 里提前被释放了。Xcode 9 会针对这种情况发出 warning：”Block captures an autoreleasing out-parameter, which may result in use-after-free bugs”。解决方案：”Declare the parameter &lt;strong&gt;strong or capture a &lt;/strong&gt;block __strong variable to keep values alive across autorelease pools”&lt;/p&gt;
&lt;p&gt;第一个解决方案简单地把参数 &lt;code&gt;(NSError **)error&lt;/code&gt; 改成 &lt;code&gt;(NSError *__strong *)error&lt;/code&gt;，这要求调用方也使用 ARC。第二个解决方案是利用 &lt;code&gt;__block&lt;/code&gt; 让 Block 捕获外部变量，默认是强引用：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)validateDictionary:(&lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *, &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *&amp;gt; *)dict error:(&lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; **)error&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __block &lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; *strongError = &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [dict enumerateKeysAndObjectsUsingBlock:^(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; * _Nonnull key, &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; * _Nonnull obj, &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; * _Nonnull stop) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (obj.length &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            strongError = [&lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; errorWithDomain:&lt;span class=&quot;string&quot;&gt;@&quot;FishDomain&quot;&lt;/span&gt; code:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; userInfo:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (error) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        *error = strongError;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;关于 Clang 隐式调用 &lt;code&gt;retain&lt;/code&gt; 和 &lt;code&gt;autorelease&lt;/code&gt; 更深入的细节如下：&lt;/p&gt;
&lt;h4 id=&quot;Clang-5-中的-Objective-C-ARC-方法家族&quot;&gt;&lt;a href=&quot;#Clang-5-中的-Objective-C-ARC-方法家族&quot; class=&quot;headerlink&quot; title=&quot;Clang 5 中的 Objective-C ARC 方法家族&quot;&gt;&lt;/a&gt;Clang 5 中的 Objective-C ARC 方法家族&lt;/h4&gt;&lt;p&gt;Objective-C 中有&lt;a href=&quot;http://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-method-families&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;五大方法家族&lt;/a&gt;，每个家族都有自己的规矩：&lt;code&gt;alloc/new/copy/mutableCopy&lt;/code&gt; 四个家族的方法返回的是 “a retainable object pointer”，而 &lt;code&gt;init&lt;/code&gt; 家族方法要求必须是实例方法，必须返回 Objective-C 对象。&lt;/p&gt;
&lt;p&gt;把一个方法划归到某个方法家族有两种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;按照命名惯例划分方法家族&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;__attribute__((objc_method_family( somefamily )))&lt;/code&gt; 直接指定&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果某个方法不遵循所在家族的规矩，会影响到内存管理，造成内存泄露等后果。（PS：如果是使用第二种方式把不守规矩的方法划归到家族，Clang 会报错。）&lt;/p&gt;
&lt;p&gt;ARC 下遵循一套内存管理原则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;alloc/new/copy/mutableCopy&lt;/code&gt; 家族的方法创建的对象是自己持有的，会被 Clang 隐式标记为 &lt;code&gt;__attribute__((ns_returns_retained))&lt;/code&gt;。等效于 Foundation 中的宏 &lt;code&gt;NS_RETURNS_RETAINED&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;init&lt;/code&gt; 家族会被 Clang 隐式标记为 &lt;code&gt;__attribute__((ns_consumes_self))&lt;/code&gt; 和 &lt;code&gt;__attribute__((ns_returns_retained))&lt;/code&gt;，用 &lt;code&gt;NS_REPLACES_RECEIVER&lt;/code&gt; 宏也是等效的。&lt;/li&gt;
&lt;li&gt;不属于任何方法家族的方法会被 Clang 隐式标记为 &lt;code&gt;__attribute__((ns_returns_not_retained))&lt;/code&gt;，等效于 Foundation 中的宏 &lt;code&gt;NS_RETURNS_NOT_RETAINED&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般情况下 Clang 会帮我们做这些事情，不必给方法声明手动标记这些属性。而且 Clang 会对最终生成的汇编指令进行优化，去掉多余的 &lt;code&gt;retain&lt;/code&gt; 和 &lt;code&gt;autorelease&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;ARC 会&lt;strong&gt;视情况&lt;/strong&gt;在调用方法时&lt;strong&gt;可能会&lt;/strong&gt;添加 &lt;code&gt;retain&lt;/code&gt;，在方法内部返回时&lt;strong&gt;可能会&lt;/strong&gt;添加 &lt;code&gt;autorelease&lt;/code&gt;，经过优化后很可能会抵消。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;__attribute__&lt;/code&gt; 其实并不是 Objective-C 的语法，而是 Clang 的属性。有关 Clang 的各种属性定义，请查看 &lt;a href=&quot;http://clang.llvm.org/docs/AttributeReference.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Attributes in Clang&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;探索方法返回值内存管理的奥秘&quot;&gt;&lt;a href=&quot;#探索方法返回值内存管理的奥秘&quot; class=&quot;headerlink&quot; title=&quot;探索方法返回值内存管理的奥秘&quot;&gt;&lt;/a&gt;探索方法返回值内存管理的奥秘&lt;/h4&gt;&lt;p&gt;先做两种情况的实验，查看汇编代码，并总结：&lt;/p&gt;
&lt;h5 id=&quot;方法为-alloc-new-copy-mutableCopy-家族或方法声明使用-NS-RETURNS-RETAINED&quot;&gt;&lt;a href=&quot;#方法为-alloc-new-copy-mutableCopy-家族或方法声明使用-NS-RETURNS-RETAINED&quot; class=&quot;headerlink&quot; title=&quot;方法为 alloc/new/copy/mutableCopy 家族或方法声明使用 NS_RETURNS_RETAINED&quot;&gt;&lt;/a&gt;方法为 &lt;code&gt;alloc/new/copy/mutableCopy&lt;/code&gt; 家族或方法声明使用 &lt;code&gt;NS_RETURNS_RETAINED&lt;/code&gt;&lt;/h5&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)newFoo;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)foo &lt;span class=&quot;built_in&quot;&gt;NS_RETURNS_RETAINED&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)newFoo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)foo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;debug 时从汇编中可以看出：调用方无操作，方法返回时无操作。这显然是优化后的结果。虽然两种方式都能达到优化效果，但更推荐采用让方法加入方法家族，而不是直接使用 &lt;code&gt;NS_RETURNS_RETAINED&lt;/code&gt; 宏。&lt;/p&gt;
&lt;h5 id=&quot;普通方法&quot;&gt;&lt;a href=&quot;#普通方法&quot; class=&quot;headerlink&quot; title=&quot;普通方法&quot;&gt;&lt;/a&gt;普通方法&lt;/h5&gt;&lt;figure class=&quot;highlight haml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-&lt;span class=&quot;ruby&quot;&gt; (id)foo;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-&lt;span class=&quot;ruby&quot;&gt; (id)foo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return [NSObject new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;debug 时从汇编中可以看出：调用方调用 &lt;code&gt;objc_retainAutoreleasedReturnValue()&lt;/code&gt;，方法返回时调用 &lt;code&gt;objc_autoreleaseReturnValue()&lt;/code&gt;（如果返回值没有赋值给变量，会调用 &lt;code&gt;objc_unsafeClaimAutoreleasedReturnValue()&lt;/code&gt;）。&lt;/p&gt;
&lt;h5 id=&quot;优化过程及原理&quot;&gt;&lt;a href=&quot;#优化过程及原理&quot; class=&quot;headerlink&quot; title=&quot;优化过程及原理&quot;&gt;&lt;/a&gt;优化过程及原理&lt;/h5&gt;&lt;p&gt;&lt;code&gt;objc_retainAutoreleasedReturnValue(value)&lt;/code&gt; 会尝试将之前调用 &lt;code&gt;objc_autoreleaseReturnValue(value)&lt;/code&gt; 时传入参数 &lt;code&gt;value&lt;/code&gt; 的所有权（retain count）传递过来。如果没有在 &lt;code&gt;value&lt;/code&gt; 上调用过 &lt;code&gt;objc_autoreleaseReturnValue(value)&lt;/code&gt;，那就调用 &lt;code&gt;retain&lt;/code&gt;。具体原理通过查看 Objective-C 源码可以得出(我列举的是 objc-709)：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;objc_autoreleaseReturnValue()&lt;/code&gt; 试图优化流程，如果上一层调用方会调用 &lt;code&gt;objc_retainAutoreleasedReturnValue()&lt;/code&gt; 则直接返回参数，否则调用 &lt;code&gt;autorelease&lt;/code&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;id &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;objc_autoreleaseReturnValue&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;id obj&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// ReturnAtPlus1 表示倾向直接把对象返回，这样就不需要调用 objc_autorelease()，优化性能&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (prepareOptimizedReturn(ReturnAtPlus1)) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; obj;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; objc_autorelease(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; ALWAYS_INLINE &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;prepareOptimizedReturn&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;ReturnDisposition disposition&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    assert(getReturnDisposition() == ReturnAtPlus0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// __builtin_return_address(0) 获取当前函数返回地址，传入 callerAcceptsOptimizedReturn 判断调用方是否紧接着调用了 objc_retainAutoreleasedReturnValue 或者 objc_unsafeClaimAutoreleasedReturnValue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (callerAcceptsOptimizedReturn(__builtin_return_address(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;))) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 将标志位 disposition 写入 TLS&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (disposition) setReturnDisposition(disposition);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; ALWAYS_INLINE &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;setReturnDisposition&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;ReturnDisposition disposition&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;span class=&quot;comment&quot;&gt;// 向 TLS 中写入 Disposition&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    tls_set_direct(RETURN_DISPOSITION_KEY, (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;*)(uintptr_t)disposition);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; ALWAYS_INLINE ReturnDisposition &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;getReturnDisposition&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;span class=&quot;comment&quot;&gt;// 从 TLS 中读取 Disposition&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (ReturnDisposition)(uintptr_t)tls_get_direct(RETURN_DISPOSITION_KEY);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;callerAcceptsOptimizedReturn()&lt;/code&gt; 函数在不同架构的 CPU 上实现也是不一样的，这是因为不同架构 CPU 的对齐方式不同，偏移量也不同。比如在 arm64 上由于指令对齐方式较好，只需判断函数返回的地址指向的值是不是 &lt;code&gt;0xaa1d03fd&lt;/code&gt; 即可；而在 x86_64 平台上则要用一大坨代码来判断。有兴趣的可以查看 objc-object.h 文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;objc_retainAutoreleasedReturnValue()&lt;/code&gt; 试图查看是否已优化过并直接返回参数，否则 &lt;code&gt;retain&lt;/code&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;id&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;objc_retainAutoreleasedReturnValue&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;id obj&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;   &lt;span class=&quot;comment&quot;&gt;// 如果之前 objc_autoreleaseReturnValue() 存入的标志位为 ReturnAtPlus1，则直接返回对象，无需调用 objc_retain()，优化性能&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (acceptOptimizedReturn() == ReturnAtPlus1) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; obj;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; objc_retain(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 负责从 TLS 中取标志位 ReturnDisposition，然后将其重置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; ALWAYS_INLINE ReturnDisposition &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;acceptOptimizedReturn&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ReturnDisposition disposition = getReturnDisposition();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setReturnDisposition(ReturnAtPlus0);  &lt;span class=&quot;comment&quot;&gt;// reset to the unoptimized state&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; disposition;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;TLS 全称为 Thread Local Storage，是每个线程专有的键值存储。在某个线程上的函数调用栈上相邻两个函数对 TLS 进行了存取，这中间肯定不会有别的程序『插手』。所以 &lt;code&gt;getReturnDisposition()&lt;/code&gt; 和 &lt;code&gt;setReturnDisposition()&lt;/code&gt; 的实现比较简单，不需要判断考虑是针对哪个对象的 Disposition 进行存取，因为当前线程上下文中只处理唯一的对象，保证不会乱掉。&lt;/p&gt;
&lt;h3 id=&quot;无参数函数的声明&quot;&gt;&lt;a href=&quot;#无参数函数的声明&quot; class=&quot;headerlink&quot; title=&quot;无参数函数的声明&quot;&gt;&lt;/a&gt;无参数函数的声明&lt;/h3&gt;&lt;p&gt;如果函数没有参数，需要用 &lt;code&gt;void&lt;/code&gt; 显式声明。否则可能调用方会传入其他类型和数量的参数，在运行时引发 crash。如果用 &lt;code&gt;void&lt;/code&gt; 显式声明，在编译阶段就会产生 error。&lt;/p&gt;
&lt;figure class=&quot;highlight arduino&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; foo() &lt;span class=&quot;comment&quot;&gt;// warning:This function declaration is not a prototype&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; foo(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// OK&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;C-Refactoring&quot;&gt;&lt;a href=&quot;#C-Refactoring&quot; class=&quot;headerlink&quot; title=&quot;C++ Refactoring&quot;&gt;&lt;/a&gt;C++ Refactoring&lt;/h2&gt;&lt;p&gt;对于一个带有 C++ 或 Objective-C++ 代码的工程来说，想重命名某个类名真的是艰难，Xcode 会提示不支持 C++！现在，各种操作也支持 C++ 咯：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://yulingtianxia.com/resources/LLVM/C++%20Refactoring.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;LLVM 的重构代码功能极大节省了开发者的时间。&lt;/p&gt;
&lt;h2 id=&quot;Features-from-C-17&quot;&gt;&lt;a href=&quot;#Features-from-C-17&quot; class=&quot;headerlink&quot; title=&quot;Features from C++17&quot;&gt;&lt;/a&gt;Features from C++17&lt;/h2&gt;&lt;p&gt;其实这些都是 C++17 的新特性罢了，LLVM 9.0 积极响应支持。可以在编译选项 C++ Language Dialect 中选择使用的 C++ 标准库。GNU++17 比 C++17 多了语言扩展。&lt;/p&gt;
&lt;h3 id=&quot;Structured-Binding&quot;&gt;&lt;a href=&quot;#Structured-Binding&quot; class=&quot;headerlink&quot; title=&quot;Structured Binding&quot;&gt;&lt;/a&gt;Structured Binding&lt;/h3&gt;&lt;p&gt;解析 Tuple 可以一句搞定了：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::tuple&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;&amp;gt; compute();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;auto&lt;/span&gt; [a, b, c] = compute();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;甚至也可以解析类似 tuple 的类型：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; Point &amp;#123; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; x; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; y; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; z; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;Point &lt;span class=&quot;title&quot;&gt;computeMidPoint&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Point p1, Point p2)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;auto&lt;/span&gt; [x, y, z] = computeMidPoint(src, dest);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;更多内容详见 C++17 的 &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0217r3.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Stuctured Binding&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;在条件判断语句中声明初始化变量&quot;&gt;&lt;a href=&quot;#在条件判断语句中声明初始化变量&quot; class=&quot;headerlink&quot; title=&quot;在条件判断语句中声明初始化变量&quot;&gt;&lt;/a&gt;在条件判断语句中声明初始化变量&lt;/h3&gt;&lt;p&gt;在判断某个条件之前，可能会产生一些中间变量，如果变量名与外界的有冲突，还会造成一些影响。所以需要一种只在条件判断语句范围内生效的局部变量，避免与无关逻辑代码有冲突：&lt;/p&gt;
&lt;figure class=&quot;highlight gcode&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;(auto a = getNumber()&lt;/span&gt;; a &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	foo&lt;span class=&quot;comment&quot;&gt;()&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// error! a 只在上面的 if 作用域中有效。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;constexpr-if&quot;&gt;&lt;a href=&quot;#constexpr-if&quot; class=&quot;headerlink&quot; title=&quot;constexpr if&quot;&gt;&lt;/a&gt;constexpr if&lt;/h3&gt;&lt;p&gt;以 &lt;code&gt;if constexpr&lt;/code&gt; 开始的语句被称为 &lt;code&gt;constexpr if&lt;/code&gt; 语句。– &lt;a href=&quot;http://zh.cppreference.com/w/cpp/language/if&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;cppreference.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;code&gt;advance&lt;/code&gt; 函数可以向前或向后迭代指定步数，但对于字符串和数组来说有更快的方式：无需一步步迭代，可以直接访问。但 &lt;code&gt;advance&lt;/code&gt; 的参数是通用的，编译不通过：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://yulingtianxia.com/resources/LLVM/constexpr%20if%200.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;传统解决方法是 Compile Time Dispatch：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://yulingtianxia.com/resources/LLVM/constexpr%20if%201.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;C++17 的 &lt;code&gt;constexpr if&lt;/code&gt; 可以一行搞定：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://yulingtianxia.com/resources/LLVM/constexpr%20if%202.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;详见 &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0292r2.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;constexpr if&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;string-view&quot;&gt;&lt;a href=&quot;#string-view&quot; class=&quot;headerlink&quot; title=&quot;string_view&quot;&gt;&lt;/a&gt;string_view&lt;/h3&gt;&lt;p&gt;简单来说它是指向字符串的指针，但不会拷贝一份字符串。一旦指向的字符串被修改或者被释放了，&lt;code&gt;string_view&lt;/code&gt; 的内容也会跟跟着变，毕竟是同一份内存。所以，虽然会优化性能，慎用。就像 OC 中的字符串和数组传递赋值时一般都 &lt;code&gt;copy&lt;/code&gt;，string_view 相当于是 &lt;code&gt;assign&lt;/code&gt;，搞不好野指针呢。&lt;/p&gt;
&lt;p&gt;详见 &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html#string.view&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;string_view&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;Link-Time-Optimization&quot;&gt;&lt;a href=&quot;#Link-Time-Optimization&quot; class=&quot;headerlink&quot; title=&quot;Link-Time Optimization&quot;&gt;&lt;/a&gt;Link-Time Optimization&lt;/h2&gt;&lt;p&gt;去年搞了个 LTO 和 增量 LTO，今年优化得编译速度更快了，于是建议我们打开 增量 LTO 啊：在编译选项中 Code Generation-&amp;gt;Link-Time Optimization&lt;/p&gt;
&lt;p&gt;其实我看了 &lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2016/405/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;2016 年的 What’s New in LLVM&lt;/a&gt;, LTO 确实占了很大篇幅，不过当时还不建议开启。经过一年的优化后算是修成正果了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这&lt;strong&gt;绝不仅仅&lt;/strong&gt;是一篇 WWDC 2017 Session 411 学习笔记。除了有关 LLVM  9.0 的新特性之外，还有关于静态分析器和 Clang 5 Objective-C ARC 的一点看法和经验。&lt;/p&gt;
&lt;p&gt;我觉得 LLVM 9 的亮点如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;支持 Objective-C API 可用性检查&lt;/li&gt;
&lt;li&gt;新增一些对隐患代码的静态分析检查和 warning&lt;/li&gt;
&lt;li&gt;更快的 LTO，使其可以真正使用&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yulingtianxia.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Core ML and Vision Framework on iOS 11</title>
    <link href="http://yulingtianxia.com/blog/2017/06/19/Core-ML-and-Vision-Framework-on-iOS-11/"/>
    <id>http://yulingtianxia.com/blog/2017/06/19/Core-ML-and-Vision-Framework-on-iOS-11/</id>
    <published>2017-06-19T02:05:41.000Z</published>
    <updated>2018-09-15T08:28:13.748Z</updated>
    
    <content type="html">&lt;p&gt;机器学习和计算机视觉在 iOS 上虽然早已有了系统级的支持，但 WWDC 17 发布的 iOS 11 将它们的使用门槛大大降低。苹果提供了设计合理且容易上手的 API，让那些对基础理论知识一窍不通的门外汉也能玩转高大上的前沿科技，这是苹果一贯的风格。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;这是一篇 WWDC 2017 Session 506，608，703 和 710 的学习笔记，以及分享自己尝试写的 Demo &lt;a href=&quot;https://github.com/yulingtianxia/Core-ML-Sample&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Core-ML-Sample&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yulingtianxia/Core-ML-Sample/blob/master/coreml.gif?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Core-ML&quot;&gt;&lt;a href=&quot;#Core-ML&quot; class=&quot;headerlink&quot; title=&quot;Core ML&quot;&gt;&lt;/a&gt;Core ML&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;Core ML 大大降低了开发者在苹果设备上使用机器学习技术预测模型的门槛和成本。苹果制定了自己的模型文件格式，统一的格式和全新的 API 设计使得 Core ML 支持苹果生态下多个平台。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://yulingtianxia.com/resources/iOS11/coreml1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;将数据经过预处理后输入 MLMODEL 文件，输出为模型的预测结果。使用 Core ML 只需要很少的代码就可以构建起一个机器学习的应用。只需关注代码即可，无需关注模型的定义，网络的构成。这跟以前写 MPS 代码时构成了强烈的反差：开发者需要写大量 MPS 代码用于构建和描述一个完整的网络，而加载的文件仅仅是模型的权重而已。MLMODEL 文件包含了权重和模型结构等信息，并可以自动生成相关的代码，节省开发者大量时间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://yulingtianxia.com/resources/iOS11/coreml2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Model-转换工具&quot;&gt;&lt;a href=&quot;#Model-转换工具&quot; class=&quot;headerlink&quot; title=&quot;Model 转换工具&quot;&gt;&lt;/a&gt;Model 转换工具&lt;/h3&gt;&lt;p&gt;苹果提供了一个 Python 工具，可以将业内一些常用的机器学习框架导出的 Model 转成 MLMODEL 文件。代码会编译成可执行二进制文件，而 MLMODEL 会编译成 Bundle 文件，在代码文件中可以直接调用 MLMODEL 生成的类，这些都是需要 Xcode 9 做支撑，也就是说，现阶段并不支持动态下发 MLMODEL 文件。Core ML 的预测过程全都在客户端进行，保证用户隐私不会泄露。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://yulingtianxia.com/resources/iOS11/coreml4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Core ML 支持 DNN,RNN,CNN,SVM,Tree ensembles,Generalized linear models,Pipeline models 等，对应的模型转换工具 &lt;a href=&quot;https://pypi.python.org/pypi/coremltools&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Core ML Tools&lt;/a&gt; 也支持了一些常用机器学习框架模型的转换。虽然目前没有直接支持 Google 的 TensorFlow，但可以使用 Keras 曲线救国。&lt;code&gt;coremltools&lt;/code&gt; 已经开源，并提供可拓展性的底层接口，可以编写适配其他机器学习框架模型的转换工具。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://yulingtianxia.com/resources/iOS11/coreml3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;MLMODEL 文件中还包含了很多元数据，比如作者，License，输入输出的描述文字。这些元数据都可以通过 &lt;code&gt;coremltools&lt;/code&gt; 的接口进行设置。&lt;code&gt;coremltools&lt;/code&gt; 上手很简单，可以查看完整详细的&lt;a href=&quot;https://pythonhosted.org/coremltools/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;使用文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;把 MLMODEL 文件拖拽到 Xcode 工程中后，记得要勾选对应的 target，这样 Xcode 才会自动生成对应的代码。生成的类名就是 MLMODEL 文件名，输入和输出的变量名和类型也可以在 Xcode 中查看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://yulingtianxia.com/resources/iOS11/coreml5.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;底层计算性能&quot;&gt;&lt;a href=&quot;#底层计算性能&quot; class=&quot;headerlink&quot; title=&quot;底层计算性能&quot;&gt;&lt;/a&gt;底层计算性能&lt;/h3&gt;&lt;p&gt;Core ML 的底层是 Accelerate BNNS 和 MPS，并可以根据实际情况进行无缝切换。比如在处理图片的场景下使用 MPS，处理文字场景下使用 Accelerate，甚至可以在同一个 model 的不同层使用不同的底层技术来预测。Vision 和 NLP 可以结合 Core ML 一起使用。Core ML 对硬件做了性能优化，而且支持的模型种类更多，开发者不用关注底层的一些细节，苹果全都封装好了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://yulingtianxia.com/resources/iOS11/coreml6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当然，这些也都是建立在 MPS 更新的基础上，MPS 在 iOS 11 中拓展了支持向量和矩阵的数据结构 &lt;code&gt;MPSVector&lt;/code&gt; 与 &lt;code&gt;MPSMatrix&lt;/code&gt;，以及它们之间相乘的 API。而且提供了更多的神经网络类型（比如 RNN 等），在卷积神经网络中也提供了更多种类的卷积核，用于满足更多特殊场景。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://yulingtianxia.com/resources/iOS11/608_using_metal_2_for_compute_%E9%A1%B5%E9%9D%A2_065.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;苹果在 Metal 2 中补充 MPS 大量功能的同时，也提供了用于描述神经网络结构的语言：Neural Network Graph API。使用它可以极大简化代码逻辑，代码量缩减到以前的四分之一（以 Inception V3 为例）。并且使用 NN Graph API 可以并行使用 CPU 和 GPU。这种图语言跟主流的分布式机器学习框架的使用很像：先用简单的 Python 语言描述好网络结构，定义好输入输出格式，然后一次性提交到后端去执行。后端对底层性能做了很多细节优化，然而开发者完全不用关心这些。新增的 &lt;code&gt;MPSNNGraph&lt;/code&gt; 提供了异步接口使得 CPU 不用再等待 GPU 的执行结果，性能也得到提升。&lt;/p&gt;
&lt;p&gt;Metal 2 使用 MPS 进行图像处理的性能也得到了提升，在不同的设备上大约提升了百分之二十多。&lt;/p&gt;
&lt;h3 id=&quot;Demo-数据预处理&quot;&gt;&lt;a href=&quot;#Demo-数据预处理&quot; class=&quot;headerlink&quot; title=&quot;Demo: 数据预处理&quot;&gt;&lt;/a&gt;Demo: 数据预处理&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/yulingtianxia/Core-ML-Sample&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Core-ML-Sample&lt;/a&gt; 使用了 Core ML 和 Vision 技术实现对摄像头拍摄的图像实时预测物体种类。因为图像来源是摄像头，所以需要将 &lt;code&gt;CMSampleBuffer&lt;/code&gt; 转成 &lt;code&gt;CVPixelBuffer&lt;/code&gt;。因为 Xcode 9 已经生成好了代码，直接调用 &lt;code&gt;Inceptionv3&lt;/code&gt; 类的 &lt;code&gt;prediction&lt;/code&gt; 方法即可完成预测。生成的 &lt;code&gt;Inceptionv3Output&lt;/code&gt; 类含有 &lt;code&gt;classLabel&lt;/code&gt; 和 &lt;code&gt;classLabelProbs&lt;/code&gt; 两个属性，可以获取预测的分类标签名以及每种标签的可能性。可以点击 Xcode Model View 中 Model Class 的生成源码箭头来查看这些类的信息。&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; inceptionv3model = &lt;span class=&quot;type&quot;&gt;Inceptionv3&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;handleImageBufferWithCoreML&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(imageBuffer: CMSampleBuffer)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; pixelBuffer = &lt;span class=&quot;type&quot;&gt;CMSampleBufferGetImageBuffer&lt;/span&gt;(imageBuffer) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; prediction = &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.inceptionv3model.prediction(image: &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.resize(pixelBuffer: pixelBuffer)!)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;type&quot;&gt;DispatchQueue&lt;/span&gt;.main.async &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; prob = prediction.classLabelProbs[prediction.classLabel] &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.predictLabel.text = &lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;subst&quot;&gt;\(prediction.classLabel)&lt;/span&gt; &lt;span class=&quot;subst&quot;&gt;\(String(describing: prob)&lt;/span&gt;)&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; error &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;NSError&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;built_in&quot;&gt;fatalError&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Unexpected error ocurred: &lt;span class=&quot;subst&quot;&gt;\(error.localizedDescription)&lt;/span&gt;.&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 Xcode Model View 中可以看到 Inceptionv3 模型的输入图片为 &lt;code&gt;Image&amp;lt;RGB,299,299&amp;gt;&lt;/code&gt;，所以需要对摄像头采集到的图像进行预处理。我的转换流程是：&lt;code&gt;CVPixelBuffer-&amp;gt;CVPixelBuffer-&amp;gt;CIImage-&amp;gt;CIImage(resized)-&amp;gt;CVPixelBuffer&lt;/code&gt;。最后一步 &lt;code&gt;CIImage&lt;/code&gt; 转 &lt;code&gt;CVPixelBuffer&lt;/code&gt; 是通过 &lt;code&gt;CIContext&lt;/code&gt; 渲染完成。&lt;/p&gt;
&lt;figure class=&quot;highlight aspectj&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/// resize CVPixelBuffer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;///&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/// - Parameter pixelBuffer: CVPixelBuffer by camera output&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/// - Returns: CVPixelBuffer with size (299, 299)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func resize(pixelBuffer: CVPixelBuffer) -&amp;gt; CVPixelBuffer? &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   let imageSide = &lt;span class=&quot;number&quot;&gt;299&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   var ciImage = CIImage(cvPixelBuffer: pixelBuffer, options: nil)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   let transform = CGAffineTransform(scaleX: CGFloat(imageSide) / CGFloat(CVPixelBufferGetWidth(pixelBuffer)), y: CGFloat(imageSide) / CGFloat(CVPixelBufferGetHeight(pixelBuffer)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   ciImage = ciImage.applying(transform).cropping(to: CGRect(x: 0, y: 0, width: imageSide, height: imageSide))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   let ciContext = CIContext()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   var resizeBuffer: CVPixelBuffer?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   CVPixelBufferCreate(kCFAllocatorDefault, imageSide, imageSide, CVPixelBufferGetPixelFormatType(pixelBuffer), nil, &amp;amp;resizeBuffer)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   ciContext.render(ciImage, to: resizeBuffer!)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; resizeBuffer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;除了图片需要预处理外，其他数据可能也需要预处理。这需要看训练的模型的输入是什么形式，比如分析一段文本所表达的情绪是开心还是沮丧，可能需要写个预处理程序统计词频，然后输入到训练好的模型中进行预测。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Model 极速集成&lt;/li&gt;
&lt;li&gt;支持多种数据类型&lt;/li&gt;
&lt;li&gt;硬件优化&lt;/li&gt;
&lt;li&gt;适配主流机器学习框架&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Vision&quot;&gt;&lt;a href=&quot;#Vision&quot; class=&quot;headerlink&quot; title=&quot;Vision&quot;&gt;&lt;/a&gt;Vision&lt;/h2&gt;&lt;h3 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;#应用场景&quot; class=&quot;headerlink&quot; title=&quot;应用场景&quot;&gt;&lt;/a&gt;应用场景&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;人脸检测：支持检测笑脸、侧脸、局部遮挡脸部、戴眼镜和帽子等场景，可以标记出人脸的矩形区域&lt;/li&gt;
&lt;li&gt;人脸特征点：可以标记出人脸和眼睛、眉毛、鼻子、嘴、牙齿的轮廓，以及人脸的中轴线&lt;/li&gt;
&lt;li&gt;图像配准&lt;/li&gt;
&lt;li&gt;矩形检测&lt;/li&gt;
&lt;li&gt;二维码/条形码检测&lt;/li&gt;
&lt;li&gt;文字检测&lt;/li&gt;
&lt;li&gt;目标跟踪：脸部，矩形和通用模板&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Vision-使用姿势&quot;&gt;&lt;a href=&quot;#Vision-使用姿势&quot; class=&quot;headerlink&quot; title=&quot;Vision 使用姿势&quot;&gt;&lt;/a&gt;Vision 使用姿势&lt;/h3&gt;&lt;p&gt;将各种功能的 Request 提供给一个 RequestHandler，Handler 持有图片信息，并将处理结果分发给每个 Request 的 completion Block 中。可以从 &lt;code&gt;results&lt;/code&gt; 属性中得到 Observation 数组，然后进行更新 UI 等操作。因为 completion Block 所执行的队列跟 perform request 的队列相同，所以更新 UI 时记得使用主队列。&lt;/p&gt;
&lt;p&gt;Vision 操作流水线分为两类：分析图片和跟踪队列。可以使用图片检测出的物体或矩形结果（Observation）来作为跟踪队列请求（Request）的参数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://yulingtianxia.com/resources/iOS11/506_vision_framework_building_on_core_ml_%E9%A1%B5%E9%9D%A2_36.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://yulingtianxia.com/resources/iOS11/506_vision_framework_building_on_core_ml_%E9%A1%B5%E9%9D%A2_40.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Vision 支持的图片数据类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CVPixelBufferRef&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CGImageRef&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CIImage&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NSURL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NSData&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这几乎涵盖了 iOS 中图片相关的 API，很实用很强大。&lt;/p&gt;
&lt;p&gt;Vision 有三种 resize 图片的方式，无需使用者再次裁切缩放&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;VNImageCropAndScaleOptionCenterCrop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VNImageCropAndScaleOptionScaleFit&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VNImageCropAndScaleOptionScaleFill&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Vision 与 iOS 上其他几种带人脸检测功能框架的对比：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://yulingtianxia.com/resources/iOS11/506_vision_framework_building_on_core_ml_%E9%A1%B5%E9%9D%A2_72.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Demo-与-Core-ML-集成&quot;&gt;&lt;a href=&quot;#Demo-与-Core-ML-集成&quot; class=&quot;headerlink&quot; title=&quot;Demo: 与 Core ML 集成&quot;&gt;&lt;/a&gt;Demo: 与 Core ML 集成&lt;/h3&gt;&lt;p&gt;Core ML 具有更好的性能，Vision 可为其提供图片处理的流程。Core ML 生成的代码中含有 &lt;code&gt;MLModel&lt;/code&gt; 类型的 &lt;code&gt;model&lt;/code&gt; 对象，可以用它初始化 &lt;code&gt;VNCoreMLModel&lt;/code&gt; 对象，这样就将 Core ML 的 Model 集成进 Vision 框架中了：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; requests = [&lt;span class=&quot;type&quot;&gt;VNRequest&lt;/span&gt;]()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setupVision&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; visionModel = &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;? &lt;span class=&quot;type&quot;&gt;VNCoreMLModel&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;: inceptionv3model.model) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;built_in&quot;&gt;fatalError&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;can&#39;t load Vision ML model&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; classificationRequest = &lt;span class=&quot;type&quot;&gt;VNCoreMLRequest&lt;/span&gt;(model: visionModel) &amp;#123; (request: &lt;span class=&quot;type&quot;&gt;VNRequest&lt;/span&gt;, error: &lt;span class=&quot;type&quot;&gt;Error&lt;/span&gt;?) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; observations = request.results &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;no results:&lt;span class=&quot;subst&quot;&gt;\(error!)&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; classifications = observations[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;...&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           .flatMap(&amp;#123; $&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? &lt;span class=&quot;type&quot;&gt;VNClassificationObservation&lt;/span&gt; &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           .&lt;span class=&quot;built_in&quot;&gt;filter&lt;/span&gt;(&amp;#123; $&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;.confidence &amp;gt; &lt;span class=&quot;number&quot;&gt;0.2&lt;/span&gt; &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           .&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;(&amp;#123; &lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;subst&quot;&gt;\($&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;.identifier)&lt;/span&gt; &lt;span class=&quot;subst&quot;&gt;\($&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;.confidence)&lt;/span&gt;&quot;&lt;/span&gt; &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;type&quot;&gt;DispatchQueue&lt;/span&gt;.main.async &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.predictLabel.text = classifications.joined(separator: &lt;span class=&quot;string&quot;&gt;&quot;\n&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   classificationRequest.imageCropAndScaleOption = &lt;span class=&quot;type&quot;&gt;VNImageCropAndScaleOptionCenterCrop&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.requests = [classificationRequest]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的代码实现了 Vision 的工作流，并在 completion Block 中对预测结果进行了处理：从 top5 中筛选可能性大于 0.2 的结果，并转成文本描述。因为所有结果的可能性总和为 1，所以最终的结果不会达到 5 个，实际测试中其实结果往往只有 1-2 个。&lt;/p&gt;
&lt;p&gt;对摄像头传入的每帧图片进行预测。虽然 Vision 帮我们完成了预处理等流程上的工作，但是需要我们传入一些额外的信息。&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;handleImageBufferWithVision&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(imageBuffer: CMSampleBuffer)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; pixelBuffer = &lt;span class=&quot;type&quot;&gt;CMSampleBufferGetImageBuffer&lt;/span&gt;(imageBuffer) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; requestOptions:[&lt;span class=&quot;type&quot;&gt;VNImageOption&lt;/span&gt; : &lt;span class=&quot;type&quot;&gt;Any&lt;/span&gt;] = [:]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; cameraIntrinsicData = &lt;span class=&quot;type&quot;&gt;CMGetAttachment&lt;/span&gt;(imageBuffer, kCMSampleBufferAttachmentKey_CameraIntrinsicMatrix, &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       requestOptions = [.cameraIntrinsics:cameraIntrinsicData]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; imageRequestHandler = &lt;span class=&quot;type&quot;&gt;VNImageRequestHandler&lt;/span&gt;(cvPixelBuffer: pixelBuffer, orientation: &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.exifOrientationFromDeviceOrientation, options: requestOptions)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; imageRequestHandler.perform(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.requests)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(error)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;需要向图片传入 EXIF Orientation 信息：&lt;/p&gt;
&lt;figure class=&quot;highlight crystal&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/&lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt; only support back camera&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var &lt;span class=&quot;symbol&quot;&gt;exifOrientationFromDeviceOrientation:&lt;/span&gt; Int32 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   let &lt;span class=&quot;symbol&quot;&gt;exifOrientation:&lt;/span&gt; DeviceOrientation&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DeviceOrientation&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;Int32&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; top0ColLeft = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; top0ColRight = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; bottom0ColRight = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; bottom0ColLeft = &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; left0ColTop = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; right0ColTop = &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; right0ColBottom = &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; left0ColBottom = &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   switch UIDevice.current.orientation &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; .&lt;span class=&quot;symbol&quot;&gt;portraitUpsideDown:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       exifOrientation = .left0ColBottom&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; .&lt;span class=&quot;symbol&quot;&gt;landscapeLeft:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       exifOrientation = .top0ColLeft&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; .&lt;span class=&quot;symbol&quot;&gt;landscapeRight:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       exifOrientation = .bottom0ColRight&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;symbol&quot;&gt;default:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       exifOrientation = .right0ColTop&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; exifOrientation.rawValue&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;总结-1&quot;&gt;&lt;a href=&quot;#总结-1&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Vision 是一个关于计算机视觉的顶层新框架。&lt;/li&gt;
&lt;li&gt;一个界面，多重跟踪检测&lt;/li&gt;
&lt;li&gt;集成 Core ML 轻松使用自己的 model&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;感受&quot;&gt;&lt;a href=&quot;#感受&quot; class=&quot;headerlink&quot; title=&quot;感受&quot;&gt;&lt;/a&gt;感受&lt;/h2&gt;&lt;p&gt;苹果为开发者带来了炫酷的功能，并且这些示例很有针对性，更实用。Vision 更像是一个工具库，对一些高频场景进行了封装，比如人脸、条形码、矩形和文字等，这些基于底层 API 封装的高级功能可以帮助开发者很快地完成老板的功能。而 Core ML 给出的 Model 也很有代表性，贴近实际应用场景，很容易激发开发者使用的热情。我想这正是苹果最擅长的，把复杂的事情简单化，提供极易上手的 Demo，并循序渐进，给予开发者更高深的玩法，不失拓展性和定制化。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;coremltools&lt;/code&gt; 肯定还存在一些兼容性问题，并且会随着各大机器学习框架的更新而不断更新，我想这也是为何苹果将其开源的原因吧。使用 python 也更方便维护，而且主流的机器学习框架都是用 python 作为前端语言。&lt;/p&gt;
&lt;p&gt;Core ML 功能强大，支持的模型种类很多。与此同时，MPS 在 iOS 11 也得到了升级，新增的数据类型更方便使用。总之其实还是新增了对底层数据和算法的封装，然后 Core ML 在此基础上又进行了一层高级的封装。可以看出苹果这一年在底层下的功夫确实不少，在这之后才有了更强大更全面的 API。我预测在这之后 Core ML 还会有更多的模型得到支持，Vision 也会加入更丰富的应用场景。&lt;/p&gt;
&lt;p&gt;如果苹果能够发挥硬件上性能的优势，可能在以后还会演示出更炫酷的 Demo，比如视频实时防抖的处理，更牛逼的滤镜效果。对高性能计算和 GPU 图像处理感兴趣的话，推荐看下 Metal 2 相关的 Session，尤其是 Session 608。&lt;/p&gt;
&lt;p&gt;同时也会发现苹果在机器学习的道路上避开了各个训练框架的锋芒，尤其是最近大红大紫的 Google TensorFlow。它选择另辟蹊径，在移动端模型预测性能优化和低成本接入的道路上另辟蹊径，充分发挥自身平台的优势。毕竟在移动端训练模型意义较小，还是交给服务端比较合理。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;机器学习和计算机视觉在 iOS 上虽然早已有了系统级的支持，但 WWDC 17 发布的 iOS 11 将它们的使用门槛大大降低。苹果提供了设计合理且容易上手的 API，让那些对基础理论知识一窍不通的门外汉也能玩转高大上的前沿科技，这是苹果一贯的风格。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yulingtianxia.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Implementing CNN with MPS</title>
    <link href="http://yulingtianxia.com/blog/2017/05/30/Implementing-CNN-with-MPS/"/>
    <id>http://yulingtianxia.com/blog/2017/05/30/Implementing-CNN-with-MPS/</id>
    <published>2017-05-30T09:20:32.000Z</published>
    <updated>2018-09-15T08:28:13.821Z</updated>
    
    <content type="html">&lt;p&gt;最近一个月从零开始自学了下有关 iOS 上的机器学习相关知识，亲身实践了从数据采集到训练模型再到移动端预测的流程。理论知识学习路径为：&lt;strong&gt;机器学习-&amp;gt;深度学习-&amp;gt;迁移学习&lt;/strong&gt;；实践框架学习路径为：&lt;strong&gt;TensorFlow-&amp;gt;Keras-&amp;gt;MPS(iOS 10)&lt;/strong&gt;。最终完成一个简单的手势图像五分类问题，并预测 iOS 摄像头采集的图片。最终结果，训练集准确率 96.26%，交叉验证集准确率 73.86%。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;理论基础&quot;&gt;&lt;a href=&quot;#理论基础&quot; class=&quot;headerlink&quot; title=&quot;理论基础&quot;&gt;&lt;/a&gt;理论基础&lt;/h2&gt;&lt;p&gt;虽然结果导向很重要，但是我还是想从基础学起，而不是去急于去网上找现成的解决方案来调参。毕竟我的目的是拓宽知识面，开新的技能树。&lt;/p&gt;
&lt;p&gt;第一周从零开始学习了 Coursera 上 Stanford Ng 教授的 &lt;a href=&quot;https://www.coursera.org/learn/machine-learning/home&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Machine Learning&lt;/a&gt; 经典课程，用 Matlab 编写了一些 Demo，用一周时间完成了原本需要 11 周时间的所有课程和考试，对机器学习的基础知识有了掌握。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wx3.sinaimg.cn/mw1024/642c5793ly1ff5ornniluj21kw0u3tn2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;机器学习大体可以分为有监督学习和无监督学习。带标签数据的有监督学习包含从最简单的线性回归到逻辑回归，再到神经网络和 SVM（支持向量机）。无监督学习包含大学竖直的 K-means 聚类，PCA(Principal Components Analysis) 降维。以及带标签数据的异常检测算法。为了确保机器学习的效果，需要通过看懂学习曲线决定下一步的工作，是解决 overfit 还是 underfit。使用交叉验证集和测试集评估模型时，如何平衡准确率和召回率，比如 F1 Score 指标。在数据预处理上要了解一些数据归一化标准化的方法。&lt;/p&gt;
&lt;p&gt;光掌握机器学习的基础知识显然不够，大而全不如专而精。深度学习在图像识别领域大放异彩，其实深度学习是机器学习的一个分支，而深度学习领域最近在图像识别上应用最火的可能就是 CNN 了。所以在狂学深度学习的时候重点研究了下 CNN。&lt;/p&gt;
&lt;h3 id=&quot;卷积神经网络简介&quot;&gt;&lt;a href=&quot;#卷积神经网络简介&quot; class=&quot;headerlink&quot; title=&quot;卷积神经网络简介&quot;&gt;&lt;/a&gt;卷积神经网络简介&lt;/h3&gt;&lt;p&gt;全连接网络权重过多，而卷积神经网络可以实现权值共享，引入了深度，数据为 3D 的。推荐查看 Stanford 的 &lt;a href=&quot;http://cs231n.github.io/convolutional-networks/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Convolutional Neural Networks (CNNs / ConvNets)&lt;/a&gt;，中文翻译：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/22038289&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CS231n课程笔记翻译：卷积神经网络笔记&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;卷积核一般为奇数，常用的都是小卷积核，比如 1x1,3x3,5x5。&lt;a href=&quot;https://zh.wikipedia.org/wiki/卷积&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;卷积&lt;/a&gt;是一种数学运算，卷积核在扫描数据的时候，正好做的就是卷积运算。卷积核其实就是个滤波器，通过平移点积运算处理数据。一个卷积层可以有多个卷积核，也就是多个滤波器，每种滤波器所『感受』的内容不同，结果也很有意思。可以看看这篇文章：&lt;a href=&quot;https://blog.keras.io/how-convolutional-neural-networks-see-the-world.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;How convolutional neural networks see the world&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;CNN 中不仅有 Convolution，还有 Pooling，Activation，Fully Connected等层级。&lt;/p&gt;
&lt;p&gt;Pooling 就是 downsampling，减小数据尺寸，常用的有有 max，average 等运算。&lt;br&gt;Activation 就是激活函数，常用的有 sigmoid，ReLU 等。&lt;br&gt;Fully Connected 也叫 Dense，因为全连接权重密度很大。其实就是个卷积核宽高等于输入数据宽高的特殊卷积层。卷积层和全连接层可以等效转换。&lt;/p&gt;
&lt;p&gt;如果卷积核尺寸不是 1x1，或平移的步长不是 1x1，那么卷积运算后的结果肯定比原尺寸要小，所以padding 规则就很重要。一般常用的『Same』规则就是在数据周围填充一些 0，使得卷积运算后的数据宽和高跟输入数据一样。&lt;/p&gt;
&lt;h3 id=&quot;图片分类常用的数据和预设网络模型&quot;&gt;&lt;a href=&quot;#图片分类常用的数据和预设网络模型&quot; class=&quot;headerlink&quot; title=&quot;图片分类常用的数据和预设网络模型&quot;&gt;&lt;/a&gt;图片分类常用的数据和预设网络模型&lt;/h3&gt;&lt;p&gt;图片分类使用已经打好标签的数据库来进行有监督学习，&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Dataset&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Training Set Size&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Testing Set Size&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Number of Classes&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Comments&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://www.cs.toronto.edu/~kriz/cifar.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Cifar10&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;60k&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;10k&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;10&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;32x32 color&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://yann.lecun.com/exdb/mnist/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MNIST&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;60k&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;10k&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;10&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;28x28 gray&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://www.image-net.org/challenges/LSVRC/2012/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ImageNet&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1.2M&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;50k&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1000&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Various sizes&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href=&quot;http://yann.lecun.com/exdb/mnist/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MNIST&lt;/a&gt; 算是深度学习领域的 HelloWorld 了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cs.toronto.edu/%7Ekriz/cifar.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CIFAR&lt;/a&gt; 小尺寸图片数据库，包含 CIFAR10 和 CIFAR100。&lt;/p&gt;
&lt;p&gt;在图像识别领域，&lt;a href=&quot;http://image-net.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ImageNet&lt;/a&gt; 是非常有名的数据库，历年挑战中都有新的更复杂的神经网络跑出更好的结果。下面的表是一些网络模型在 &lt;a href=&quot;http://image-net.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ImageNet&lt;/a&gt; Challenge 中的准确率以及 TF-Slim 源码和 checkpoint 文件，数据来源：&lt;a href=&quot;https://github.com/tensorflow/models/tree/master/slim&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TensorFlow-Slim image classification library&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Model&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;TF-Slim File&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Checkpoint&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Top-1 Accuracy&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Top-5 Accuracy&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://arxiv.org/abs/1409.4842v1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Inception V1&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://github.com/tensorflow/models/blob/master/slim/nets/inception_v1.py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Code&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://download.tensorflow.org/models/inception_v1_2016_08_28.tar.gz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;inception_v1_2016_08_28.tar.gz&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;69.8&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;89.6&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://arxiv.org/abs/1502.03167&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Inception V2&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://github.com/tensorflow/models/blob/master/slim/nets/inception_v2.py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Code&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://download.tensorflow.org/models/inception_v2_2016_08_28.tar.gz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;inception_v2_2016_08_28.tar.gz&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;73.9&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;91.8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://arxiv.org/abs/1512.00567&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Inception V3&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://github.com/tensorflow/models/blob/master/slim/nets/inception_v3.py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Code&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://download.tensorflow.org/models/inception_v3_2016_08_28.tar.gz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;inception_v3_2016_08_28.tar.gz&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;78.0&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;93.9&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://arxiv.org/abs/1602.07261&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Inception V4&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://github.com/tensorflow/models/blob/master/slim/nets/inception_v4.py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Code&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://download.tensorflow.org/models/inception_v4_2016_09_09.tar.gz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;inception_v4_2016_09_09.tar.gz&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;80.2&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;95.2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://arxiv.org/abs/1602.07261&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Inception-ResNet-v2&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://github.com/tensorflow/models/blob/master/slim/nets/inception_resnet_v2.py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Code&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://download.tensorflow.org/models/inception_resnet_v2_2016_08_30.tar.gz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;inception_resnet_v2.tar.gz&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;80.4&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;95.3&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://arxiv.org/abs/1512.03385&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ResNet V1 50&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://github.com/tensorflow/models/blob/master/slim/nets/resnet_v1.py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Code&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://download.tensorflow.org/models/resnet_v1_50_2016_08_28.tar.gz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;resnet_v1_50.tar.gz&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;75.2&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;92.2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://arxiv.org/abs/1512.03385&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ResNet V1 101&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://github.com/tensorflow/models/blob/master/slim/nets/resnet_v1.py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Code&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://download.tensorflow.org/models/resnet_v1_101_2016_08_28.tar.gz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;resnet_v1_101.tar.gz&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;76.4&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;92.9&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://arxiv.org/abs/1512.03385&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ResNet V1 152&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://github.com/tensorflow/models/blob/master/slim/nets/resnet_v1.py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Code&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://download.tensorflow.org/models/resnet_v1_152_2016_08_28.tar.gz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;resnet_v1_152.tar.gz&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;76.8&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;93.2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://arxiv.org/abs/1603.05027&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ResNet V2 50&lt;/a&gt;^&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://github.com/tensorflow/models/blob/master/slim/nets/resnet_v2.py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Code&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://download.tensorflow.org/models/resnet_v2_50_2017_04_14.tar.gz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;resnet_v2_50.tar.gz&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;75.6&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;92.8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://arxiv.org/abs/1603.05027&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ResNet V2 101&lt;/a&gt;^&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://github.com/tensorflow/models/blob/master/slim/nets/resnet_v2.py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Code&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://download.tensorflow.org/models/resnet_v2_101_2017_04_14.tar.gz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;resnet_v2_101.tar.gz&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;77.0&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;93.7&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://arxiv.org/abs/1603.05027&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ResNet V2 152&lt;/a&gt;^&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://github.com/tensorflow/models/blob/master/slim/nets/resnet_v2.py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Code&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://download.tensorflow.org/models/resnet_v2_152_2017_04_14.tar.gz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;resnet_v2_152.tar.gz&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;77.8&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;94.1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://arxiv.org/abs/1409.1556.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;VGG 16&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://github.com/tensorflow/models/blob/master/slim/nets/vgg.py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Code&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://download.tensorflow.org/models/vgg_16_2016_08_28.tar.gz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;vgg_16.tar.gz&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;71.5&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;89.8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://arxiv.org/abs/1409.1556.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;VGG 19&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://github.com/tensorflow/models/blob/master/slim/nets/vgg.py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Code&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://download.tensorflow.org/models/vgg_19_2016_08_28.tar.gz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;vgg_19.tar.gz&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;71.1&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;89.8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;推荐一个还算不错的机器学习的数据网站：&lt;a href=&quot;https://www.kaggle.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;kaggle&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;迁移学习&quot;&gt;&lt;a href=&quot;#迁移学习&quot; class=&quot;headerlink&quot; title=&quot;迁移学习&quot;&gt;&lt;/a&gt;迁移学习&lt;/h3&gt;&lt;p&gt;从头开始训练一个复杂的网络是很费时费力的，需要获取符合目标的海量真实数据，并使用性能极强的集群来训练数据，并有足够的耐心等待训练结果。稍有不慎，还需要不断调参，重新再来。这是个枯燥乏味的体力活，并且是在有硬件经济实力的基础上才办得到的。总会看到一些论文里描述自己的模型用 Tesla KXX 跑了多久才训练出了结果，其实在机器学习领域，花费半年甚至更久的时间来调参优化模型是很正常的。&lt;/p&gt;
&lt;p&gt;所以基于已经训练好的模型参数来进行 fine-tuning 后应用到新的模型上是一个省时省力的方案，也被称之为迁移学习。大部分数据是存在相关性的，在图片分类问题中，即便现有模型不包含我们想要的分类，也可以利用已经训练好的权重来进行 fine-tuning，使其对新的类别进行分类。&lt;/p&gt;
&lt;p&gt;一般的做法是将已经训练好的模型权重加载，除去 top 部分（全连接层和 softmax 分类器等），冻结前面层级的权重，只保留想要 fine-tuning 的层级（一般是后面的卷积层），最后根据分类个数自己添加全连接层。训练时只有后面的层级权重才会被修改，前面已经训练好的权重不会改变。这样会很快将正确率提高到 90% 以上。&lt;/p&gt;
&lt;p&gt;详细内容可以参考这篇文章：(&lt;a href=&quot;https://blog.keras.io/building-powerful-image-classification-models-using-very-little-data.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://blog.keras.io/building-powerful-image-classification-models-using-very-little-data.html&lt;/a&gt;)&lt;/p&gt;
&lt;h2 id=&quot;框架选择&quot;&gt;&lt;a href=&quot;#框架选择&quot; class=&quot;headerlink&quot; title=&quot;框架选择&quot;&gt;&lt;/a&gt;框架选择&lt;/h2&gt;&lt;p&gt;有一些知名的框架可供选择：TensorFlow, Torch, Caffee, Theano, Keras…&lt;/p&gt;
&lt;p&gt;不同框架所使用的数据格式不一样，主要区别在于 Channel  通道的位置是在最前还是最后。框架之间的学习成本都不一样，单拿 TensorFlow 来说，其最基础的语法需要一点点构建一张图，而其 &lt;code&gt;tf.contrib.learn&lt;/code&gt; 和 &lt;code&gt;tf.contrib.layers&lt;/code&gt; API 是更高一层的封装，还有 TF-Slim 这种更轻量级的高级封装，几行代码就能干好多事，看起来更屌。但其实目前由于 TensorFlow 的快速迭代，导致不能向下兼容，老代码运行不起来。单拿 TF-Slim 来说，官网 API 文档缺失，Github 的教程代码老旧无法运行，还在使用从 model 库 merge 到 tensorflow 之前的语法。我当时本想用 TF-Slim 快速验证一些模型，结果没想到反而浪费了大量时间，得不偿失。&lt;/p&gt;
&lt;p&gt;Keras 基于 TensorFlow 或 Theano，集成了大量功能，是一种方便快速验证 idea 的高层 API。 内置大量常用网络，很容易上手，语法简洁，功能强大又不失可定制性。强力推荐，官方文档：&lt;a href=&quot;https://keras.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Keras Documentation&lt;/a&gt;，中文文档：&lt;a href=&quot;http://keras-cn.readthedocs.io/en/latest/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Keras 中文文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;无论是哪种框架，几乎都是基于分布式设计的思想，先描述出计算图，然后再向图中填充数据流，使其运转起来，最后得到结果。虽然是使用 Python 语言来描述计算图，但是真正繁重的工作都会提交给底层的后端去处理。但这样也给 debug 带来了困难，因为描述计算图的时候并不能得到数据结果，只能检查出数据格式是否匹配。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;笼统的说，符号主义的计算首先定义各种变量，然后建立一个“计算图”，计算图规定了各个变量之间的计算关系。建立好的计算图需要编译以确定其内部细节，然而，此时的计算图还是一个“空壳子”，里面没有任何实际的数据，只有当你把需要运算的输入放进去后，才能在整个模型中形成数据流，从而形成输出值。&lt;br&gt;    就像用管道搭建供水系统，当你在拼水管的时候，里面是没有水的。只有所有的管子都接完了，才能送水。&lt;br&gt;    – 引自 &lt;a href=&quot;http://keras-cn.readthedocs.io/en/latest/for_beginners/concepts/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://keras-cn.readthedocs.io/en/latest/for_beginners/concepts/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;数据采集&quot;&gt;&lt;a href=&quot;#数据采集&quot; class=&quot;headerlink&quot; title=&quot;数据采集&quot;&gt;&lt;/a&gt;数据采集&lt;/h2&gt;&lt;p&gt;因为网上提供的一些用于训练的海量图片数据都是格式整齐像素较低的图片，比如28x28这种，且特征明显，都为某种物体，这种专用于比赛挑战的图片分类数量一般都是10，100，1000等，更专注于算法的准确率，忽视了真实的场景。&lt;/p&gt;
&lt;p&gt;为了模拟真实场景，我使用 Web 程序调用 iMac 前置摄像头采集 320x240 尺寸的照片。为了更高效采集图片数据，我采用连拍的方式拍摄并保存图片到本地：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://yulingtianxia.com/resources/MachineLearning/training_data.png&quot; alt=&quot;帅是我的无奈&quot;&gt;&lt;/p&gt;
&lt;p&gt;需要去除少量过于模糊和手指不小心跑出屏幕外的图片，尽可能提高数据的质量。&lt;/p&gt;
&lt;p&gt;因为不同平台和浏览器对 Html5 规范支持程度不同，建议在 Mac 上使用 Firefox，Windows 上应该 Chrome 也好使，但没试过。&lt;/p&gt;
&lt;p&gt;图像采集的代码放在 &lt;a href=&quot;https://github.com/yulingtianxia/HandGestureCNN/tree/master/captureImages&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;captureImages&lt;/a&gt; 目录里。&lt;/p&gt;
&lt;h2 id=&quot;Inception-V3-pre-trained-network&quot;&gt;&lt;a href=&quot;#Inception-V3-pre-trained-network&quot; class=&quot;headerlink&quot; title=&quot;Inception V3 pre-trained network&quot;&gt;&lt;/a&gt;Inception V3 pre-trained network&lt;/h2&gt;&lt;p&gt;在 Keras Blog 中，&lt;a href=&quot;https://blog.keras.io/building-powerful-image-classification-models-using-very-little-data.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Building powerful image classification models using very little data&lt;/a&gt; 很好地介绍了如何针对小数据集利用现有的 VGG16 网络 fine-tuning，并在 &lt;a href=&quot;https://www.kaggle.com/c/dogs-vs-cats/data&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dogs vs. Cats&lt;/a&gt; 数据集上取得了 94% 的准确率。&lt;/p&gt;
&lt;p&gt;VGG 系列网络虽然结构简单易理解，但无论是加载权重的耗时还是预测耗时都要比 Inception 系列网络要长，这是因为其权重数据更多。虽然 Inception 系列更复杂，但鉴于其优秀的性能和更胜一筹的准确率，我决定在移动设备上使用 Inception 而非 VGG。&lt;/p&gt;
&lt;p&gt;其实苹果爸爸已经帮我们用 Swift 和 Metal Performance Shaders 实现了个使用 Inception V3 网络预测图像类别的 Demo:&lt;a href=&quot;https://developer.apple.com/library/content/samplecode/MetalImageRecognition/Introduction/Intro.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MetalImageRecognition: Performing Image Recognition with Inception_v3 Network using Metal Performance Shaders Convolutional Neural Network routines&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所以我决定使用 &lt;a href=&quot;https://arxiv.org/pdf/1512.00567v3.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Inception V3 Network&lt;/a&gt; 来 fine-tuning，这样在后续的 MPS 代码编写上就会省很多时间。TensorFlow 官方也有相应 &lt;a href=&quot;https://www.tensorflow.org/tutorials/image_recognition#image-recognition&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;教程&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;bottleneck-features&quot;&gt;&lt;a href=&quot;#bottleneck-features&quot; class=&quot;headerlink&quot; title=&quot;bottleneck features&quot;&gt;&lt;/a&gt;bottleneck features&lt;/h3&gt;&lt;p&gt;下图展示了 Inception V3 网络的结构，其中的 top 部分就是 Final part 所指的部分，我们可以将其替换成我们自己的全连接层，利用前面 Input 预测的结果来作为输入数据，训练我们自己的分类器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://yulingtianxia.com/resources/MachineLearning/Inception V3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;上图中的 Inception mudules 使用的是&lt;a href=&quot;https://arxiv.org/pdf/1512.00567v3.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;论文&lt;/a&gt;中提到的图 6 的结构，实际代码中则使用的图 5。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Keras 有很多使用 ImageNet 预训练的模型，我们这里只需要 Inception V3 去掉 Final part 的剩余部分，一行代码搞定：&lt;/p&gt;
&lt;figure class=&quot;highlight ini&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;model&lt;/span&gt; = applications.InceptionV3(include_top=&lt;span class=&quot;literal&quot;&gt;False&lt;/span&gt;, weights=&lt;span class=&quot;string&quot;&gt;&#39;imagenet&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 TensorFlow 中读取文件数据需要通过 &lt;code&gt;QueueRunner&lt;/code&gt; 和 &lt;code&gt;Coordinator&lt;/code&gt; 构造队列来实现 data flow，比较麻烦：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://yulingtianxia.com/resources/MachineLearning/AnimatedFileQueues.gif&quot; alt=&quot;图片来源 TensorFlow&quot;&gt;&lt;/p&gt;
&lt;p&gt;Keras 真是太方便了，用生成器把图片数据标准化，使用加载好的 &lt;code&gt;model&lt;/code&gt; 预测出结果，并保存到 npy 文件中。&lt;/p&gt;
&lt;figure class=&quot;highlight nix&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;datagen&lt;/span&gt; = ImageDataGenerator(&lt;span class=&quot;attr&quot;&gt;rescale=1.&lt;/span&gt; / &lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;generator&lt;/span&gt; = datagen.flow_from_directory(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   train_data_dir,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;attr&quot;&gt;target_size=(img_width,&lt;/span&gt; img_height),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;attr&quot;&gt;batch_size=batch_size,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;attr&quot;&gt;class_mode=None,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;attr&quot;&gt;shuffle=False)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;bottleneck_features_train&lt;/span&gt; = model.predict_generator(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   generator, nb_train_samples // batch_size)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;np.save(open(&#39;bottleneck_features_train.npy&#39;, &#39;w&#39;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       bottleneck_features_train)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里保存的结果并不是 one-hot 格式的分类结果，只是作为 Final part 的输入，所以叫做 bottleneck features。&lt;/p&gt;
&lt;p&gt;下一步就是构建自己的 Final part，比如我们这里想要做个五分类的模型：&lt;/p&gt;
&lt;figure class=&quot;highlight gams&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;model&lt;/span&gt; = Sequential()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;model&lt;/span&gt;.add(Flatten(input_shape=train_data.shape[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;model&lt;/span&gt;.add(Dense(&lt;span class=&quot;number&quot;&gt;256&lt;/span&gt;, activation=&lt;span class=&quot;string&quot;&gt;&#39;relu&#39;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;model&lt;/span&gt;.add(Dropout(&lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;model&lt;/span&gt;.add(Dense(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, activation=&lt;span class=&quot;string&quot;&gt;&#39;softmax&#39;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;Flatten&lt;/code&gt; 和 &lt;code&gt;Dropout&lt;/code&gt; 层并不会改变数据，是没有权重的层。所以这里有两个全连接层，最后一层有五个节点，输出一个长度为 5 的 one-hot 格式向量。&lt;/p&gt;
&lt;p&gt;这里之所以使用 bottleneck features 作为输入数据来进行训练，是为了节省运算资源。如果采用冻结前面部分网络的方式，虽然被冻结的网络权重不会变，但每跑一次的运算量都很大，而且结果是相同的。所以采取预测一次 bottleneck features，离线保存的方式。在机器学习中减少 loss 提升准确率常用的方法就是梯度下降法，实际应用中使用 mini-batch 梯度下降法来平衡计算性能和 loss 收敛效果。这里的 batch_size 就是每次下降所使用数据批次的数量。&lt;/p&gt;
&lt;figure class=&quot;highlight nix&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;model.compile(&lt;span class=&quot;attr&quot;&gt;optimizer=optimizers.SGD(lr=1e-4,&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;momentum=0.9),&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &lt;span class=&quot;attr&quot;&gt;loss=&#39;categorical_crossentropy&#39;,&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;metrics=[&#39;accuracy&#39;])&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;model.fit(train_data, train_labels,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;attr&quot;&gt;epochs=epochs,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;attr&quot;&gt;batch_size=batch_size,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;attr&quot;&gt;validation_data=(validation_data,&lt;/span&gt; validation_labels))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;model.save_weights(top_model_weights_path)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里训练的是我们自己添加的两个全连接层，以便于拟合我们自己的数据。&lt;/p&gt;
&lt;p&gt;这部分的源码放在 &lt;a href=&quot;https://github.com/yulingtianxia/HandGestureCNN/blob/master/Train/bottleneck_features_train_inceptionv3.py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;bottleneck_features_train_inceptionv3.py&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Fine-tuning&quot;&gt;&lt;a href=&quot;#Fine-tuning&quot; class=&quot;headerlink&quot; title=&quot;Fine-tuning&quot;&gt;&lt;/a&gt;Fine-tuning&lt;/h3&gt;&lt;p&gt;为了达到更好的效果，可以解冻后面几层。看了下 Inception V3 的网络结构，最后一个 tower 拥有 9 个卷积层，比较复杂。虽然理论上 fine-tuneing 整个 tower 是可行的，但是计算开销很大，用我的 iMac 4 GHz Intel Core i7 八核跑一个月都不行。&lt;/p&gt;
&lt;p&gt;现在需要加载预训练网络的权重到 &lt;code&gt;base_model&lt;/code&gt; 中，并将其与 &lt;code&gt;top_model&lt;/code&gt; 拼在一起。Keras 中有两种描述模型，一种是 &lt;code&gt;Sequential&lt;/code&gt;，另一种是带有函数式 API 的 &lt;code&gt;Model&lt;/code&gt;。前者层与层之前连接的入度和出度都为 1，后者就很灵活很随意了。这里构建 &lt;code&gt;top_model&lt;/code&gt; 使用的 &lt;code&gt;Sequential&lt;/code&gt;，然后使用 &lt;code&gt;Model&lt;/code&gt; 统一输入和输出，起到连接的作用。最后通过设置 &lt;code&gt;trainable&lt;/code&gt; 属性来冻结部分网络。为了让准确率更高，会将上一步 bottleneck features 训练好的权重作为 &lt;code&gt;top_model&lt;/code&gt; 的初始权重。&lt;/p&gt;
&lt;figure class=&quot;highlight nix&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# build the InceptionV3 network&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;input_tensor&lt;/span&gt; = Input(&lt;span class=&quot;attr&quot;&gt;shape=(img_height,&lt;/span&gt; img_width, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;base_model&lt;/span&gt; = applications.InceptionV3(&lt;span class=&quot;attr&quot;&gt;weights=&#39;imagenet&#39;,&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;include_top=False,&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;input_tensor=input_tensor)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&#39;Model loaded.&#39;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# build a classifier model to put on top of the convolutional model&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;top_model&lt;/span&gt; = Sequential()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;top_model.add(Flatten(&lt;span class=&quot;attr&quot;&gt;input_shape=base_model.output_shape[1:]))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;top_model.add(Dense(&lt;span class=&quot;number&quot;&gt;256&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;activation=&#39;relu&#39;))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;top_model.add(Dropout(&lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;top_model.add(Dense(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;activation=&#39;softmax&#39;))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# note that it is necessary to start with a fully-trained&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# classifier, including the top classifier,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# in order to successfully do fine-tuning&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;top_model.load_weights(top_model_weights_path)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# add the model on top of the convolutional base&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;model&lt;/span&gt; = Model(&lt;span class=&quot;attr&quot;&gt;inputs=base_model.input,&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;outputs=top_model(base_model.output))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# set the first xx layers (up to the last conv block)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# to non-trainable (weights will not be updated)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for layer &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; model.layers[:len(base_model.layers)-&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    layer.&lt;span class=&quot;attr&quot;&gt;trainable&lt;/span&gt; = False&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;有关 Keras 两种模型的概念可以查看 &lt;a href=&quot;https://keras.io/models/about-keras-models/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;About Keras models&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;可以通过设置数据生成器的一些参数来提升数据的随机性，降低过拟合。&lt;code&gt;ImageDataGenerator&lt;/code&gt; 针对图片有很多预设的处理方式，例如平移，旋转，缩放，反转等。TensorFlow 中也有类似的图片预处理功能，但 API 使用上没 Keras 便利。有关图片预处理的内容可以参考文档 &lt;a href=&quot;https://keras.io/preprocessing/image/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Image Preprocessing&lt;/a&gt;，这里仅针对某些方式进行随意预处理，提升数据：&lt;/p&gt;
&lt;figure class=&quot;highlight nix&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;train_datagen&lt;/span&gt; = ImageDataGenerator(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attr&quot;&gt;rescale=1./255,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  	&lt;span class=&quot;attr&quot;&gt;rotation_range=40,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  	&lt;span class=&quot;attr&quot;&gt;width_shift_range=0.2,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  	&lt;span class=&quot;attr&quot;&gt;height_shift_range=0.2,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  	&lt;span class=&quot;attr&quot;&gt;shear_range=0.2,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  	&lt;span class=&quot;attr&quot;&gt;zoom_range=0.2,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  	&lt;span class=&quot;attr&quot;&gt;horizontal_flip=True,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  	&lt;span class=&quot;attr&quot;&gt;fill_mode=&#39;nearest&#39;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Keras 可以根据数据的文件夹自动分类打标签，所以我将图片按文件夹归类就可以了，很方便。&lt;/p&gt;
&lt;p&gt;我一共使用了 1808 张图片作为训练集，192 张图片作为交叉验证集。经过了 50 个 epoch 后，训练集准确率 96.26%，交叉验证集准确率 73.86%。&lt;/p&gt;
&lt;p&gt;这部分源码放在 &lt;a href=&quot;https://github.com/yulingtianxia/HandGestureCNN/blob/master/Train/finetune_inceptionv3.py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;finetune_inceptionv3.py&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Convert-HDF5-to-binary-dat-files&quot;&gt;&lt;a href=&quot;#Convert-HDF5-to-binary-dat-files&quot; class=&quot;headerlink&quot; title=&quot;Convert HDF5 to binary .dat files&quot;&gt;&lt;/a&gt;Convert HDF5 to binary .dat files&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;HDF（英语：Hierarchical Data Format）指一种为存储和处理大容量科学数据设计的文件格式及相应库文件。HDF最早由NCSA开发，目前在非盈利组织 HDF 小组维护下继续发展。当前流行的版本是HDF5。&lt;br&gt;    – 维基百科&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.hdfgroup.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HDF Group&lt;/a&gt; 提供了可视化查看 HDF 文件的工具：&lt;a href=&quot;https://support.hdfgroup.org/products/java/release/download.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HDFView&lt;/a&gt;，因为是用 java 写的，所以是跨平台的。Mac 版本有个已知的 bug：双击一个 &lt;code&gt;.h5&lt;/code&gt; 文件后 HDFView 界面是空的，需要把 &lt;code&gt;.h5&lt;/code&gt; 文件拖动到 HDFView 左边栏才能打开。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://yulingtianxia.com/resources/MachineLearning/HDFView.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Keras 可以将训练处的权重结果高存成 HDF5 格式，但苹果提供的 Demo 使用的权重文件是 memory-mapped 二进制文件，每层网络都对应一个 &lt;code&gt;.dat&lt;/code&gt; 文件。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://support.hdfgroup.org/products/hdf5_tools/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SOFTWARE USING HDF5&lt;/a&gt; 列举了很多用于操作 HDF 文件和格式转换的工具。可以用一些工具将存有权重的 HDF 文件先转化成若干 &lt;code&gt;.dat&lt;/code&gt; 文件，然后再打包到 iOS App 中。还有一种做法是将 HDF 文件打包到 iOS App 中，然后在客户端完成格式导出。&lt;a href=&quot;https://github.com/aleph7/HDF5Kit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HDF5Kit&lt;/a&gt; 是对 &lt;a href=&quot;https://support.hdfgroup.org/ftp/HDF5/releases/hdf5-1.10/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HDF 源码&lt;/a&gt;的 Swift 封装，不过还有些 crash。我采用了第二种做法，因为我懒，替换权重文件的时候只需要一个 HDF 文件，不用替换一堆 &lt;code&gt;.dat&lt;/code&gt; 文件🙄。实际应用中千万别这么干。&lt;/p&gt;
&lt;p&gt;可以根据上图中 HDFView 展示的树状层级递归遍历 Group，并拼接好正确的名称。比如 “bias:0” 和 “kernel:0”。将 HDF5 转换成二进制文件的代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Read parameters from HDF5 file and store to dat file in Tmp directory&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;extractHDF5&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(h5Name: String)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// MARK: Parse HDF5 file&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; path = &lt;span class=&quot;type&quot;&gt;Bundle&lt;/span&gt;.main.path(forResource: h5Name, ofType: &lt;span class=&quot;string&quot;&gt;&quot;h5&quot;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;fatalError&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Failed to get a path&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; file = &lt;span class=&quot;type&quot;&gt;File&lt;/span&gt;.open(path, mode: .readOnly) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;fatalError&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Failed to open file at &lt;span class=&quot;subst&quot;&gt;\(path)&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; layerNamesStringAttribute = file.openStringAttribute(&lt;span class=&quot;string&quot;&gt;&quot;layer_names&quot;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;fatalError&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Failed to open attribute &#39;layer_names&#39;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; layerNames = &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;? layerNamesStringAttribute.read() &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;fatalError&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Failed to get layer names&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// count used for file name later&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; countOfConvLayer = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; countOfFcLayer   = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; partOfFileName = &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; layerName &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; layerNames &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; layerGroup = file.openGroup(layerName) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;fatalError&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Failed to open group of &lt;span class=&quot;subst&quot;&gt;\(layerName)&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; objectName &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; layerGroup.objectNames() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// only the layer that has parameters remain&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; wtDataset = layerGroup.openFloatDataset(objectName + &lt;span class=&quot;string&quot;&gt;&quot;/kernel:0&quot;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;built_in&quot;&gt;fatalError&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Failed to open data set of &lt;span class=&quot;subst&quot;&gt;\(objectName)&lt;/span&gt;/kernel:0&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; bsDataset = layerGroup.openFloatDataset(objectName + &lt;span class=&quot;string&quot;&gt;&quot;/bias:0&quot;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;built_in&quot;&gt;fatalError&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Failed to open data set of &lt;span class=&quot;subst&quot;&gt;\(objectName)&lt;/span&gt;/bias:0&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; dimension = wtDataset.space.dims&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; wtArray = &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;? wtDataset.read() &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;built_in&quot;&gt;fatalError&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Failed to read data set of &lt;span class=&quot;subst&quot;&gt;\(objectName)&lt;/span&gt;/kernel:0&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; bsArray = &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;? bsDataset.read() &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;built_in&quot;&gt;fatalError&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Failed to read data set of &lt;span class=&quot;subst&quot;&gt;\(objectName)&lt;/span&gt;/bias:0&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; wtLength = wtArray.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; bsLength = bsArray.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; dimension.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// weights for convolution layer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                wtArray = &lt;span class=&quot;type&quot;&gt;SwapAxes&lt;/span&gt;.for4dFlatArray(originalArray: wtArray, axis1: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, axis2: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, dimensionOfArray: &amp;amp;dimension)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                wtArray = &lt;span class=&quot;type&quot;&gt;SwapAxes&lt;/span&gt;.for4dFlatArray(originalArray: wtArray, axis1: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, axis2: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, dimensionOfArray: &amp;amp;dimension)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                wtArray = &lt;span class=&quot;type&quot;&gt;SwapAxes&lt;/span&gt;.for4dFlatArray(originalArray: wtArray, axis1: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, axis2: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, dimensionOfArray: &amp;amp;dimension)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                countOfConvLayer += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                partOfFileName = &lt;span class=&quot;string&quot;&gt;&quot;conv&quot;&lt;/span&gt; + &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;(countOfConvLayer)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; dimension.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// weights for fully connected layer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                wtArray = &lt;span class=&quot;type&quot;&gt;SwapAxes&lt;/span&gt;.for2dFlatArray(originalArray: wtArray, axis1: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, axis2: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, dimensionOfArray: &amp;amp;dimension)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                countOfFcLayer += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                partOfFileName = &lt;span class=&quot;string&quot;&gt;&quot;fc&quot;&lt;/span&gt; + &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;(countOfFcLayer)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;built_in&quot;&gt;fatalError&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Dataset&#39;s dimension is neither 4 (convolution layer) nor 2 (fully connected layer)&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; wtData = &lt;span class=&quot;type&quot;&gt;NSData&lt;/span&gt;(bytes: &amp;amp;wtArray, length: wtLength * &lt;span class=&quot;type&quot;&gt;MemoryLayout&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;Float&lt;/span&gt;&amp;gt;.size)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; bsData = &lt;span class=&quot;type&quot;&gt;NSData&lt;/span&gt;(bytes: &amp;amp;bsArray, length: bsLength * &lt;span class=&quot;type&quot;&gt;MemoryLayout&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;Float&lt;/span&gt;&amp;gt;.size)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 写入数据到文件...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Metal-Performance-Shaders&quot;&gt;&lt;a href=&quot;#Metal-Performance-Shaders&quot; class=&quot;headerlink&quot; title=&quot;Metal Performance Shaders&quot;&gt;&lt;/a&gt;Metal Performance Shaders&lt;/h2&gt;&lt;h3 id=&quot;MPS-简介&quot;&gt;&lt;a href=&quot;#MPS-简介&quot; class=&quot;headerlink&quot; title=&quot;MPS 简介&quot;&gt;&lt;/a&gt;MPS 简介&lt;/h3&gt;&lt;p&gt;Metal Performance Shaders 简称 MPS，可以为使用 Metal 技术的 App 提供底层高性能 GPU 运算接口。最初苹果提供的 Shader 语言本来是很底层很生涩的，后来为 iOS 提供了原生支持的 API，可以用 Swift 或 OC 来调用底层接口了。iOS 9 的 MPS 提供了图片特效处理和 Metal 纹理相关的 API，iOS 10 的 MPS 新增了有关 CNN 和矩阵乘法的 API。不过目前苹果只开放了 CNN 的预测功能，如果想要在 iOS 10 上训练一个 CNN，那就只能借助第三方工具了。&lt;/p&gt;
&lt;p&gt;苹果的 BNNS 同样提供了创建 CNN 的 API，而且也只能使用训练好的权重进行预测。但仅仅是对 CPU 进行了优化。因为 OpenGL 的限制，其性能与 Metal 相比并不占优势。OpenCL 在 iOS 上是私有框架。所以说目前看来，不考虑系统兼容性(iOS 10)和资源限制(arm64)，Metal 技术是发挥 GPU 运算优势的最好选择。&lt;/p&gt;
&lt;p&gt;MPS 系统原生支持不用担心安装包增量问题，并且使用 Metal 技术使用 GPU 加速运算，功耗发热少。MPS 目前的缺点是不支持网络的训练和必须 HardCode 网络结构，但面对复杂度较低的神经网络时还是很实用的。毕竟 TensorFlow 在 iOS 上只能用 CPU 计算，且编译费时费力，安装包增量巨大。&lt;/p&gt;
&lt;p&gt;MPS 在我的 iPhone 6s Plus 上性能很好，发热也少，可以通过神经网络实时预测出结果。这是 &lt;a href=&quot;https://github.com/shu223/iOS-10-Sampler&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS-10-Sampler&lt;/a&gt; 项目的效果，它是在苹果官方 Demo &lt;a href=&quot;https://developer.apple.com/library/content/samplecode/MetalImageRecognition/Introduction/Intro.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MetalImageRecognition&lt;/a&gt; 基础上稍微改进拍摄功能的用户体验，MPS 的部分未做任何改动。我基于它和 &lt;a href=&quot;https://github.com/kazoo-kmt/MPSCNNfeeder&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MPSCNNfeeder&lt;/a&gt; 实现了 &lt;a href=&quot;https://github.com/yulingtianxia/HandGestureCNN/tree/master/HandGestureCNN&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HandGestureCNN&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/shu223/iOS-10-Sampler/blob/master/README_resources/imagerecog.gif?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;苹果给了一个 MPS 的 HelloWorld： &lt;a href=&quot;https://developer.apple.com/library/content/samplecode/MPSCNNHelloWorld/Introduction/Intro.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MPSCNNHelloWorld: Simple Digit Detection Convolution Neural Networks (CNN)&lt;/a&gt;，恰好对应着机器学习领域的 HelloWorld MNIST。可以通过查看这个 Demo 的源码来快速上手 MPS 的用法。&lt;/p&gt;
&lt;p&gt;其实总体来说并不是很复杂，但有几个重要的地方需要我们自己去解决：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据处理，也就是模型文件的数据格式需要自己去解析。不同深度学习框架导出的模型权重文件格式都不一样，会涉及到比较底层的位读写。这里有一定工作量。&lt;/li&gt;
&lt;li&gt;使用卷积神经网络预测模型的时候，会涉及到 padding，这部分需要自己计算。输出数据体在空间上的尺寸可以通过输入数据体尺寸（W），卷积层中神经元的感受野尺寸（F），步长（S）和零填充的数量（P）的函数来计算。输出数据体的空间尺寸为 (W-F +2P)/S+1。这里说的是某个维度，单指宽或长。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;MPSImage&lt;/code&gt; 是为了突破 &lt;code&gt;MTLTexture&lt;/code&gt; 最大维度为 4 （RGBA）的限制，搞了个 workaround，就是用多个切片模拟多维度。如果有 N 个维度，那么切片数量为 (N+3)/4。比如下图为 N = 9 的情况。所以涉及到数据对齐的事情，预测后的数据需要处理下。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://docs-assets.developer.apple.com/published/48ad0af3fd/b6d1d091-162c-418d-bc2e-0b6f3105c126.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;好在苹果提供的 Demo 里已经对于后两个问题有了可以参考的代码，第一个问题其实是个矩阵转换的操作。 TensorFlow 卷积核权重的顺序为 [kH kW iC oC]，而 MPS 接受的权重为 [oC kH kW iC] 形式。而我使用 Keras 的时候将 TensorFlow 作为后端，所以需要转换下权重格式。矩阵转换在 python 里很容易，还好我找到了 Swift 版本的实现：&lt;a href=&quot;https://github.com/kazoo-kmt/MPSCNNfeeder/blob/master/swapaxes.swift&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SwapAxes&lt;/a&gt;，直接拿过来用了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PS: 科普下，[oC kH kW iC] 是四维数组（矩阵） [outputChannels][kernelHeight][kernelWidth][inputChannels/groups] 的 shape。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;使用-MPS-构建网络并预测&quot;&gt;&lt;a href=&quot;#使用-MPS-构建网络并预测&quot; class=&quot;headerlink&quot; title=&quot;使用 MPS 构建网络并预测&quot;&gt;&lt;/a&gt;使用 MPS 构建网络并预测&lt;/h3&gt;&lt;p&gt;MPS 预测的执行流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取可用的 device&lt;/li&gt;
&lt;li&gt;从 &lt;code&gt;device&lt;/code&gt; 获取 &lt;code&gt;commandQueue&lt;/code&gt;，从 &lt;code&gt;commandQueue&lt;/code&gt; 获取 &lt;code&gt;commandBuffer&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;构建网络模型和输入数据的 &lt;code&gt;MSPImage&lt;/code&gt; 对象&lt;/li&gt;
&lt;li&gt;调用网络每层的 &lt;code&gt;encode&lt;/code&gt; 方法，输入为 &lt;code&gt;commandBuffer&lt;/code&gt; 和上一层网络输出的 &lt;code&gt;MSPImage&lt;/code&gt; 对象。&lt;/li&gt;
&lt;li&gt;提交 &lt;code&gt;commandBuffer&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;等待输出结果，并处理成 one-hot 格式。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;剩下的工作就是修改工程中的 &lt;code&gt;Inception3Net.swift&lt;/code&gt; 文件，使其网络结构与我们用 Keras 搭建的网络结构一样即可。前面提到过，&lt;code&gt;Flatten&lt;/code&gt; 和 &lt;code&gt;Dropout&lt;/code&gt; 没有权重，不改变数据。&lt;code&gt;Flatten&lt;/code&gt; 其实就是 &lt;code&gt;reshape&lt;/code&gt; 操作，在 MPS 中不需要特意做 &lt;code&gt;reshape&lt;/code&gt; 操作也没有 &lt;code&gt;Flatten&lt;/code&gt; 层，&lt;code&gt;MPSImage&lt;/code&gt; 被描述成什么 shape，数据就会被排列成那个 shape。&lt;code&gt;Dropout&lt;/code&gt; 层在训练的时候按一定几率丢弃结果，在预测模型的时候根本用不到。&lt;/p&gt;
&lt;p&gt;回顾下之前用 Keras 写的全连接层结构的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight gams&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;model&lt;/span&gt; = Sequential()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;model&lt;/span&gt;.add(Flatten(input_shape=train_data.shape[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;model&lt;/span&gt;.add(Dense(&lt;span class=&quot;number&quot;&gt;256&lt;/span&gt;, activation=&lt;span class=&quot;string&quot;&gt;&#39;relu&#39;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;model&lt;/span&gt;.add(Dropout(&lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;model&lt;/span&gt;.add(Dense(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, activation=&lt;span class=&quot;string&quot;&gt;&#39;softmax&#39;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;转换成 MPS 的代码后差不多是这个样子（省略无关代码）：&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let device = inputCommandQueue.device&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let relu = MPSCNNNeuronReLU(&lt;span class=&quot;string&quot;&gt;device:&lt;/span&gt; device!, &lt;span class=&quot;string&quot;&gt;a:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let softmax = MPSCNNSoftMax(&lt;span class=&quot;string&quot;&gt;device:&lt;/span&gt; device!)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let sftid = MPSImageDescriptor(&lt;span class=&quot;string&quot;&gt;channelFormat:&lt;/span&gt; textureFormat, &lt;span class=&quot;string&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;  , &lt;span class=&quot;string&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;  , &lt;span class=&quot;string&quot;&gt;featureChannels:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// logits&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let fc0 = SlimMPSCNNFullyConnected(&lt;span class=&quot;string&quot;&gt;kernelWidth:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;                             kernelHeight:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;                             inputFeatureChannels:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2048&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;                             outputFeatureChannels:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;256&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;                             neuronFilter:&lt;/span&gt; relu,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;                             device:&lt;/span&gt; device,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;                             kernelParamsBinaryName:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;fc1&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let fc1 = SlimMPSCNNFullyConnected(&lt;span class=&quot;string&quot;&gt;kernelWidth:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;                             kernelHeight:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;                             inputFeatureChannels:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;256&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;                             outputFeatureChannels:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;                             neuronFilter:&lt;/span&gt; nil,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;                             device:&lt;/span&gt; device,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;                             kernelParamsBinaryName:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;fc2&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let image10 = ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let sftImage    = MPSImage(&lt;span class=&quot;string&quot;&gt;device:&lt;/span&gt; device!, &lt;span class=&quot;string&quot;&gt;imageDescriptor:&lt;/span&gt; sftid)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// MPSImageDescriptor for final logits generating layers&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let fc0id = MPSImageDescriptor(&lt;span class=&quot;string&quot;&gt;channelFormat:&lt;/span&gt; textureFormat, &lt;span class=&quot;string&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;featureChannels:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;256&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var fc0Image, &lt;span class=&quot;string&quot;&gt;fc1Image :&lt;/span&gt; MPSTemporaryImage!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func logits_layer(&lt;span class=&quot;string&quot;&gt;commandBuffer:&lt;/span&gt; MTLCommandBuffer)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// These images are only needed in this layer and will not be read by the CPU or&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// outside of the command bufer, so we can allocate them as MPSTemporaryImages and&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// save the CPU cost and memory size of allocating reserved storage for them.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// These objects can not be reused outside of the command buffer, which is why&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// we did not make them in the init(withDevice:commandQueue:) call.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// Temporary images are designed to be efficiently created as needed, used a few times&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// and thrown away almost immediately&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   fc0Image     = MPSTemporaryImage(&lt;span class=&quot;string&quot;&gt;commandBuffer:&lt;/span&gt; commandBuffer, &lt;span class=&quot;string&quot;&gt;imageDescriptor:&lt;/span&gt; fc0id)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   fc1Image     = MPSTemporaryImage(&lt;span class=&quot;string&quot;&gt;commandBuffer:&lt;/span&gt; commandBuffer, &lt;span class=&quot;string&quot;&gt;imageDescriptor:&lt;/span&gt; sftid)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// encode layers to metal commandBuffer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   fc0.encode    (&lt;span class=&quot;string&quot;&gt;commandBuffer:&lt;/span&gt; commandBuffer, &lt;span class=&quot;string&quot;&gt;sourceImage:&lt;/span&gt; image10, &lt;span class=&quot;string&quot;&gt;destinationImage:&lt;/span&gt; fc0Image)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   fc1.encode    (&lt;span class=&quot;string&quot;&gt;commandBuffer:&lt;/span&gt; commandBuffer, &lt;span class=&quot;string&quot;&gt;sourceImage:&lt;/span&gt; fc0Image, &lt;span class=&quot;string&quot;&gt;destinationImage:&lt;/span&gt; fc1Image)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   softmax.encode(&lt;span class=&quot;string&quot;&gt;commandBuffer:&lt;/span&gt; commandBuffer, &lt;span class=&quot;string&quot;&gt;sourceImage:&lt;/span&gt; fc1Image, &lt;span class=&quot;string&quot;&gt;destinationImage:&lt;/span&gt; sftImage)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;这是一篇行外人看不懂，行内人觉得水，我自己觉得收获满满的实践笔记。并没有花大量篇幅总结Machine Learning 的基础知识，也没有逐个讲述框架 API 的使用，更没有列一堆公式和数学定义。。。因为这种知识体系大而全的文章，网上不胜枚举，而且肯定比我总结的好。本着一个小白去探索世界的心态，把自己从理论学习到训练模型再到 iOS 上的预测的实践流程记录下来。很多枯燥耗时的学习 ML、TF 和配置环境的过程都省略掉了。&lt;/p&gt;
&lt;p&gt;最后建议如果有条件的话，还是用配置较高的集群或者云服务来训练模型，节省程序员宝贵的时间。如果不能做到自己提出创新有效的网络模型，其实深度学习的大量工作就是调参、采集数据、看别人论文如何改参数和网络结构，然后等待机器训练结果。。。反复循环。。。&lt;/p&gt;
&lt;p&gt;神经网络不是真的模拟出人脑的生物特征，CNN 跟人眼扫视世界或人脑辨别物体其实差很多，深度学习只是尽力让机器拟合出想要的结果罢了，离真正的人工智能还差远了。所以不要被铺天盖地的吹嘘洗脑了，一个 AlphaGo 就能又让一大堆所谓的科技媒体高潮出机器快要统治人类了，不要老想搞个大新闻！&lt;/p&gt;
&lt;p&gt;深度学习发展很快，要学习的内容还有很多。学习得越多，就发现自己越是无知，以至于怀疑自己的智商和精力了。&lt;/p&gt;
&lt;h2 id=&quot;Reference&quot;&gt;&lt;a href=&quot;#Reference&quot; class=&quot;headerlink&quot; title=&quot;Reference&quot;&gt;&lt;/a&gt;Reference&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.coursera.org/learn/machine-learning/home&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Coursera Machine Learning&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.tensorflow.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TensorFlow&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://keras-cn.readthedocs.io/en/latest/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Keras 中文文档&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://keras.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Keras Documentation&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://image-net.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ImageNet&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.kaggle.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;kaggle&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://cs231n.stanford.edu&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CS231n: Convolutional Neural Networks for Visual Recognition&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://cs231n.github.io/convolutional-networks/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Convolutional Neural Networks (CNNs / ConvNets)&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://machinethink.net/blog/convolutional-neural-networks-on-the-iphone-with-vggnet/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Convolutional neural networks on the iPhone with VGGNet&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://blog.keras.io/building-powerful-image-classification-models-using-very-little-data.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Building powerful image classification models using very little data&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.hdfgroup.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HDF Group&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://developer.apple.com/reference/metalperformanceshaders&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MetalPerformanceShaders&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://developer.apple.com/reference/accelerate/bnns&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BNNS&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/aleph7/HDF5Kit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HDF5Kit&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/shu223/iOS-10-Sampler&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS-10-Sampler&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/kazoo-kmt/MPSCNNfeeder&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MPSCNNfeeder&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近一个月从零开始自学了下有关 iOS 上的机器学习相关知识，亲身实践了从数据采集到训练模型再到移动端预测的流程。理论知识学习路径为：&lt;strong&gt;机器学习-&amp;gt;深度学习-&amp;gt;迁移学习&lt;/strong&gt;；实践框架学习路径为：&lt;strong&gt;TensorFlow-&amp;gt;Keras-&amp;gt;MPS(iOS 10)&lt;/strong&gt;。最终完成一个简单的手势图像五分类问题，并预测 iOS 摄像头采集的图片。最终结果，训练集准确率 96.26%，交叉验证集准确率 73.86%。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yulingtianxia.com/tags/iOS/"/>
    
      <category term="Machine Leaning" scheme="http://yulingtianxia.com/tags/Machine-Leaning/"/>
    
      <category term="Metal" scheme="http://yulingtianxia.com/tags/Metal/"/>
    
  </entry>
  
</feed>
